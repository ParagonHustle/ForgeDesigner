Combined Code Files - Thu 17 Apr 2025 08:46:37 PM UTC


=== client/src/components/ui/accordion.tsx ===
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


=== client/src/components/ui/alert-dialog.tsx ===
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


=== client/src/components/ui/alert.tsx ===
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


=== client/src/components/ui/aspect-ratio.tsx ===
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }


=== client/src/components/ui/avatar.tsx ===
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }


=== client/src/components/ui/badge.tsx ===
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }


=== client/src/components/ui/breadcrumb.tsx ===
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}


=== client/src/components/ui/button.tsx ===
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


=== client/src/components/ui/calendar.tsx ===
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }


=== client/src/components/ui/card.tsx ===
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


=== client/src/components/ui/carousel.tsx ===
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}


=== client/src/components/ui/chart.tsx ===
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}


=== client/src/components/ui/checkbox.tsx ===
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }


=== client/src/components/ui/collapsible.tsx ===
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }


=== client/src/components/ui/command.tsx ===
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}


=== client/src/components/ui/context-menu.tsx ===
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}


=== client/src/components/ui/dialog.tsx ===
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}


=== client/src/components/ui/drawer.tsx ===
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}


=== client/src/components/ui/dropdown-menu.tsx ===
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}


=== client/src/components/ui/form.tsx ===
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}


=== client/src/components/ui/hover-card.tsx ===
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }


=== client/src/components/ui/input-otp.tsx ===
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }


=== client/src/components/ui/input.tsx ===
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


=== client/src/components/ui/label.tsx ===
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


=== client/src/components/ui/menubar.tsx ===
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}


=== client/src/components/ui/navigation-menu.tsx ===
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}


=== client/src/components/ui/pagination.tsx ===
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}


=== client/src/components/ui/popover.tsx ===
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }


=== client/src/components/ui/progress.tsx ===
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }


=== client/src/components/ui/radio-group.tsx ===
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }


=== client/src/components/ui/resizable.tsx ===
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }


=== client/src/components/ui/scroll-area.tsx ===
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }


=== client/src/components/ui/select.tsx ===
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


=== client/src/components/ui/separator.tsx ===
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }


=== client/src/components/ui/sheet.tsx ===
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


=== client/src/components/ui/sidebar.tsx ===
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        if (setOpenProp) {
          return setOpenProp?.(
            typeof value === "function" ? value(open) : value
          )
        }

        _setOpen(value)

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${open}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full text-sidebar-foreground has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}


=== client/src/components/ui/skeleton.tsx ===
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }


=== client/src/components/ui/slider.tsx ===
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }


=== client/src/components/ui/switch.tsx ===
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }


=== client/src/components/ui/table.tsx ===
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


=== client/src/components/ui/tabs.tsx ===
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }


=== client/src/components/ui/textarea.tsx ===
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }


=== client/src/components/ui/toast.tsx ===
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}


=== client/src/components/ui/toaster.tsx ===
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}


=== client/src/components/ui/toggle-group.tsx ===
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }


=== client/src/components/ui/toggle.tsx ===
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }


=== client/src/components/ui/tooltip.tsx ===
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


=== client/src/components/ui/AICompanion.tsx ===
import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { MessageCircle } from 'lucide-react';

const AICompanion = () => {
  const [open, setOpen] = useState(false);
  const [messages, setMessages] = useState<{role: 'user' | 'assistant', content: string}[]>([
    { role: 'assistant', content: "I'm your Aura Guide! How can I assist you with your journey through The Forge today?" }
  ]);
  const [input, setInput] = useState('');

  const handleSendMessage = () => {
    if (!input.trim()) return;
    
    const userMessage = { role: 'user' as const, content: input };
    setMessages([...messages, userMessage]);
    setInput('');
    
    // Simulate AI response
    setTimeout(() => {
      const responses = [
        "To maximize your Aura fusion success, try matching elements when possible.",
        "Don't forget to collect your farming resources regularly!",
        "Characters gain passive bonuses from equipped Auras even when inactive.",
        "The Forge level determines the maximum level your characters can reach.",
        "Upgrade your Townhall to unlock more simultaneous tasks.",
        "Rare auras have a higher chance of transferring skills during fusion.",
        "Visit the Black Market often - the inventory refreshes every 24 hours.",
        "Complete Bounty Board quests for valuable Soul Shards.",
        "Characters with high Vitality perform better in longer dungeon runs."
      ];
      
      const aiResponse = { 
        role: 'assistant' as const, 
        content: responses[Math.floor(Math.random() * responses.length)] 
      };
      setMessages(prevMessages => [...prevMessages, aiResponse]);
    }, 1000);
  };

  return (
    <>
      {/* Mobile version - just the icon */}
      <Dialog open={open} onOpenChange={setOpen}>
        <DialogTrigger asChild>
          <button className="w-10 h-10 md:w-auto md:h-auto flex items-center justify-center mt-2">
            <img 
              src="https://cdn.pixabay.com/photo/2020/06/01/22/23/eye-5248678_960_720.jpg" 
              alt="AI Assistant" 
              className="w-10 h-10 rounded-full border-2 border-[#00B9AE]"
            />
            <span className="ml-2 text-sm hidden md:block">Aura Guide</span>
          </button>
        </DialogTrigger>
        
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-md">
          <DialogHeader>
            <DialogTitle className="text-[#00B9AE] font-cinzel text-xl">Aura Guide</DialogTitle>
          </DialogHeader>
          
          <div className="mt-4 h-80 overflow-y-auto p-2 bg-[#1F1D36]/50 rounded-md">
            {messages.map((msg, index) => (
              <div 
                key={index} 
                className={`mb-3 ${
                  msg.role === 'assistant' 
                    ? 'bg-[#432874]/20 border-l-2 border-[#00B9AE]' 
                    : 'bg-[#432874]/10 border-r-2 border-[#FF9D00]'
                } p-2 rounded-md`}
              >
                <p className="text-sm">{msg.content}</p>
              </div>
            ))}
          </div>
          
          <div className="flex mt-4">
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
              placeholder="Ask your AI companion..."
              className="flex-1 bg-[#1F1D36]/80 border border-[#432874]/30 rounded-l-lg px-3 py-2 text-sm focus:outline-none focus:border-[#00B9AE]"
            />
            <Button 
              onClick={handleSendMessage}
              className="bg-[#00B9AE] hover:bg-[#00B9AE]/80 rounded-r-lg rounded-l-none"
            >
              <MessageCircle className="h-5 w-5" />
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
};

export default AICompanion;


=== client/src/components/ui/OfferBanner.tsx ===
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { useAuthStore } from '@/lib/zustandStore';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';

const OfferBanner = () => {
  const [showBanner, setShowBanner] = useState(true);
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [dialogOpen, setDialogOpen] = useState(false);
  const { user, fetchUser } = useAuthStore();
  const { toast } = useToast();

  const handlePurchase = async () => {
    if (!user) return;
    
    setIsPurchasing(true);
    try {
      // Simulate purchase API call
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      toast({
        title: "Purchase Successful!",
        description: "6,200 Forge Tokens have been added to your account.",
        variant: "default",
      });
      
      // Refresh user data
      fetchUser();
      setDialogOpen(false);
    } catch (error) {
      console.error('Purchase error:', error);
      toast({
        title: "Purchase Failed",
        description: "There was an error processing your purchase.",
        variant: "destructive",
      });
    } finally {
      setIsPurchasing(false);
    }
  };

  if (!showBanner) return null;

  return (
    <div className="bg-gradient-to-r from-[#432874]/80 to-[#00B9AE]/50 rounded-lg mb-6 relative overflow-hidden">
      <button 
        onClick={() => setShowBanner(false)}
        className="absolute top-2 right-2 text-[#C8B8DB]/70 hover:text-[#C8B8DB] text-sm"
      >
        
      </button>
      
      <div className="p-4 flex items-center justify-between">
        <div>
          <h3 className="text-[#FF9D00] font-cinzel text-xl font-bold">Limited Time Offer!</h3>
          <p className="text-[#C8B8DB] text-sm">Get 6,200 Forge Tokens and unlock exclusive Legendary Auras!</p>
        </div>
        
        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
          <DialogTrigger asChild>
            <Button className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E] font-semibold">
              Buy Now
            </Button>
          </DialogTrigger>
          
          <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
            <DialogHeader>
              <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Premium Token Package</DialogTitle>
            </DialogHeader>
            
            <div className="mt-4">
              <div className="bg-[#432874]/20 rounded-lg p-4 mb-4">
                <div className="flex items-center justify-center mb-3">
                  <img 
                    src="https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=250&h=250&fit=crop"
                    alt="Forge Tokens" 
                    className="w-16 h-16 rounded-full border-2 border-[#FF9D00]"
                  />
                </div>
                
                <h3 className="text-center text-[#FF9D00] font-cinzel text-2xl">6,200 Forge Tokens</h3>
                <p className="text-center text-sm mt-2">
                  Forge Tokens can be used for premium purchases in the Black Market, 
                  speed up building upgrades, and unlock Legendary Auras.
                </p>
              </div>
              
              <div className="flex justify-between items-center mb-4">
                <span className="text-[#C8B8DB]">Price:</span>
                <span className="text-[#FF9D00] font-bold">$19.99</span>
              </div>
              
              <Button 
                onClick={handlePurchase} 
                disabled={isPurchasing}
                className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E] font-semibold"
              >
                {isPurchasing ? "Processing..." : "Complete Purchase"}
              </Button>
              
              <p className="text-center text-xs mt-4 text-[#C8B8DB]/60">
                For demonstration purposes only. No actual purchase will be made.
              </p>
            </div>
          </DialogContent>
        </Dialog>
      </div>
      
      {/* Decorative Elements */}
      <div className="absolute top-0 right-0 w-32 h-32 bg-[#FFD700]/10 rounded-full -mr-10 -mt-10 blur-md"></div>
      <div className="absolute bottom-0 left-0 w-24 h-24 bg-[#00B9AE]/20 rounded-full -ml-10 -mb-10 blur-md"></div>
    </div>
  );
};

export default OfferBanner;


=== client/src/components/layout/MainLayout.tsx ===
import { ReactNode, useEffect } from 'react';
import Navbar from './Navbar';
import Sidebar from './Sidebar';
import AICompanion from '../ui/AICompanion';
import { useDiscordAuth } from '@/lib/discordAuth';
import { useGameStore } from '@/lib/zustandStore';

interface MainLayoutProps {
  children: ReactNode;
}

const MainLayout = ({ children }: MainLayoutProps) => {
  const { isAuthenticated, isLoading, user, login, fetchUser } = useDiscordAuth();
  const { 
    fetchResources, 
    fetchCharacters, 
    fetchAuras, 
    fetchFarmingTasks, 
    fetchDungeonRuns,
    fetchForgingTasks,
    fetchBlackMarketListings,
    fetchBountyQuests
  } = useGameStore();

  // Load user data on mount
  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  // Fetch game data when authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      fetchResources();
      fetchCharacters();
      fetchAuras();
      fetchFarmingTasks();
      fetchDungeonRuns();
      fetchForgingTasks();
      fetchBlackMarketListings();
      fetchBountyQuests();
    }
  }, [
    isAuthenticated, 
    isLoading, 
    fetchResources, 
    fetchCharacters, 
    fetchAuras, 
    fetchFarmingTasks, 
    fetchDungeonRuns,
    fetchForgingTasks,
    fetchBlackMarketListings,
    fetchBountyQuests
  ]);

  if (isLoading) {
    return (
      <div className="min-h-screen bg-primary-900 flex items-center justify-center">
        <div className="text-secondary animate-pulse text-2xl font-cinzel">
          Loading The Forge...
        </div>
      </div>
    );
  }

  // If not authenticated, show login screen
  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-[#1A1A2E] flex flex-col items-center justify-center p-4">
        <div className="bg-[#432874]/20 border border-[#432874]/50 rounded-xl p-8 max-w-md w-full">
          <h1 className="text-4xl font-cinzel font-bold text-[#FF9D00] text-center mb-6">The Forge</h1>
          <p className="text-[#C8B8DB] text-center mb-8">
            Welcome to The Forge - the management platform for Aura Forge. Log in with Discord to begin your journey.
          </p>
          
          {/* Universal login button that uses the dev/prod logic in the store */}
          <button 
            onClick={() => login()}
            className="w-full bg-[#7855FF] hover:bg-[#6248BF] transition-colors text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center relative overflow-hidden"
          >
            {/* DEV mode indicator that shows up conditionally with client-side JS */}
            <div id="dev-indicator" className="absolute top-0 left-0 bg-green-500 text-white text-xs px-2 py-0.5 hidden">DEV</div>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 127.14 96.36" className="w-6 h-6 mr-2 fill-current">
              <path d="M107.7,8.07A105.15,105.15,0,0,0,81.47,0a72.06,72.06,0,0,0-3.36,6.83A97.68,97.68,0,0,0,49,6.83,72.37,72.37,0,0,0,45.64,0,105.89,105.89,0,0,0,19.39,8.09C2.79,32.65-1.71,56.6.54,80.21h0A105.73,105.73,0,0,0,32.71,96.36,77.7,77.7,0,0,0,39.6,85.25a68.42,68.42,0,0,1-10.85-5.18c.91-.66,1.8-1.34,2.66-2a75.57,75.57,0,0,0,64.32,0c.87.71,1.76,1.39,2.66,2a68.68,68.68,0,0,1-10.87,5.19,77,77,0,0,0,6.89,11.1A105.25,105.25,0,0,0,126.6,80.22h0C129.24,52.84,122.09,29.11,107.7,8.07ZM42.45,65.69C36.18,65.69,31,60,31,53s5-12.74,11.43-12.74S54,46,53.89,53,48.84,65.69,42.45,65.69Zm42.24,0C78.41,65.69,73.25,60,73.25,53s5-12.74,11.44-12.74S96.23,46,96.12,53,91.08,65.69,84.69,65.69Z" />
            </svg>
            <span id="login-button-text">Login with Discord</span>
          </button>
          
          {/* Client-side script to update login button text based on dev/prod environment */}
          <script dangerouslySetInnerHTML={{ __html: `
            (function() {
              const isDevEnvironment = window.location.hostname === 'localhost' || window.location.hostname.includes('replit');
              if (isDevEnvironment) {
                const indicator = document.getElementById('dev-indicator');
                const buttonText = document.getElementById('login-button-text');
                if (indicator) indicator.classList.remove('hidden');
                if (buttonText) buttonText.textContent = 'Dev Login (No Discord Required)';
              }
            })();
          `}} />
          
          <div className="mt-6 text-center text-[#C8B8DB]/60 text-sm">
            Alpha v0.1 - Connect your Discord account to start your adventure
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-[#1F1D36] text-[#C8B8DB] font-nunito">
      <Navbar />
      
      <div className="flex flex-1 overflow-hidden">
        <Sidebar />
        
        <main className="flex-1 overflow-y-auto bg-[#1F1D36] p-4">
          {children}
          
          <div className="fixed bottom-4 right-4 md:hidden">
            <AICompanion />
          </div>
        </main>
      </div>
    </div>
  );
};

export default MainLayout;


=== client/src/components/layout/Sidebar.tsx ===
import { useState } from 'react';
import { Link, useLocation } from 'wouter';
import AICompanion from '../ui/AICompanion';
import { Button } from "@/components/ui/button";
import { 
  Home, 
  Package, 
  Grid, 
  Gem, 
  ShoppingBag, 
  Building2, 
  List, 
  Hammer,
  Award,
  HelpCircle,
  User,
  Scroll
} from 'lucide-react';

const navItems = [
  { path: "/", label: "Dashboard", icon: <Home className="h-6 w-6" /> },
  { path: "/inventory", label: "Inventory", icon: <Package className="h-6 w-6" /> },
  { path: "/dungeons", label: "Dungeon", icon: <Grid className="h-6 w-6" /> },
  { path: "/farming", label: "Farming", icon: <Gem className="h-6 w-6" /> },
  { path: "/forge", label: "Forge", icon: <Hammer className="h-6 w-6" /> },
  { path: "/blackmarket", label: "Black Market", icon: <ShoppingBag className="h-6 w-6" /> },
  { path: "/townhall", label: "Townhall", icon: <Building2 className="h-6 w-6" /> },
  { path: "/tavern", label: "Tavern", icon: <User className="h-6 w-6" /> },
  { path: "/bountyboard", label: "Bounty Board", icon: <Scroll className="h-6 w-6" /> },
  { path: "/collections", label: "Collections", icon: <Award className="h-6 w-6" /> },
];

const Sidebar = () => {
  const [location] = useLocation();
  
  return (
    <aside className="w-16 md:w-56 bg-[#1A1A2E] border-r border-[#432874]/50 flex flex-col h-screen transition-all duration-300">
      <div className="py-4 flex flex-col items-center md:items-start space-y-1 overflow-y-auto">
        {navItems.map((item) => {
          const isActive = location === item.path;
          
          return (
            <Link key={item.path} href={item.path}>
              <div 
                className={`flex items-center w-full px-3 py-2.5 rounded-lg cursor-pointer ${
                  isActive 
                    ? "bg-[#432874]/20 text-[#FF9D00] border-l-2 border-[#FF9D00]" 
                    : "hover:bg-[#432874]/10 text-[#C8B8DB]"
                }`}
              >
                {item.icon}
                <span className="ml-3 hidden md:block">{item.label}</span>
              </div>
            </Link>
          );
        })}
      </div>
      
      <div className="mt-auto p-4 hidden md:block space-y-4">
        <div className="bg-[#432874]/20 rounded-lg p-3 text-center">
          <div className="text-xs text-[#C8B8DB]/70 mb-2">Today's Special Offer</div>
          <div className="text-[#FF9D00] text-sm font-bold">50% OFF ALL PREMIUM PACKS</div>
          <div className="text-xs text-[#C8B8DB]/90 mt-1">Limited time offer! Ends in 3h 45m</div>
          <div className="mt-2">
            <Button size="sm" className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]">
              Claim Offer
            </Button>
          </div>
        </div>
        
        <div className="bg-[#432874]/20 rounded-lg p-2 text-center">
          <div className="text-xs text-[#C8B8DB]/70">AI Companion</div>
          <AICompanion />
        </div>
      </div>
    </aside>
  );
};

export default Sidebar;


=== client/src/components/layout/Navbar.tsx ===
import { useDiscordAuth } from '@/lib/discordAuth';
import { useGameStore } from '@/lib/zustandStore';
import { Zap } from 'lucide-react';
import { useLocation, Link } from 'wouter';
import CompactDiscordChat from '@/components/common/CompactDiscordChat';

const Navbar = () => {
  const { user, logout } = useDiscordAuth();
  const { forgeTokens, rogueCredits, speedBoostActive, speedBoostMultiplier } = useGameStore();
  const location = useLocation();

  return (
    <nav className="bg-[#1A1A2E] border-b border-[#432874]/50 px-4 py-2 flex justify-between items-center sticky top-0 z-50">
      <div className="flex items-center">
        <div className="text-2xl font-cinzel font-bold text-[#FF9D00] mr-2">The Forge</div>
        <span className="bg-[#00B9AE]/20 text-[#00B9AE] text-xs px-2 py-0.5 rounded">Alpha v0.1</span>

        {/* Discord Chat - Further expanded width */}
        <div className="ml-5 flex-1 w-full max-w-4xl">
          <CompactDiscordChat />
        </div>
      </div>

      <div className="flex items-center space-x-4">
        
        {/* Resources Display - More compact */}
        <div className="hidden md:flex items-center space-x-3">
          <div className="flex items-center">
            <img 
              src="https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=250&h=250&fit=crop" 
              alt="Forge Tokens" 
              className="w-4 h-4 rounded-full mr-1"
            />
            <span className="text-[#FFD700] text-xs">{forgeTokens}</span>
          </div>
          <div className="flex items-center">
            <img 
              src="https://images.unsplash.com/photo-1543486958-d783bfbf7f8e?w=250&h=250&fit=crop" 
              alt="Rogue Credits" 
              className="w-4 h-4 rounded-full mr-1"
            />
            <span className="text-xs">{rogueCredits}</span>
          </div>
        </div>

        {/* User Profile */}
        <div className="relative group">
          <div className="flex items-center bg-[#432874]/30 rounded-full px-3 py-1.5 cursor-pointer">
            <img 
              src={user?.avatarUrl || "https://cdn.pixabay.com/photo/2021/03/02/12/03/avatar-6062252_1280.png"} 
              alt="User Avatar" 
              className="w-7 h-7 rounded-full border border-[#FF9D00]"
            />
            <span className="ml-2 text-sm hidden md:block">{user?.username || "ForgeHero"}</span>
            {user?.isAdmin && (
              <span className="ml-2 bg-[#FF9D00] text-black text-xs px-2 py-0.5 rounded-full font-semibold">
                ADMIN
              </span>
            )}
          </div>

          {/* Dropdown menu */}
          <div className="absolute right-0 mt-2 w-48 bg-[#1A1A2E] border border-[#432874]/50 rounded-lg shadow-lg overflow-hidden transform scale-0 group-hover:scale-100 transition-transform origin-top-right">
            <div className="p-2 space-y-1">
              <button 
                onClick={() => window.location.reload()}
                className="w-full text-left p-2 hover:bg-[#432874]/20 rounded-md text-sm"
              >
                Refresh User Data
              </button>
              <button 
                onClick={() => logout()}
                className="w-full text-left p-2 hover:bg-[#432874]/20 rounded-md text-sm"
              >
                Logout
              </button>
            </div>
          </div>
        </div>
      </div>
    </nav>
  );
};

export default Navbar;

=== client/src/components/common/CountdownTimer.tsx ===
import { useState, useEffect } from 'react';

interface CountdownTimerProps {
  endTime: Date | string;
  onComplete?: () => void;
  className?: string;
}

const CountdownTimer = ({ endTime, onComplete, className = '' }: CountdownTimerProps) => {
  const [timeLeft, setTimeLeft] = useState<string>('');
  const [isComplete, setIsComplete] = useState<boolean>(false);
  
  useEffect(() => {
    // Convert string to Date if necessary
    const targetDate = typeof endTime === 'string' ? new Date(endTime) : endTime;
    
    const calculateTimeLeft = () => {
      const difference = targetDate.getTime() - new Date().getTime();
      
      if (difference <= 0) {
        setTimeLeft('Complete');
        setIsComplete(true);
        // The following line has been commented out to prevent automatic task completion
        // if (onComplete) onComplete();
        return;
      }
      
      // Calculate hours, minutes, seconds
      const hours = Math.floor(difference / (1000 * 60 * 60));
      const minutes = Math.floor((difference % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((difference % (1000 * 60)) / 1000);
      
      // Format the time left
      let formattedTime = '';
      
      if (hours > 0) {
        formattedTime += `${hours}:`;
      }
      
      formattedTime += `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      
      setTimeLeft(formattedTime);
    };
    
    // Calculate on mount and then every second
    calculateTimeLeft();
    const timer = setInterval(calculateTimeLeft, 1000);
    
    // Clean up the interval on unmount
    return () => clearInterval(timer);
  }, [endTime, onComplete]);
  
  return (
    <span className={`${className} ${isComplete ? 'text-[#00B9AE]' : 'text-[#C8B8DB]/70'}`}>
      {timeLeft}
    </span>
  );
};

export default CountdownTimer;


=== client/src/components/common/GameTooltip.tsx ===
import React from 'react';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { InfoIcon, Lightbulb } from 'lucide-react';

// Define the tooltip data structure
export interface GameMechanicTooltip {
  id: string;
  title: string;
  description: string;
  category: 'combat' | 'farming' | 'forge' | 'dungeons' | 'building' | 'general' | 'character' | 'aura';
}

// Props for the GameTooltip component
interface GameTooltipProps {
  mechanic: GameMechanicTooltip;
  children?: React.ReactNode;
  iconOnly?: boolean;
  iconSize?: number;
  iconColor?: string;
  side?: "top" | "right" | "bottom" | "left";
  align?: "start" | "center" | "end";
}

export const GameTooltip: React.FC<GameTooltipProps> = ({
  mechanic,
  children,
  iconOnly = false,
  iconSize = 16,
  iconColor = '#FDA643', // Golden-orange color
  side = "top",
  align = "center",
}) => {
  return (
    <TooltipProvider>
      <Tooltip delayDuration={300}>
        <TooltipTrigger className="inline-flex items-center gap-1 cursor-help">
          {children}
          {(iconOnly || !children) && (
            <InfoIcon
              size={iconSize}
              className="text-primary-600 cursor-help"
              color={iconColor}
            />
          )}
          {!iconOnly && children && (
            <InfoIcon
              size={iconSize}
              className="ml-1 text-primary-600 cursor-help"
              color={iconColor}
            />
          )}
        </TooltipTrigger>
        <TooltipContent
          side={side}
          align={align}
          className="bg-gray-900/95 border-purple-900 text-white p-3 max-w-xs rounded-lg shadow-xl z-50"
        >
          <div className="space-y-2">
            <div className="flex items-start gap-2">
              <Lightbulb className="text-yellow-400 mt-0.5 flex-shrink-0" size={18} />
              <h4 className="font-semibold text-yellow-400">{mechanic.title}</h4>
            </div>
            <p className="text-sm leading-relaxed">{mechanic.description}</p>
          </div>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
};

// Export a default function to easily get a tooltip by ID
export default GameTooltip;

=== client/src/components/common/TooltipWrapper.tsx ===
import React from 'react';
import GameTooltip from './GameTooltip';
import { getTooltipById } from '@/lib/tooltipData';

interface TooltipWrapperProps {
  id: string;
  children?: React.ReactNode;
  iconOnly?: boolean;
  iconSize?: number;
  side?: "top" | "right" | "bottom" | "left";
  align?: "start" | "center" | "end";
}

/**
 * A wrapper component that makes it easy to add tooltips with just an ID
 */
export const TooltipWrapper: React.FC<TooltipWrapperProps> = ({
  id,
  children,
  iconOnly = false,
  iconSize,
  side,
  align,
}) => {
  const tooltipData = getTooltipById(id);

  // If tooltip data doesn't exist, just render the children
  if (!tooltipData) {
    console.warn(`Tooltip with ID "${id}" not found`);
    return <>{children}</>;
  }

  return (
    <GameTooltip
      mechanic={tooltipData}
      iconOnly={iconOnly}
      iconSize={iconSize}
      side={side}
      align={align}
    >
      {children}
    </GameTooltip>
  );
};

export default TooltipWrapper;

=== client/src/components/common/MechanicsHelpModal.tsx ===
import React from 'react';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger,
  DialogDescription
} from '@/components/ui/dialog';
import { 
  Tabs, 
  TabsContent, 
  TabsList, 
  TabsTrigger 
} from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { HelpCircle, Lightbulb } from 'lucide-react';
import { gameMechanicsTooltips } from '@/lib/tooltipData';
import { GameMechanicTooltip } from '@/components/common/GameTooltip';

// Props for the MechanicsHelpModal
interface MechanicsHelpModalProps {
  initialCategory?: GameMechanicTooltip['category'];
  buttonText?: string;
  buttonVariant?: 'default' | 'outline' | 'ghost';
  buttonSize?: 'sm' | 'default' | 'lg';
  iconOnly?: boolean;
}

/**
 * A modal that displays all game mechanics tooltips, organized by category
 */
export const MechanicsHelpModal: React.FC<MechanicsHelpModalProps> = ({
  initialCategory = 'general',
  buttonText = 'Game Mechanics',
  buttonVariant = 'outline',
  buttonSize = 'sm',
  iconOnly = false,
}) => {
  // Group tooltips by category
  const tooltipsByCategory = React.useMemo(() => {
    const grouped: Record<string, GameMechanicTooltip[]> = {};
    
    gameMechanicsTooltips.forEach(tooltip => {
      if (!grouped[tooltip.category]) {
        grouped[tooltip.category] = [];
      }
      grouped[tooltip.category].push(tooltip);
    });
    
    return grouped;
  }, []);

  // Get unique categories
  const categories = React.useMemo(() => {
    return Object.keys(tooltipsByCategory) as GameMechanicTooltip['category'][];
  }, [tooltipsByCategory]);

  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant={buttonVariant} size={buttonSize}>
          <HelpCircle className="mr-2" size={16} />
          {!iconOnly && buttonText}
        </Button>
      </DialogTrigger>
      <DialogContent className="bg-gray-900 border-purple-900 text-white sm:max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="text-yellow-400 font-semibold text-xl flex items-center gap-2">
            <Lightbulb className="text-yellow-400" size={20} />
            Game Mechanics Guide
          </DialogTitle>
          <DialogDescription className="text-gray-300">
            Learn about various mechanics and systems in The Forge.
          </DialogDescription>
        </DialogHeader>

        <Tabs defaultValue={initialCategory} className="w-full">
          <TabsList className="grid grid-cols-4 sm:grid-cols-7 mb-4">
            {categories.map((category) => (
              <TabsTrigger 
                key={category} 
                value={category}
                className="capitalize text-xs sm:text-sm"
              >
                {category}
              </TabsTrigger>
            ))}
          </TabsList>

          {categories.map((category) => (
            <TabsContent key={category} value={category} className="space-y-4">
              {tooltipsByCategory[category].map((tooltip) => (
                <div key={tooltip.id} className="bg-gray-800/60 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2 flex items-center gap-2">
                    <Lightbulb className="text-yellow-400" size={16} />
                    {tooltip.title}
                  </h3>
                  <p className="text-gray-200 text-sm leading-relaxed">
                    {tooltip.description}
                  </p>
                </div>
              ))}
            </TabsContent>
          ))}
        </Tabs>
      </DialogContent>
    </Dialog>
  );
};

export default MechanicsHelpModal;

=== client/src/components/common/CompactDiscordChat.tsx ===
import { useState, useEffect, useRef } from 'react';
import { useGameStore } from '@/lib/zustandStore';
import { Send, MessageSquare, ChevronDown, ChevronUp, Maximize2, MessageCircle } from 'lucide-react';
import { useDiscordAuth } from '@/lib/discordAuth';
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

const CompactDiscordChat = () => {
  const { discordMessages, addDiscordMessage } = useGameStore();
  const { user } = useDiscordAuth();
  const [message, setMessage] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [showPreview, setShowPreview] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const unreadCount = useRef(0);
  
  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    if (!isOpen && discordMessages.length > 0) {
      unreadCount.current += 1;
    }
  }, [discordMessages, isOpen]);

  // Reset unread count when opening
  useEffect(() => {
    if (isOpen) {
      unreadCount.current = 0;
    }
  }, [isOpen]);

  const handleSendMessage = () => {
    if (!message.trim() || !user) return;
    
    // Add message to local state
    addDiscordMessage(user.username, message);
    
    // Clear input
    setMessage('');
  };

  // Get the three most recent messages to display in the header
  const recentMessages = discordMessages.slice(-3);

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <div className="relative flex-1">
        {/* Live Discord Chat Bar */}
        <div className="flex items-center relative w-80 md:w-[32rem]">  {/* Further increased width */}
          {/* Live Chat Display (Always visible) - Full width without Discord label */}
          <div className="bg-[#1F1D36]/80 border border-[#432874]/30 rounded-l-md flex-1 h-16 px-3 py-1 flex flex-col justify-center w-full">
            {recentMessages.length > 0 ? (
              <div className="w-full">
                {recentMessages.map((msg, index) => (
                  <div key={msg.id} className={`flex ${index !== recentMessages.length - 1 ? 'mb-0.5' : ''}`}>
                    <span className={`font-semibold text-xs whitespace-nowrap ${
                      msg.username === 'GuildMaster' ? 'text-[#FF9D00]' : 
                      msg.username === 'AuraCollector' ? 'text-[#00B9AE]' : 
                      'text-[#C8B8DB]'
                    }`}>
                      {msg.username}:
                    </span>
                    <span className="text-[#C8B8DB]/90 ml-1 truncate text-xs flex-1">{msg.content}</span>
                  </div>
                ))}
              </div>
            ) : (
              <span className="text-[#C8B8DB]/50 text-xs">No messages yet</span>
            )}
            {unreadCount.current > 0 && (
              <span className="absolute top-1 right-3 w-4 h-4 rounded-full bg-[#FF9D00] text-[#1A1A2E] text-xs flex items-center justify-center">
                {unreadCount.current > 9 ? '9+' : unreadCount.current}
              </span>
            )}
          </div>
          
          {/* Expand Button */}
          <DialogTrigger asChild>
            <button className="bg-[#432874]/20 border border-[#432874]/30 border-l-0 rounded-r-md px-2 h-full flex items-center justify-center hover:bg-[#432874]/40 transition-colors">
              <Maximize2 className="h-4 w-4 text-[#7855FF]" />
            </button>
          </DialogTrigger>
        </div>
      </div>
      
      <DialogContent className="sm:max-w-xl bg-[#1A1A2E] border-[#432874]/50">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-cinzel font-bold text-[#FF9D00]">Discord Chat</h2>
          <div className="bg-[#FF9D00]/20 rounded-full px-2 py-0.5 text-xs text-[#FF9D00]">
            {Math.floor(Math.random() * 10) + 5} Online
          </div>
        </div>
        
        <div className="h-80 overflow-y-auto bg-[#1F1D36]/50 rounded-lg p-3 mb-3 text-xs space-y-2 custom-scrollbar">
          {discordMessages.length > 0 ? (
            <>
              {discordMessages.map((msg) => (
                <div key={msg.id} className="flex items-start group hover:bg-[#432874]/10 p-1 rounded-md transition-colors">
                  <span className={`font-semibold whitespace-nowrap ${
                    msg.username === 'GuildMaster' ? 'text-[#FF9D00]' : 
                    msg.username === 'AuraCollector' ? 'text-[#00B9AE]' : 
                    'text-[#C8B8DB]'
                  }`}>
                    {msg.username}:
                  </span>
                  <span className="text-[#C8B8DB]/90 ml-1 break-words">{msg.content}</span>
                  <span className="ml-auto text-[#C8B8DB]/40 text-[10px] opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap">
                    {new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                  </span>
                </div>
              ))}
              <div ref={messagesEndRef} />
            </>
          ) : (
            <div className="h-full flex items-center justify-center text-[#C8B8DB]/40">
              No messages yet. Start the conversation!
            </div>
          )}
        </div>
        
        <div className="flex">
          <input 
            type="text"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
            placeholder="Type a message..."
            className="flex-1 bg-[#1F1D36]/80 border border-[#432874]/30 rounded-l-lg px-3 py-2 text-sm focus:outline-none focus:border-[#FF9D00]"
          />
          <button 
            onClick={handleSendMessage}
            className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 transition-colors px-4 rounded-r-lg flex items-center justify-center"
          >
            <Send className="h-4 w-4 text-[#1A1A2E]" />
          </button>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default CompactDiscordChat;

=== client/src/components/dashboard/WelcomeSection.tsx ===
import { motion } from 'framer-motion';

interface WelcomeSectionProps {
  username: string;
  charactersCount: number;
  aurasCount: number;
  activeDungeons: number;
  farmingSlotsCount: number;
}

const WelcomeSection = ({
  username,
  charactersCount,
  aurasCount,
  activeDungeons,
  farmingSlotsCount
}: WelcomeSectionProps) => {
  return (
    <motion.div 
      className="bg-[#1A1A2E] rounded-xl p-6 relative overflow-hidden"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <div className="absolute top-0 right-0 w-64 h-64 bg-[#432874]/20 rounded-full -mr-32 -mt-32 blur-md"></div>
      
      <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] relative z-10">Welcome back, {username}</h1>
      <p className="mt-2 text-[#C8B8DB]/80 relative z-10">Your journey continues with new challenges and rewards.</p>
      
      {/* Account Stats */}
      <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mt-6 relative z-10">
        <div className="bg-[#2D1B4E]/50 p-3 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Characters</div>
          <div className="text-xl font-semibold">{charactersCount}/20</div>
        </div>
        <div className="bg-[#2D1B4E]/50 p-3 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Auras</div>
          <div className="text-xl font-semibold">{aurasCount}</div>
        </div>
        <div className="bg-[#2D1B4E]/50 p-3 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Dungeons</div>
          <div className="text-xl font-semibold">{activeDungeons} Active</div>
        </div>
        <div className="bg-[#2D1B4E]/50 p-3 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Farming</div>
          <div className="text-xl font-semibold">{farmingSlotsCount} Slots</div>
        </div>
      </div>
    </motion.div>
  );
};

export default WelcomeSection;


=== client/src/components/dashboard/RecentActivity.tsx ===
import { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import type { ActivityLog } from '@shared/schema';

const RecentActivity = () => {
  // Fetch recent activity logs
  const { data: activityLogs, isLoading } = useQuery<ActivityLog[]>({ 
    queryKey: ['/api/activity?limit=5'],
    refetchInterval: 30000 // Refresh every 30 seconds
  });

  const formatTimeAgo = (date: Date | string) => {
    const now = new Date();
    const activityDate = new Date(date);
    const diffInMilliseconds = now.getTime() - activityDate.getTime();
    
    // Convert to seconds
    const diffInSeconds = Math.floor(diffInMilliseconds / 1000);
    
    if (diffInSeconds < 60) {
      return 'just now';
    }
    
    // Convert to minutes
    const diffInMinutes = Math.floor(diffInSeconds / 60);
    
    if (diffInMinutes < 60) {
      return `${diffInMinutes} minute${diffInMinutes !== 1 ? 's' : ''} ago`;
    }
    
    // Convert to hours
    const diffInHours = Math.floor(diffInMinutes / 60);
    
    if (diffInHours < 24) {
      return `${diffInHours} hour${diffInHours !== 1 ? 's' : ''} ago`;
    }
    
    // Convert to days
    const diffInDays = Math.floor(diffInHours / 24);
    
    return `${diffInDays} day${diffInDays !== 1 ? 's' : ''} ago`;
  };

  const getActivityColor = (activityType: string) => {
    const typeColors: Record<string, string> = {
      dungeon_completed: '[#FF9D00]',
      dungeon_started: '[#DC143C]',
      aura_crafted: '[#FF9D00]',
      aura_fusion_completed: '[#FF9D00]',
      farming_completed: '[#228B22]',
      farming_started: '[#228B22]',
      item_purchased: '[#C8B8DB]',
      character_created: '[#00B9AE]',
      aura_created: '[#00B9AE]',
    };

    return typeColors[activityType] || '[#C8B8DB]/50';
  };

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, x: -10 },
    show: { opacity: 1, x: 0 }
  };

  if (isLoading) {
    return (
      <motion.div 
        className="bg-[#1A1A2E] rounded-xl p-6"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.3 }}
      >
        <h2 className="text-xl font-cinzel font-bold mb-4">Recent Activity</h2>
        <div className="space-y-3 animate-pulse">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="border-l-2 border-[#432874]/30 pl-3 py-1">
              <div className="h-4 bg-[#432874]/20 rounded w-3/4 mb-1"></div>
              <div className="h-3 bg-[#432874]/10 rounded w-1/4"></div>
            </div>
          ))}
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div 
      className="bg-[#1A1A2E] rounded-xl p-6"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 0.3 }}
    >
      <h2 className="text-xl font-cinzel font-bold mb-4">Recent Activity</h2>
      
      <motion.div 
        className="space-y-3"
        variants={container}
        initial="hidden"
        animate="show"
      >
        {activityLogs && activityLogs.length > 0 ? (
          activityLogs.map((log) => (
            <motion.div 
              key={log.id} 
              className={`border-l-2 border-${getActivityColor(log.activityType)} pl-3 py-1`}
              variants={item}
            >
              <div className="text-sm font-medium">{log.description}</div>
              <div className="text-xs text-[#C8B8DB]/70">{formatTimeAgo(log.timestamp)}</div>
            </motion.div>
          ))
        ) : (
          <div className="text-center text-[#C8B8DB]/50 py-4">
            No recent activity to display
          </div>
        )}
      </motion.div>
      
      <motion.button 
        className="w-full mt-4 bg-[#432874]/40 hover:bg-[#432874]/60 transition-colors py-2 rounded-lg text-sm"
        variants={item}
        whileHover={{ scale: 1.02 }}
        whileTap={{ scale: 0.98 }}
      >
        View Activity Log
      </motion.button>
    </motion.div>
  );
};

export default RecentActivity;


=== client/src/components/dashboard/ResourcesOverview.tsx ===
import { useDiscordAuth } from '@/lib/discordAuth';
import { useGameStore } from '@/lib/zustandStore';
import { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { Link } from 'wouter';

const ResourcesOverview = () => {
  const { user } = useDiscordAuth();
  const { resources, fetchResources } = useGameStore();

  // Ensure we have the latest resources data
  useEffect(() => {
    fetchResources();
  }, [fetchResources]);

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 10 },
    show: { opacity: 1, y: 0 }
  };

  return (
    <motion.div 
      className="bg-[#1A1A2E] rounded-xl p-6"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 0.2 }}
    >
      <h2 className="text-xl font-cinzel font-bold mb-4">Resources</h2>
      
      <motion.div 
        className="space-y-3"
        variants={container}
        initial="hidden"
        animate="show"
      >
        <motion.div 
          className="flex justify-between items-center"
          variants={item}
        >
          <div className="flex items-center">
            <img 
              src="https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop" 
              alt="Forge Tokens" 
              className="w-8 h-8 rounded-full mr-2"
            />
            <div>
              <div className="text-sm font-semibold">Forge Tokens</div>
              <div className="text-xs text-[#C8B8DB]/70">Premium Currency</div>
            </div>
          </div>
          <div className="text-[#FFD700] font-bold">{user?.forgeTokens || 0}</div>
        </motion.div>
        
        <motion.div 
          className="flex justify-between items-center"
          variants={item}
        >
          <div className="flex items-center">
            <img 
              src="https://images.unsplash.com/photo-1543486958-d783bfbf7f8e?w=150&h=150&fit=crop" 
              alt="Rogue Credits" 
              className="w-8 h-8 rounded-full mr-2"
            />
            <div>
              <div className="text-sm font-semibold">Rogue Credits</div>
              <div className="text-xs text-[#C8B8DB]/70">Standard Currency</div>
            </div>
          </div>
          <div className="text-[#C8B8DB] font-bold">{user?.rogueCredits || 0}</div>
        </motion.div>
        
        <motion.div 
          className="flex justify-between items-center"
          variants={item}
        >
          <div className="flex items-center">
            <img 
              src="https://images.unsplash.com/photo-1618325500063-14cd8117369c?w=150&h=150&fit=crop" 
              alt="Soul Shards" 
              className="w-8 h-8 rounded-full mr-2"
            />
            <div>
              <div className="text-sm font-semibold">Soul Shards</div>
              <div className="text-xs text-[#C8B8DB]/70">Character Upgrades</div>
            </div>
          </div>
          <div className="text-[#00B9AE] font-bold">{user?.soulShards || 0}</div>
        </motion.div>
        
        {resources.slice(0, 2).map((resource) => (
          <motion.div 
            key={resource.id}
            className="flex justify-between items-center"
            variants={item}
          >
            <div className="flex items-center">
              <img 
                src={resource.iconUrl || "https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop"} 
                alt={resource.name} 
                className="w-8 h-8 rounded-full mr-2"
              />
              <div>
                <div className="text-sm font-semibold">{resource.name}</div>
                <div className="text-xs text-[#C8B8DB]/70">{resource.type.charAt(0).toUpperCase() + resource.type.slice(1)}</div>
              </div>
            </div>
            <div className="text-[#C8B8DB] font-bold">{resource.quantity}</div>
          </motion.div>
        ))}
      </motion.div>
      
      <div className="flex flex-col space-y-2 mt-4">
        <Link href="/characters">
          <motion.button 
            className="w-full bg-[#432874]/40 hover:bg-[#432874]/60 transition-colors py-2 rounded-lg text-sm"
            variants={item}
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
          >
            View All Resources
          </motion.button>
        </Link>
        
        {/* Admin Button to Add 15,000 Essence */}
        <motion.button 
          className="w-full bg-[#00B9AE]/30 hover:bg-[#00B9AE]/50 transition-colors py-2 rounded-lg text-sm text-[#00B9AE]"
          variants={item}
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
          onClick={async () => {
            try {
              const response = await fetch('/api/admin/add-essence', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
              });
              
              if (response.ok) {
                // Refresh resources after adding Essence
                fetchResources();
                alert('Added 15,000 Essence!');
              } else {
                console.error('Failed to add Essence:', await response.text());
              }
            } catch (error) {
              console.error('Error adding Essence:', error);
            }
          }}
        >
          Add 15,000 Essence (Admin)
        </motion.button>
        
        {/* Admin Button to Add Currency */}
        <motion.button 
          className="w-full bg-[#FFD700]/30 hover:bg-[#FFD700]/50 transition-colors py-2 rounded-lg text-sm text-[#FFD700]"
          variants={item}
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
          onClick={async () => {
            try {
              const response = await fetch('/api/admin/add-currency', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
              });
              
              if (response.ok) {
                // Refresh the user data to update the currencies
                window.location.reload(); // Force a full reload to update currency display in header
                alert('Added 5,000 Rogue Credits and 5,000 Forge Tokens!');
              } else {
                console.error('Failed to add Currency:', await response.text());
              }
            } catch (error) {
              console.error('Error adding Currency:', error);
            }
          }}
        >
          Add 5,000 Credits & Tokens (Admin)
        </motion.button>
      </div>
    </motion.div>
  );
};

export default ResourcesOverview;


=== client/src/components/dashboard/DiscordChat.tsx ===
import { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { useGameStore } from '@/lib/zustandStore';
import { Send, Maximize2, Minimize2 } from 'lucide-react';
import { useDiscordAuth } from '@/lib/discordAuth';

const DiscordChat = () => {
  const { discordMessages, addDiscordMessage } = useGameStore();
  const { user } = useDiscordAuth();
  const [message, setMessage] = useState('');
  const [expanded, setExpanded] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  
  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [discordMessages]);

  const handleSendMessage = () => {
    if (!message.trim() || !user) return;
    
    // Add message to local state
    addDiscordMessage(user.username, message);
    
    // Clear input
    setMessage('');
    
    // In a real implementation, this would send to Discord via WebSocket
  };

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.05
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 10 },
    show: { opacity: 1, y: 0 }
  };

  return (
    <motion.div 
      className={`bg-[#1A1A2E] rounded-xl p-6 ${expanded ? 'col-span-12' : ''}`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 0.4 }}
      layout
    >
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-cinzel font-bold">Discord</h2>
        <div className="flex items-center space-x-3">
          <div className="bg-[#FF9D00]/20 rounded-full px-2 py-0.5 text-xs text-[#FF9D00]">
            {Math.floor(Math.random() * 10) + 5} Online
          </div>
          <button 
            onClick={() => setExpanded(!expanded)} 
            className="p-1 rounded-full hover:bg-[#432874]/20 transition-colors"
            title={expanded ? "Minimize" : "Expand"}
          >
            {expanded ? 
              <Minimize2 className="h-4 w-4 text-[#C8B8DB]/70" /> : 
              <Maximize2 className="h-4 w-4 text-[#C8B8DB]/70" />
            }
          </button>
        </div>
      </div>
      
      <motion.div 
        className={`${expanded ? 'h-64' : 'h-16'} overflow-y-auto bg-[#1F1D36]/50 rounded-lg p-3 mb-3 text-xs transition-all duration-300`}
        variants={container}
        initial="hidden"
        animate="show"
        layout
      >
        {discordMessages.map((msg, index) => (
          <motion.div key={msg.id} className="mb-2" variants={item}>
            <span className={`font-semibold ${
              msg.username === 'GuildMaster' ? 'text-[#FF9D00]' : 
              msg.username === 'AuraCollector' ? 'text-[#00B9AE]' : 
              'text-[#C8B8DB]'
            }`}>
              {msg.username}:
            </span>
            <span className="text-[#C8B8DB]/90"> {msg.content}</span>
          </motion.div>
        ))}
        <div ref={messagesEndRef} />
      </motion.div>
      
      <div className="flex">
        <input 
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
          placeholder="Type a message..."
          className="flex-1 bg-[#1F1D36]/80 border border-[#432874]/30 rounded-l-lg px-3 py-2 text-sm focus:outline-none focus:border-[#FF9D00]"
        />
        <button 
          onClick={handleSendMessage}
          className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 transition-colors px-4 rounded-r-lg flex items-center justify-center"
        >
          <Send className="h-4 w-4 text-[#1A1A2E]" />
        </button>
      </div>
    </motion.div>
  );
};

export default DiscordChat;


=== client/src/components/dashboard/DashboardView.tsx ===
import KleosChatInterface from './KleosChatInterface';
import ActiveTasks from './ActiveTasks';
import OfferBanner from '../ui/OfferBanner';
import { useDiscordAuth } from '@/lib/discordAuth';
import { useGameStore } from '@/lib/zustandStore';
import { useEffect } from 'react';
import { Zap } from 'lucide-react';

const DashboardView = () => {
  const { user } = useDiscordAuth();
  const { 
    fetchFarmingTasks, 
    fetchDungeonRuns, 
    fetchForgingTasks,
    characters,
    farmingTasks,
    dungeonRuns,
    forgingTasks,
    speedBoostActive,
    speedBoostMultiplier
  } = useGameStore();
  
  // Refresh active tasks periodically
  useEffect(() => {
    const fetchActiveTasks = () => {
      fetchFarmingTasks();
      fetchDungeonRuns();
      fetchForgingTasks();
    };
    
    // Fetch initial data
    fetchActiveTasks();
    
    // Set up periodic refresh (every 10 seconds)
    const intervalId = setInterval(fetchActiveTasks, 10000);
    
    return () => clearInterval(intervalId);
  }, [fetchFarmingTasks, fetchDungeonRuns, fetchForgingTasks]);
  
  return (
    <>
      <OfferBanner />
      
      {/* Speed Boost Indicator */}
      {speedBoostActive && (
        <div className="mb-4 flex items-center justify-end">
          <div className="flex items-center bg-[#FF9D00]/20 text-[#FF9D00] px-3 py-1.5 rounded-md animate-pulse">
            <Zap className="h-4 w-4 mr-2" />
            <span className="font-bold">{speedBoostMultiplier}x Speed Boost Active</span>
          </div>
        </div>
      )}
      
      <div className="grid grid-cols-1 md:grid-cols-12 gap-6">
        {/* Kleos Chat Interface Column */}
        <div className="md:col-span-8 space-y-6">
          <KleosChatInterface 
            charactersCount={characters.length}
            aurasCount={0} // Need to implement
            activeDungeons={dungeonRuns.filter(run => !run.completed).length}
            farmingSlotsCount={farmingTasks.filter(task => !task.completed).length}
          />
        </div>
        
        {/* Active Tasks Column */}
        <div className="md:col-span-4 space-y-6">
          <ActiveTasks 
            farmingTasks={farmingTasks}
            dungeonRuns={dungeonRuns}
            forgingTasks={forgingTasks}
          />
        </div>
      </div>
    </>
  );
};

export default DashboardView;


=== client/src/components/dashboard/KleosChatInterface.tsx ===
import { useState, useRef, useEffect } from 'react';
import { motion } from 'framer-motion';
import { Send, Bot, Sparkles, InfoIcon } from 'lucide-react';
import { useDiscordAuth } from '@/lib/discordAuth';

interface Message {
  id: string;
  sender: 'user' | 'kleos';
  content: string;
  timestamp: Date;
}

interface KleosChatInterfaceProps {
  charactersCount: number;
  aurasCount: number;
  activeDungeons: number;
  farmingSlotsCount: number;
}

const KleosChatInterface = ({
  charactersCount,
  aurasCount,
  activeDungeons,
  farmingSlotsCount
}: KleosChatInterfaceProps) => {
  const { user } = useDiscordAuth();
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [isTyping, setIsTyping] = useState(false);
  
  // Generate random witty welcome message
  const generateWittyMessage = () => {
    const activitySummaries = [
      `I see you've got ${activeDungeons} brave souls risking their pixels in dungeons, while ${farmingSlotsCount} minions are farming away. Your empire grows, ${user?.username || 'Adventurer'}!`,
      `${user?.username || 'Adventurer'}! Your ${charactersCount} characters are getting restless. Maybe send a few more on adventures? The dungeons are practically begging for heroes.`,
      `Hot off the digital press: You've collected ${aurasCount} Auras! That's ${aurasCount > 10 ? 'impressive' : 'a good start'}. Keep it up and you'll be glowing brighter than my circuits soon.`,
      `${activeDungeons > 0 ? `Your ${activeDungeons} active dungeons are in full swing!` : 'No active dungeons? The monsters are getting bored!'} And your ${farmingSlotsCount} farming slots are ${farmingSlotsCount > 3 ? 'working overtime' : 'looking a bit lonely'}.`,
      `Welcome back, ${user?.username || 'Adventurer'}! I've been counting your ${aurasCount} Auras while you were away. It's not weird, it's just what AI assistants do.`,
      `Stats update: ${charactersCount} characters, ${aurasCount} Auras, and ${activeDungeons + farmingSlotsCount} active tasks. Not to pressure you, but the leaderboards are watching!`
    ];

    const offers = [
      `Today's special: Double essence drops in Fire dungeons! Not to be dramatic, but this is THE time to farm.`,
      `Weekend offer: 30% off all Forge accelerations! Time to craft those Legendary Auras you've been dreaming about.`,
      `Psst! The Black Market just got a fresh shipment. I spotted some rare items that would complement your collection nicely.`,
      `The Townhall is buzzing with news of an upcoming event. Something about "celestial invasions" - sounds ominous and profitable!`,
      `I heard a rumor that premium dungeon tickets will be half-price tomorrow. Just saying, your inventory could use a restock.`,
      `Special event alert! "Eclipse of Elements" starts tomorrow. Get your team ready for some interdimensional farming.`
    ];

    const wittyTips = [
      `Pro tip: Matching Aura elements with character affinities boosts performance by 25%. I'm not saying your current setup is wrong, but... well, you know.`,
      `You know what would really complete your collection? That legendary Wind Aura you've been avoiding crafting. Just a thought!`,
      `Between you and me, focusing on Speed attributes is the meta right now. Your competitors are already catching on.`,
      `I analyzed your dungeon strategies. Have you considered actually surviving? I kid! But seriously, more vitality might help.`,
      `Your farming efficiency is good, but with a few optimizations to your character assignments, it could be great. Just saying!`,
      `I've been running simulations, and your current team would last approximately 2.7 seconds against the upcoming boss. Might want to prepare a bit more.`
    ];

    // Randomly select one from each category
    const activitySummary = activitySummaries[Math.floor(Math.random() * activitySummaries.length)];
    const offer = offers[Math.floor(Math.random() * offers.length)];
    const wittyTip = wittyTips[Math.floor(Math.random() * wittyTips.length)];

    return `${activitySummary}\n\n${offer}\n\n${wittyTip}\n\nHow can I assist you today? You can ask me about Forge mechanics, dungeon strategies, character building, market insights, or game updates.`;
  };

  // Initialize with welcome message
  useEffect(() => {
    if (messages.length === 0) {
      const initialMessage = generateWittyMessage();

      setMessages([
        {
          id: '1',
          sender: 'kleos',
          content: initialMessage,
          timestamp: new Date()
        }
      ]);
    }
  }, [charactersCount, aurasCount, activeDungeons, farmingSlotsCount, user?.username, messages.length]);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSendMessage = () => {
    if (!input.trim()) return;
    
    // Add user message
    const userMessage: Message = {
      id: Date.now().toString(),
      sender: 'user',
      content: input,
      timestamp: new Date()
    };
    
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    
    // Simulate AI thinking
    setIsTyping(true);
    
    // Simulate AI response delay
    setTimeout(() => {
      const generalResponses = [
        "I'm analyzing the dungeons data now. The best strategy for your level would be to focus on elemental synergies between your characters and auras. Fire and Earth combos are particularly devastating against the new Abyssal enemies.",
        "Looking at the market trends, Forge Tokens are up 15% this week, while essence prices have stabilized. Might be a good time to craft those high-tier auras you've been planning.",
        "Your character progression is solid! For your next upgrades, I'd recommend investing in more vitality for your tanks and accuracy for damage dealers. The upcoming dungeons have some seriously evasive bosses.",
        "Based on your collection, you're just 3 auras away from completing the Celestial set. That 30% bonus to all elemental damage is definitely worth hunting down those last few pieces!",
        "The next game update will introduce the Shadow Realm dungeon tier with some juicy exclusive rewards. You'll want at least 3 characters with Dark resistance above 50% - might want to start preparing!",
        "For optimal farming efficiency this week, I'd focus on Soul Shards in the Misty Highlands. With the current event bonus, you could increase your yield by up to 75% with the right character setup."
      ];
      
      const characterAdvice = [
        `I've been observing your ${charactersCount > 0 ? 'favorite character' : 'characters'}, and I've noticed a potential improvement path. Have you considered focusing more on elemental specialization? The new meta heavily rewards it.`,
        `Your character roster is looking ${charactersCount > 5 ? 'quite diverse' : 'like it could use some variety'}! A balanced team with at least one tank, two DPS, and a support character would boost your dungeon clear rate significantly.`,
        `Did you know that pairing characters with complementary auras can increase their effectiveness by up to 35%? Your current setups could benefit from some strategic reassignments.`,
        `Your characters' skill allocations could use some optimization. The current endgame meta favors burst damage over sustained DPS - might be worth respeccing a few skill trees.`,
        `I've analyzed your character progression paths, and it seems you're prioritizing raw stats over synergy effects. While solid, you could gain an extra 20% efficiency by aligning your team compositions better.`
      ];
      
      const personalizedTips = [
        `By the way, I noticed you tend to prefer ${activeDungeons > farmingSlotsCount ? 'dungeon runs over farming' : 'farming over dungeon runs'}. Did you know you can optimize your rewards by balancing your activities based on the day of the week? Essence drops are boosted on weekends!`,
        `Based on your activity patterns, you might enjoy the new Guild Challenges that are coming next week. They're designed specifically for players who enjoy ${activeDungeons > 0 ? 'challenging dungeon content' : 'strategic resource management'}.`,
        `Your playstyle reminds me of some of the top players on the leaderboard! They also focus on ${aurasCount > 10 ? 'building diverse aura collections' : 'mastering a few powerful characters'}. You're definitely on the right track.`,
        `I've been tracking your progress, and you're advancing 15% faster than the average player at your stage! Whatever you're doing with those ${charactersCount} characters, keep it up!`,
        `Quick observation: players with similar profiles to yours often excel at the Celestial Trials event. With your current setup, you could potentially reach the top 10% bracket with just a few strategic adjustments.`
      ];
      
      // Randomly select a response category with weighting
      const responseType = Math.random();
      let randomResponse;
      
      if (responseType < 0.4) {
        randomResponse = generalResponses[Math.floor(Math.random() * generalResponses.length)];
      } else if (responseType < 0.7) {
        randomResponse = characterAdvice[Math.floor(Math.random() * characterAdvice.length)];
      } else {
        randomResponse = personalizedTips[Math.floor(Math.random() * personalizedTips.length)];
      }
      
      const aiResponse: Message = {
        id: (Date.now() + 1).toString(),
        sender: 'kleos',
        content: randomResponse,
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, aiResponse]);
      setIsTyping(false);
    }, 1500);
  };

  return (
    <motion.div 
      className="bg-[#1A1A2E] rounded-xl p-6 relative overflow-hidden"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <div className="absolute top-0 right-0 w-64 h-64 bg-[#432874]/20 rounded-full -mr-32 -mt-32 blur-md"></div>
      
      {/* Header with Kleos info */}
      <div className="flex items-center mb-4 relative z-10">
        <div className="relative">
          <div className="w-12 h-12 rounded-full bg-gradient-to-r from-[#FF9D00] to-[#7855FF] flex items-center justify-center">
            <Bot className="h-6 w-6 text-[#1A1A2E]" />
          </div>
          <div className="absolute -bottom-1 -right-1 bg-[#00B9AE] rounded-full p-1">
            <Sparkles className="h-3 w-3 text-[#1A1A2E]" />
          </div>
        </div>
        <div className="ml-3">
          <div className="text-xl font-cinzel font-bold text-[#FF9D00]">Kleos</div>
          <div className="text-xs text-[#C8B8DB]/70 flex items-center">
            <span className="bg-[#00B9AE]/20 text-[#00B9AE] px-1.5 py-0.5 rounded text-[0.65rem] mr-2">AI Assistant</span>
            <span>Forge Knowledge Engine</span>
          </div>
        </div>
        <div className="ml-auto">
          <InfoIcon className="h-5 w-5 text-[#C8B8DB]/50 hover:text-[#C8B8DB] cursor-pointer" />
        </div>
      </div>
      
      {/* Messages container */}
      <div className="bg-[#1F1D36]/50 rounded-lg p-4 h-64 overflow-y-auto mb-4 relative z-10">
        {messages.map((msg) => (
          <div 
            key={msg.id} 
            className={`mb-3 ${msg.sender === 'user' ? 'text-right' : ''}`}
          >
            {msg.sender === 'kleos' && (
              <div className="flex items-start mb-1">
                <div className="w-6 h-6 rounded-full bg-gradient-to-r from-[#FF9D00] to-[#7855FF] flex items-center justify-center mr-2">
                  <Bot className="h-3 w-3 text-[#1A1A2E]" />
                </div>
                <div className="text-xs font-semibold text-[#FF9D00]">Kleos</div>
              </div>
            )}
            
            <div 
              className={`inline-block max-w-[85%] rounded-xl p-3 text-sm ${
                msg.sender === 'user' 
                  ? 'bg-[#432874]/40 text-[#C8B8DB]' 
                  : 'bg-[#1A1A2E] text-[#C8B8DB] border border-[#432874]/30'
              }`}
            >
              {msg.content.split('\n').map((line, i) => (
                <div key={i} className={line.trim() === '' ? 'h-2' : ''}>
                  {line}
                </div>
              ))}
            </div>
            
            <div className="text-xs text-[#C8B8DB]/50 mt-1">
              {new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
            </div>
          </div>
        ))}
        
        {isTyping && (
          <div className="flex items-start mb-3">
            <div className="w-6 h-6 rounded-full bg-gradient-to-r from-[#FF9D00] to-[#7855FF] flex items-center justify-center mr-2">
              <Bot className="h-3 w-3 text-[#1A1A2E]" />
            </div>
            <div className="bg-[#1A1A2E] rounded-xl p-3 text-sm border border-[#432874]/30">
              <div className="flex space-x-1">
                <div className="w-2 h-2 rounded-full bg-[#C8B8DB]/70 animate-bounce" style={{ animationDelay: '0ms' }}></div>
                <div className="w-2 h-2 rounded-full bg-[#C8B8DB]/70 animate-bounce" style={{ animationDelay: '150ms' }}></div>
                <div className="w-2 h-2 rounded-full bg-[#C8B8DB]/70 animate-bounce" style={{ animationDelay: '300ms' }}></div>
              </div>
            </div>
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>
      
      {/* Input area */}
      <div className="flex relative z-10">
        <input 
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
          placeholder="Ask Kleos anything about The Forge..."
          className="flex-1 bg-[#1F1D36]/80 border border-[#432874]/30 rounded-l-lg px-3 py-2 text-sm focus:outline-none focus:border-[#FF9D00]"
        />
        <button 
          onClick={handleSendMessage}
          className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 transition-colors px-4 rounded-r-lg flex items-center justify-center"
          disabled={!input.trim()}
        >
          <Send className="h-4 w-4 text-[#1A1A2E]" />
        </button>
      </div>
      
      {/* Account Stats - Minimized as this is now integrated into the chat */}
      <div className="grid grid-cols-4 gap-4 mt-4 relative z-10">
        <div className="bg-[#2D1B4E]/50 p-2 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Characters</div>
          <div className="text-lg font-semibold">{charactersCount}/20</div>
        </div>
        <div className="bg-[#2D1B4E]/50 p-2 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Auras</div>
          <div className="text-lg font-semibold">{aurasCount}</div>
        </div>
        <div className="bg-[#2D1B4E]/50 p-2 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Dungeons</div>
          <div className="text-lg font-semibold">{activeDungeons} Active</div>
        </div>
        <div className="bg-[#2D1B4E]/50 p-2 rounded-lg border border-[#432874]/30">
          <div className="text-xs text-[#C8B8DB]/70">Farming</div>
          <div className="text-lg font-semibold">{farmingSlotsCount} Slots</div>
        </div>
      </div>
    </motion.div>
  );
};

export default KleosChatInterface;

=== client/src/components/dashboard/ActiveTasks.tsx ===
import { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import CountdownTimer from '../common/CountdownTimer';
import { Link } from 'wouter';
import { Grid, Gem, Hammer, User } from 'lucide-react';
import { motion } from 'framer-motion';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { useGameStore } from '@/lib/zustandStore';
import { apiRequest } from '@/lib/queryClient';
import type { FarmingTask, DungeonRun, ForgingTask, Character, Aura } from '@shared/schema';

interface ActiveTasksProps {
  farmingTasks: FarmingTask[];
  dungeonRuns: DungeonRun[];
  forgingTasks: ForgingTask[];
}

const ActiveTasks = ({ farmingTasks, dungeonRuns, forgingTasks }: ActiveTasksProps) => {
  const { toast } = useToast();
  const { characters, fetchFarmingTasks, fetchDungeonRuns, fetchForgingTasks } = useGameStore();
  const [completingTask, setCompletingTask] = useState<number | null>(null);
  const [showResultDialog, setShowResultDialog] = useState(false);
  const [completedAura, setCompletedAura] = useState<Aura | null>(null);

  // Helper function to calculate progress percentage
  const calculateProgress = (startTime: Date | string | null, endTime: Date | string): number => {
    const start = startTime ? new Date(startTime).getTime() : new Date().getTime() - 3600000; // Default to 1 hour ago if no start time
    const end = new Date(endTime).getTime();
    const now = new Date().getTime();
    return Math.min(100, Math.max(0, ((now - start) / (end - start)) * 100));
  };

  // Filter tasks
  const activeFarmingTasks = farmingTasks.filter(task => !task.completed);
  const activeDungeonRuns = dungeonRuns.filter(run => !run.completed);
  const activeForgingTasks = forgingTasks.filter(task => !task.completed);
  
  // Count completed tasks for each category - only count tasks that are completed AND done
  const completedFarmingCount = farmingTasks.filter(task => 
    task.completed === true && 
    new Date(task.endTime) <= new Date() &&
    // Only show tasks that are recently completed (within the last hour)
    new Date(task.endTime).getTime() > new Date().getTime() - (60 * 60 * 1000)
  ).length;
  const completedDungeonCount = dungeonRuns.filter(run => 
    run.completed === true && 
    new Date(run.endTime) <= new Date() &&
    // Only show dungeon runs that are recently completed (within the last hour)
    new Date(run.endTime).getTime() > new Date().getTime() - (60 * 60 * 1000)
  ).length;
  const completedForgingCount = forgingTasks.filter(task => 
    task.completed === true && 
    new Date(task.endTime) <= new Date() &&
    // Only show forging tasks that are recently completed (within the last hour)
    new Date(task.endTime).getTime() > new Date().getTime() - (60 * 60 * 1000)
  ).length;

  // Group characters by ID for easier lookup
  const charactersById = characters.reduce<Record<number, Character>>((acc, char) => {
    acc[char.id] = char;
    return acc;
  }, {});

  const handleCompleteFarmingTask = async (taskId: number) => {
    if (completingTask) return;
    setCompletingTask(taskId);

    try {
      const res = await apiRequest('POST', `/api/farming/complete/${taskId}`, undefined);
      const data = await res.json();

      toast({
        title: "Farming Complete",
        description: `Gained ${data.amount} ${data.resource}`,
      });

      // Refresh farming tasks
      fetchFarmingTasks();
    } catch (error) {
      console.error('Error completing farming task:', error);
      toast({
        title: "Error",
        description: "Failed to complete farming task",
        variant: "destructive",
      });
    } finally {
      setCompletingTask(null);
    }
  };

  const handleCompleteDungeonRun = async (runId: number) => {
    if (completingTask) return;
    setCompletingTask(runId);

    try {
      const res = await apiRequest('POST', `/api/dungeons/complete/${runId}`, undefined);
      const data = await res.json();

      toast({
        title: data.success ? "Dungeon Cleared!" : "Dungeon Failed",
        description: data.success 
          ? `You gained rewards from the dungeon` 
          : "Your party had to retreat from the dungeon",
        variant: data.success ? "default" : "destructive",
      });

      // Refresh dungeon runs
      fetchDungeonRuns();
    } catch (error) {
      console.error('Error completing dungeon run:', error);
      toast({
        title: "Error",
        description: "Failed to complete dungeon run",
        variant: "destructive",
      });
    } finally {
      setCompletingTask(null);
    }
  };

  const handleCompleteForging = async (taskId: number) => {
    if (completingTask) return;
    setCompletingTask(taskId);

    try {
      const res = await apiRequest('POST', `/api/forge/complete/${taskId}`, undefined);
      const data = await res.json();

      // Store the completed aura and show dialog
      setCompletedAura(data.aura);
      setShowResultDialog(true);

      // Refresh forging tasks
      fetchForgingTasks();
    } catch (error) {
      console.error('Error completing forging task:', error);
      toast({
        title: "Error",
        description: "Failed to complete forging task",
        variant: "destructive",
      });
    } finally {
      setCompletingTask(null);
    }
  };

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  if (activeFarmingTasks.length === 0 && activeDungeonRuns.length === 0 && activeForgingTasks.length === 0) {
    return (
      <motion.div 
        className="bg-[#1A1A2E] rounded-xl p-6"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-cinzel font-bold">Active Tasks</h2>
        </div>

        <div className="bg-[#2D1B4E]/20 rounded-lg p-8 text-center">
          <p className="text-[#C8B8DB]/80 mb-4">You have no active tasks at the moment.</p>
          <div className="flex flex-wrap gap-2 justify-center">
            <Link href="/dungeons">
              <Button className="bg-[#432874] hover:bg-[#432874]/80">
                <Grid className="mr-2 h-4 w-4" />
                Start Dungeon
              </Button>
            </Link>
            <Link href="/farming">
              <Button className="bg-[#432874] hover:bg-[#432874]/80">
                <Gem className="mr-2 h-4 w-4" />
                Start Farming
              </Button>
            </Link>
            <Link href="/forge">
              <Button className="bg-[#432874] hover:bg-[#432874]/80">
                <Hammer className="mr-2 h-4 w-4" />
                Start Forging
              </Button>
            </Link>
          </div>
        </div>
      </motion.div>
    );
  }

  return (
    <>
      <motion.div 
        className="bg-[#1A1A2E] rounded-xl p-4"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-lg font-cinzel font-bold">Active Tasks</h2>
          <Link href="/dungeons">
            <button className="text-[#FF9D00] text-xs hover:underline">View All</button>
          </Link>
        </div>

        {/* Completed tasks notification bar */}
        {(completedFarmingCount > 0 || completedDungeonCount > 0 || completedForgingCount > 0) && (
          <div className="flex flex-wrap gap-2 mb-3">
            {completedFarmingCount > 0 && (
              <Link href="/farming">
                <div className="flex items-center bg-[#228B22]/20 text-[#228B22] px-2 py-1 rounded border border-[#228B22]/30 text-xs hover:bg-[#228B22]/30 transition-colors">
                  <Gem className="h-3 w-3 mr-1" />
                  <span>Farming</span>
                  <span className="ml-1 w-4 h-4 bg-[#228B22] text-black rounded-full flex items-center justify-center text-[10px] font-bold">
                    {completedFarmingCount}
                  </span>
                </div>
              </Link>
            )}
            
            {completedDungeonCount > 0 && (
              <Link href="/dungeons">
                <div className="flex items-center bg-[#DC143C]/20 text-[#DC143C] px-2 py-1 rounded border border-[#DC143C]/30 text-xs hover:bg-[#DC143C]/30 transition-colors">
                  <Grid className="h-3 w-3 mr-1" />
                  <span>Dungeon</span>
                  <span className="ml-1 w-4 h-4 bg-[#DC143C] text-white rounded-full flex items-center justify-center text-[10px] font-bold">
                    {completedDungeonCount}
                  </span>
                </div>
              </Link>
            )}
            
            {completedForgingCount > 0 && (
              <Link href="/forge">
                <div className="flex items-center bg-[#FF9D00]/20 text-[#FF9D00] px-2 py-1 rounded border border-[#FF9D00]/30 text-xs hover:bg-[#FF9D00]/30 transition-colors">
                  <Hammer className="h-3 w-3 mr-1" />
                  <span>Forge</span>
                  <span className="ml-1 w-4 h-4 bg-[#FF9D00] text-black rounded-full flex items-center justify-center text-[10px] font-bold">
                    {completedForgingCount}
                  </span>
                </div>
              </Link>
            )}
          </div>
        )}

        <motion.div 
          className="space-y-2"
          variants={container}
          initial="hidden"
          animate="show"
        >
        {/* Dungeon Tasks */}
        {activeDungeonRuns.map((run) => (
          <motion.div 
            key={`dungeon-${run.id}`}
            className="bg-[#1F1D36]/50 p-2 rounded-lg border border-[#432874]/30"
            variants={item}
          >
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <Grid className="h-5 w-5 text-[#DC143C]" />
                <span className="ml-2 font-semibold">{run.dungeonName} (Level {run.dungeonLevel})</span>
              </div>
              <div className="flex items-center text-sm">
                <div className="bg-[#DC143C]/20 text-[#DC143C] px-2 py-0.5 rounded">In Progress</div>
                <CountdownTimer 
                  endTime={run.endTime} 
                  className="ml-2" 
                  onComplete={() => {}} // Removed auto-complete
                />
              </div>
            </div>
            <div className="mt-3 grid grid-cols-4 gap-2">
              {run.characterIds.map((charId) => (
                <img 
                  key={charId}
                  src={charactersById[charId]?.avatarUrl || "https://via.placeholder.com/150"} 
                  alt={charactersById[charId]?.name || "Character"} 
                  className="w-10 h-10 rounded-full border border-[#DC143C]/50"
                />
              ))}
            </div>
            {new Date(run.endTime) <= new Date() && (
              <Link href="/dungeons">
                <Button 
                  className="w-full mt-2 bg-[#DC143C] hover:bg-[#DC143C]/80 text-white"
                >
                  View Dungeon Run
                </Button>
              </Link>
            )}
          </motion.div>
        ))}

        {/* Farming Tasks */}
        {activeFarmingTasks.map((task) => {
          // Get the character name if there's a character assigned
          const character = task.characterId ? charactersById[task.characterId] : null;
          const characterName = character ? character.name : 'Unknown';

          return (
            <motion.div 
              key={`farming-${task.id}`}
              className="bg-[#1F1D36]/50 p-2 rounded-lg border border-[#432874]/30"
              variants={item}
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center">
                  <Gem className="h-5 w-5 text-[#228B22]" />
                  <span className="ml-2 font-semibold">{task.resourceName} Farming</span>
                </div>
                <div className="flex items-center text-sm">
                  <div className="bg-[#228B22]/20 text-[#228B22] px-2 py-0.5 rounded">Active</div>
                  <CountdownTimer 
                    endTime={task.endTime} 
                    className="ml-2" 
                    onComplete={() => handleCompleteFarmingTask(task.id)}
                  />
                </div>
              </div>

              <div className="mt-2">
                <Progress value={calculateProgress(task.startTime, task.endTime)} max={100} className="h-1.5 bg-[#432874]/20" />
              </div>
              <div className="flex justify-between items-center mt-2">
                <div className="text-xs text-[#C8B8DB]/70">
                  <span>Expected yield: {task.expectedYield || "?"} {task.resourceName}</span>
                </div>
                <div className="text-xs text-[#228B22]/90">
                  <span>+15% Farming Efficiency</span>
                </div>
              </div>

              {new Date(task.endTime) <= new Date() && (
                <Button 
                  className="w-full mt-2 bg-[#228B22] hover:bg-[#228B22]/80 text-white"
                  onClick={() => handleCompleteFarmingTask(task.id)}
                  disabled={completingTask === task.id}
                >
                  {completingTask === task.id ? "Collecting..." : "Collect Resources"}
                </Button>
              )}
            </motion.div>
          );
        })}

        {/* Forge Tasks */}
        {activeForgingTasks.map((task) => {
          const startTime = task.startTime ? new Date(task.startTime) : new Date();
          const endTime = task.endTime ? new Date(task.endTime) : new Date();

          const taskProgress = Math.min(
            100,
            Math.max(
              0,
              ((new Date().getTime() - startTime.getTime()) /
                (endTime.getTime() - startTime.getTime())) *
                100
            )
          );

          // Get the character name if there's a character assigned
          const character = task.characterId ? charactersById[task.characterId] : null;
          const characterName = character ? character.name : 'Unknown';

          return (
            <motion.div 
              key={`forge-${task.id}`}
              className="bg-[#1F1D36]/50 p-2 rounded-lg border border-[#432874]/30"
              variants={item}
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center">
                  <Hammer className="h-5 w-5 text-[#FF9D00]" />
                  <span className="ml-2 font-semibold">
                    {task.taskType === 'craft' 
                      ? `Crafting ${task.targetElement} Aura` 
                      : 'Aura Fusion'}
                  </span>
                </div>
                <div className="flex items-center text-sm">
                  <div className="bg-[#FF9D00]/20 text-[#FF9D00] px-2 py-0.5 rounded">Crafting</div>
                  <CountdownTimer 
                    endTime={task.endTime} 
                    className="ml-2" 
                    onComplete={() => handleCompleteForging(task.id)}
                  />
                </div>
              </div>

              <div className="mt-2">
                <Progress value={taskProgress} className="h-2 bg-[#1F1D36] border-[#432874]/20" />
              </div>
              <div className="flex justify-between items-center mt-2">
                <div className="text-xs text-[#C8B8DB]/70">
                  <span>Task type: {task.taskType === 'fusion' ? 'Fusion' : 'Crafting'}</span>
                </div>
                <div className="text-xs text-[#FF9D00]/90">
                  <span>+10% Crafting Speed</span>
                </div>
              </div>
              {new Date(task.endTime) <= new Date() && (
                <Link href="/forge">
                  <Button 
                    className="w-full mt-2 bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                  >
                    Go to Forge
                  </Button>
                </Link>
              )}
            </motion.div>
          );
        })}
      </motion.div>
      
      {/* Forge Result Dialog */}
      <Dialog open={showResultDialog} onOpenChange={setShowResultDialog}>
        <DialogContent className="bg-[#1A1A2E] border-[#432874] max-w-2xl">
          <DialogHeader>
            <DialogTitle className="text-2xl font-cinzel text-[#FF9D00]">
              Forging Complete!
            </DialogTitle>
          </DialogHeader>

          {completedAura && (
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                <div className={`w-16 h-16 rounded-full flex items-center justify-center ${
                  completedAura.element === 'fire' ? 'bg-red-500/30 text-red-300' 
                  : completedAura.element === 'water' ? 'bg-blue-500/30 text-blue-300'
                  : completedAura.element === 'earth' ? 'bg-green-500/30 text-green-300' 
                  : completedAura.element === 'wind' ? 'bg-cyan-500/30 text-cyan-300'
                  : completedAura.element === 'light' ? 'bg-yellow-500/30 text-yellow-300'
                  : 'bg-purple-500/30 text-purple-300'
                }`}>
                  <span className="text-2xl">{completedAura.element?.charAt(0).toUpperCase()}</span>
                </div>
                <div>
                  <h3 className="text-xl font-semibold capitalize">
                    {completedAura.name || `${completedAura.element} Aura`}
                  </h3>
                  <div className="flex gap-2">
                    <Badge className="bg-purple-700/30 text-purple-300 border-purple-600/30">
                      Level {completedAura.level}
                    </Badge>
                    <Badge className="bg-[#432874]/30 text-[#C8B8DB]">
                      {completedAura.tier ? `Tier ${completedAura.tier}` : 'Basic Tier'}
                    </Badge>
                  </div>
                </div>
              </div>

              <div className="bg-[#432874]/20 rounded-lg p-4">
                <h4 className="font-semibold mb-2">Stat Multipliers</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-[#C8B8DB]">
                  {completedAura.attack && (
                    <div>Attack: <span className="text-[#FF9D00]">+{completedAura.attack}%</span></div>
                  )}
                  {completedAura.defense && (
                    <div>Defense: <span className="text-[#FF9D00]">+{completedAura.defense}%</span></div>
                  )}
                  {completedAura.vitality && (
                    <div>Vitality: <span className="text-[#FF9D00]">+{completedAura.vitality}%</span></div>
                  )}
                  {completedAura.speed && (
                    <div>Speed: <span className="text-[#FF9D00]">+{completedAura.speed}%</span></div>
                  )}
                  {completedAura.accuracy && (
                    <div>Accuracy: <span className="text-[#FF9D00]">+{completedAura.accuracy}%</span></div>
                  )}
                  {completedAura.focus && (
                    <div>Focus: <span className="text-[#FF9D00]">+{completedAura.focus}%</span></div>
                  )}
                  {completedAura.resilience && (
                    <div>Resilience: <span className="text-[#FF9D00]">+{completedAura.resilience}%</span></div>
                  )}
                </div>
              </div>

              {/* Aura basic info */}
              <div className="bg-[#432874]/20 rounded-lg p-4">
                <h4 className="font-semibold mb-2">Element: {completedAura.element}</h4>
                <p className="text-[#C8B8DB]">A powerful {completedAura.element} aura that enhances your character's abilities.</p>
              </div>

              {completedAura.skills && (
                <div className="bg-[#432874]/20 rounded-lg p-4">
                  <h4 className="font-semibold mb-2">Skills</h4>
                  <div className="space-y-2">
                    {(typeof completedAura.skills === 'string' 
                      ? JSON.parse(completedAura.skills) 
                      : completedAura.skills
                    ).map((skill: any, index: number) => (
                      <div key={index} className="border border-[#432874]/40 rounded p-2">
                        <div className="font-medium text-[#FF9D00]">{skill.name}</div>
                        <div className="text-sm text-[#C8B8DB]/80">{typeof skill.description === 'string' ? skill.description : `Skill effect for ${skill.name}`}</div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          <DialogFooter>
            <Button 
              onClick={() => setShowResultDialog(false)}
              className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      </motion.div>
    </>
  );
};

export default ActiveTasks;

=== client/src/components/characters/CharactersView.tsx ===
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { CharacterCard } from './CharacterCard';
import type { Character, Aura } from '@shared/schema';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Plus, Filter, Search } from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';

const CharactersView = () => {
  const { data: characters = [], isLoading: loadingCharacters, refetch: refetchCharacters } = useQuery<Character[]>({ 
    queryKey: ['/api/characters']
  });
  const { data: auras = [], isLoading: loadingAuras, refetch: refetchAuras } = useQuery<Aura[]>({ 
    queryKey: ['/api/auras']
  });
  const queryClient = useQueryClient();
  const [filter, setFilter] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [showDialog, setShowDialog] = useState(false);
  const { toast } = useToast();
  
  const isLoading = loadingCharacters || loadingAuras;

  const filteredCharacters = characters.filter(character => {
    // Apply search filter
    const matchesSearch = character.name.toLowerCase().includes(searchTerm.toLowerCase());
    
    // Apply category filter
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'active' && character.isActive) ||
      (filter === 'idle' && !character.isActive) ||
      (filter === filter && character.class.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  const handleRecruitCharacter = async () => {
    try {
      // Generate a random character for demonstration
      const randomNames = ["Eldrin", "Lyra", "Thorne", "Seraphina", "Gideon", "Isolde"];
      const randomClasses = ["Warrior", "Mage", "Rogue", "Cleric"];
      const randomAvatars = [
        "https://images.unsplash.com/photo-1577095972620-2f389ca3abcd?w=150&h=150&fit=crop",
        "https://images.unsplash.com/photo-1613477564751-fc2a7c5bbb7a?w=150&h=150&fit=crop",
        "https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=150&h=150&fit=crop"
      ];
      
      const newCharacter = {
        name: randomNames[Math.floor(Math.random() * randomNames.length)],
        class: randomClasses[Math.floor(Math.random() * randomClasses.length)],
        level: 1,
        avatarUrl: randomAvatars[Math.floor(Math.random() * randomAvatars.length)],
        attack: 10 + Math.floor(Math.random() * 5),
        defense: 10 + Math.floor(Math.random() * 5),
        vitality: 100 + Math.floor(Math.random() * 20),
        speed: 10 + Math.floor(Math.random() * 5),
        focus: 10 + Math.floor(Math.random() * 5),
        resilience: 10 + Math.floor(Math.random() * 5),
        accuracy: 10 + Math.floor(Math.random() * 5)
      };
      
      const response = await apiRequest('POST', '/api/characters', newCharacter);
      const data = await response.json();
      
      toast({
        title: "Character Recruited!",
        description: `${data.name} has joined your roster.`
      });
      
      setShowDialog(false);
    } catch (error) {
      console.error('Error recruiting character:', error);
      toast({
        title: "Recruitment Failed",
        description: "Unable to recruit a new character at this time.",
        variant: "destructive"
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl">Loading characters...</div>
      </div>
    );
  }

  return (
    <>
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Characters</h1>
        <p className="text-[#C8B8DB]/80">
          Manage your heroes, equip Auras, and assign them to tasks.
        </p>
      </div>
      
      <div className="flex flex-wrap gap-4 mb-6">
        <div className="relative flex-grow max-w-md">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-[#C8B8DB]/50 h-4 w-4" />
          <input
            type="text"
            placeholder="Search characters..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10 w-full bg-[#1F1D36]/80 border border-[#432874]/30 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-[#FF9D00]"
          />
        </div>
        
        <div className="flex items-center gap-2">
          <Filter className="text-[#C8B8DB]/70 h-4 w-4" />
          <Select value={filter} onValueChange={setFilter}>
            <SelectTrigger className="bg-[#1F1D36]/80 border-[#432874]/30 focus:border-[#FF9D00] focus:ring-0 w-32">
              <SelectValue placeholder="Filter" />
            </SelectTrigger>
            <SelectContent className="bg-[#1A1A2E] border-[#432874]/30">
              <SelectItem value="all">All</SelectItem>
              <SelectItem value="active">Active</SelectItem>
              <SelectItem value="idle">Idle</SelectItem>
              <SelectItem value="warrior">Warrior</SelectItem>
              <SelectItem value="mage">Mage</SelectItem>
              <SelectItem value="rogue">Rogue</SelectItem>
              <SelectItem value="cleric">Cleric</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        <Dialog open={showDialog} onOpenChange={setShowDialog}>
          <DialogTrigger asChild>
            <Button className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]">
              <Plus className="h-4 w-4 mr-2" /> Recruit
            </Button>
          </DialogTrigger>
          <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
            <DialogHeader>
              <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Recruit a New Character</DialogTitle>
            </DialogHeader>
            
            <div className="py-4">
              <div className="bg-[#432874]/20 rounded-lg p-4 text-center mb-4">
                <img
                  src="https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=250&h=250&fit=crop"
                  alt="New Character"
                  className="w-20 h-20 rounded-full border-2 border-[#FF9D00] mx-auto mb-2"
                />
                <p className="text-[#C8B8DB]">
                  Recruiting a new character costs <span className="text-[#FFD700] font-bold">500</span> Rogue Credits.
                </p>
              </div>
              
              <Button 
                className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                onClick={handleRecruitCharacter}
              >
                Recruit Random Character
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>
      
      {filteredCharacters.length === 0 ? (
        <div className="bg-[#1A1A2E] rounded-xl p-8 text-center">
          <p className="text-[#C8B8DB]/80 mb-4">
            {searchTerm 
              ? `No characters found matching "${searchTerm}"` 
              : "You don't have any characters yet."}
          </p>
          <Button 
            className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
            onClick={() => setShowDialog(true)}
          >
            <Plus className="h-4 w-4 mr-2" /> Recruit Your First Character
          </Button>
        </div>
      ) : (
        <motion.div 
          className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
          variants={container}
          initial="hidden"
          animate="show"
        >
          {filteredCharacters.map((character) => (
            <CharacterCard 
              key={character.id} 
              character={character} 
              availableAuras={auras}
              allAuras={auras}
              refetchAura={() => refetchAuras()}
              refetchAllAuras={() => refetchAuras()}
              equippedAura={auras.find(aura => aura.id === character.equippedAuraId)}
            />
          ))}
        </motion.div>
      )}
    </>
  );
};

export default CharactersView;


=== client/src/components/characters/CharacterCard.tsx ===
import { motion } from 'framer-motion';
import { useState } from 'react';
import type { Character, Aura } from '@shared/schema';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import TooltipWrapper from '@/components/common/TooltipWrapper';
import { 
  Lock,
  Shield, 
  Swords, 
  Heart, 
  Zap, 
  Brain, 
  Flower2, 
  Clock,
  Star,
  Bolt,
  Flame, 
  Info,
  Droplet,
  Leaf,
  Wind,
  Check,
  Target,
  ChevronRight,
  Sparkles,
  Loader2,
  CircleOff,
  Eye,
  Anchor,
  Droplets
} from 'lucide-react';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger,
  DialogDescription,
  DialogFooter 
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from "@/components/ui/select";
import CountdownTimer from '../common/CountdownTimer';

interface CharacterCardProps {
  character: Character;
  availableAuras: Aura[];
  refetchAura?: () => void;
  refetchAllAuras?: () => void;
  showDetailed?: boolean;
  allAuras: Aura[];
  equippedAura?: Aura | null;
}

const CharacterCard = ({ 
  character, 
  availableAuras, 
  refetchAura, 
  refetchAllAuras,
  showDetailed = false,
  allAuras = [],
  equippedAura
}: CharacterCardProps) => {
  const [equipAuraDialogOpen, setEquipAuraDialogOpen] = useState(false);
  const [detailDialogOpen, setDetailDialogOpen] = useState(false);
  const [duplicatesDialogOpen, setDuplicatesDialogOpen] = useState(false);
  const [upgradeDialogOpen, setUpgradeDialogOpen] = useState(false);
  const [selectedAuraId, setSelectedAuraId] = useState<number | null>(null);
  const [isEquipping, setIsEquipping] = useState(false);
  const [isUpgrading, setIsUpgrading] = useState(false);
  
  // Mock data for character duplicates and soul shards - will need to be updated with real data later
  const [duplicateCount, setDuplicateCount] = useState(Math.floor(Math.random() * 5)); // Placeholder
  const [soulShardCount, setSoulShardCount] = useState(Math.floor(Math.random() * 100)); // Placeholder
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Find aura equipped by this character
  const aura = allAuras.find(a => a.id === character.equippedAuraId);

  // Get skills from aura
  let auraSkills: any[] = [];
  if (aura && aura.skills) {
    try {
      if (typeof aura.skills === 'string') {
        auraSkills = JSON.parse(aura.skills);
      } else if (Array.isArray(aura.skills)) {
        auraSkills = aura.skills;
      }
    } catch (e) {
      console.error('Failed to parse aura skills:', e);
    }
  }

  // Function to calculate status text based on a stat's multiplier
  const getStatModifierText = (statValue: number | null) => {
    if (!statValue) return <span className="text-gray-500">0%</span>;
    
    if (statValue > 0) {
      return <span className="text-green-500">+{statValue}%</span>;
    } else if (statValue < 0) {
      return <span className="text-red-500">{statValue}%</span>;
    } else {
      return <span className="text-gray-500">0%</span>;
    }
  };
  
  // Calculate stat values with aura modifiers applied
  const getAdjustedStat = (baseStat: number | null, auraStat: number | null): number => {
    if (!baseStat) return 0;
    if (!auraStat) return baseStat;
    
    // Apply percentage modifier from aura
    const adjustedValue = Math.round(baseStat * (1 + auraStat / 100));
    return adjustedValue;
  };

  // Calculate total stat bonus for an aura (sum of all stat percentages)
  const calculateTotalStats = (aura: Aura | null | undefined): number => {
    if (!aura) return 0;
    
    let total = 0;
    total += aura.attack || 0;
    total += aura.vitality || 0;
    total += aura.speed || 0;
    total += aura.defense || 0;
    total += aura.accuracy || 0;
    total += aura.focus || 0;
    total += aura.resilience || 0;
    return total;
  };

  // State for filtering auras by element
  const [elementFilter, setElementFilter] = useState<string>("all");
  
  // Get a list of all unique aura elements
  const uniqueElements = Array.from(new Set(availableAuras
    .map(a => a.element)
    .filter(element => element !== undefined && element !== null)
  )) as string[];
  
  // Filter and sort auras
  const unequippedAuras = availableAuras 
    ? availableAuras
        .filter(a => !a.equippedByCharacterId && !a.isFusing)
        .filter(a => elementFilter === "all" || a.element === elementFilter)
        // First sort by total stats (descending), then by level (descending)
        .sort((a, b) => {
          const totalStatsA = calculateTotalStats(a);
          const totalStatsB = calculateTotalStats(b);
          if (totalStatsB !== totalStatsA) {
            return totalStatsB - totalStatsA;
          }
          return (b.level || 0) - (a.level || 0);
        })
    : [];

  // Function to equip an aura to the character
  const equipAura = async () => {
    if (!selectedAuraId) return;

    setIsEquipping(true);
    try {
      const response = await apiRequest('POST', `/api/characters/${character.id}/equip-aura/${selectedAuraId}`);
      console.log("Equip aura response:", response);
      
      // Update character in place with the new equippedAuraId
      // This ensures we don't have to wait for the query invalidation
      character.equippedAuraId = selectedAuraId;
      
      // Force immediate refresh of ALL related data
      queryClient.invalidateQueries({ queryKey: ['/api/characters'] });
      queryClient.invalidateQueries({ queryKey: ['/api/auras'] });
      queryClient.refetchQueries({ queryKey: ['/api/characters'] });
      queryClient.refetchQueries({ queryKey: ['/api/auras'] });
      
      // We also need to directly refetch the specific aura data
      if (refetchAura) refetchAura();
      if (refetchAllAuras) refetchAllAuras();
      
      // Force fetch for the newly equipped aura
      queryClient.fetchQuery({ 
        queryKey: [`/api/auras/${selectedAuraId}`]
      });
      
      // Wait a moment and then perform a second round of refreshes
      // This handles any potential race conditions
      setTimeout(() => {
        if (refetchAura) refetchAura();
        if (refetchAllAuras) refetchAllAuras();
        queryClient.refetchQueries({ queryKey: ['/api/characters'] });
        console.log("Completed second round of data refreshes");
        
        // Create a simulated cache update for immediate UI feedback
        // This makes the UI show the new aura right away
        const auraToEquip = allAuras.find(a => a.id === selectedAuraId);
        if (auraToEquip) {
          console.log("Using cached aura data for immediate display:", auraToEquip);
          queryClient.setQueryData([`/api/auras/${selectedAuraId}`], auraToEquip);
        }
      }, 500);

      toast({
        title: "Aura equipped",
        description: "The aura has been successfully equipped to your character.",
      });

      setEquipAuraDialogOpen(false);
    } catch (error) {
      console.error('Failed to equip aura:', error);
      toast({
        title: "Failed to equip aura",
        description: "There was an error equipping the aura. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsEquipping(false);
    }
  };

  // Function to get element icon
  const getElementIcon = (element?: string) => {
    if (!element) return null;
    switch (element.toLowerCase()) {
      case 'fire': return <Flame className="h-4 w-4 text-red-500" />;
      case 'water': return <Droplet className="h-4 w-4 text-blue-500" />;
      case 'earth': return <Leaf className="h-4 w-4 text-green-500" />;
      case 'wind': return <Wind className="h-4 w-4 text-cyan-400" />;
      default: return <Flame className="h-4 w-4 text-red-500" />;
    }
  };

  const getClassColor = (characterClass: string) => {
    const classColors: Record<string, string> = {
      'warrior': 'bg-red-700/30 text-red-400',
      'mage': 'bg-blue-700/30 text-blue-400',
      'rogue': 'bg-green-700/30 text-green-400',
      'cleric': 'bg-yellow-700/30 text-yellow-400',
    };

    return classColors[characterClass.toLowerCase()] || 'bg-gray-700/30 text-gray-400';
  };

  // Function to get activity text
  const getActivityText = () => {
    if (!character.isActive) return null;

    return (
      <div className="absolute top-2 right-2 flex items-center space-x-1">
        <Badge variant="outline" className="bg-[#DC143C]/20 text-[#DC143C] border-[#DC143C]/30 flex items-center">
          <Lock className="h-3 w-3 mr-1" />
          {character.activityType === 'farming' ? 'Farming' : 'Dungeon'}
          {character.activityEndTime && (
            <>
              <span className="mx-1"></span>
              <CountdownTimer endTime={character.activityEndTime} />
            </>
          )}
        </Badge>
      </div>
    );
  };

  const getAuraElementClass = (element?: string) => {
    if (!element) return 'bg-gradient-to-r from-gray-500 to-gray-700';
    switch (element.toLowerCase()) {
      case 'fire': return 'bg-gradient-to-r from-red-500 to-orange-500';
      case 'water': return 'bg-gradient-to-r from-blue-500 to-cyan-500';
      case 'earth': return 'bg-gradient-to-r from-green-500 to-lime-500';
      case 'wind': return 'bg-gradient-to-r from-sky-500 to-cyan-500';
      default: return 'bg-gradient-to-r from-purple-500 to-pink-500';
    }
  };
  
  // Function to generate skill logic text from skill properties
  const generateSkillLogic = (skill: any): string => {
    let logic = '';
    
    // Special case for Soothing Current
    if (skill.name === "Soothing Current") {
      return `${skill.damage}x Damage to 1 Target and Heal the lowest HP Ally for ${skill.healing || 5}% of the Caster's Max Health`;
    }
    
    // Damage component
    if (skill.damage) {
      logic += `${skill.damage}x Damage to ${skill.targets || 1} Target${skill.targets > 1 ? 's' : ''}`;
    }
    
    // Healing component
    if (skill.healing) {
      if (logic) logic += ' and ';
      
      let healingText = `Heal `;
      if (skill.healTargetType === "lowest") {
        healingText += "the lowest HP Ally";
      } else if (skill.healTargetType === "all") {
        healingText += "all Allies";
      } else {
        healingText += `${skill.healTargets || 1} Target${(skill.healTargets || 1) > 1 ? 's' : ''}`;
      }
      
      healingText += ` for ${skill.healing}% of `;
      healingText += "the Caster's Max Health";
      
      logic += healingText;
    }
    
    // Effect component
    if (skill.effect) {
      if (logic) logic += ' and ';
      logic += `Apply ${skill.effect}`;
      if (skill.effectStacks) logic += ` (${skill.effectStacks} stacks)`;
      if (skill.effectChance && skill.effectChance < 100) logic += ` with ${skill.effectChance}% chance`;
    }
    

    
    // Special case for known skills that need hardcoded logic
    if (skill.name === "Soothing Current" && !logic) {
      return `${skill.damage || 0.8}x Damage to 1 Target and Heal the lowest HP Ally for ${skill.healing || 5}% of the Caster's Max Health`;
    }
    
    // If we couldn't generate logic, use description as fallback
    if (!logic && skill.description) {
      return skill.description;
    }
    
    return logic || 'Attack a single target';
  };
  
  // Function to upgrade character level
  const upgradeCharacter = async () => {
    setIsUpgrading(true);
    try {
      // Calculate requirements based on character level
      const currentLevel = character.level || 1;
      const requiredShards = currentLevel * 5;
      const requiredEssence = currentLevel * 100;
      
      // Mock API call for now - will be replaced with actual API endpoint
      console.log(`Upgrading character ${character.name} from level ${currentLevel} to ${currentLevel + 1}`);
      console.log(`Required: ${requiredShards} Soul Shards, ${requiredEssence} Essence`);
      
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Update character level locally for immediate feedback
      character.level = currentLevel + 1;
      
      // Update local state for soul shards
      setSoulShardCount(prev => prev - requiredShards);
      
      // Force refresh of characters data
      queryClient.invalidateQueries({ queryKey: ['/api/characters'] });
      
      toast({
        title: "Character Upgraded",
        description: `${character.name} is now level ${character.level}!`,
      });
      
      setUpgradeDialogOpen(false);
    } catch (error) {
      console.error('Failed to upgrade character:', error);
      toast({
        title: "Upgrade Failed",
        description: "There was an error upgrading the character. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsUpgrading(false);
    }
  };

  return (
    <>
      {/* Equip Aura Dialog */}
      <Dialog open={equipAuraDialogOpen} onOpenChange={setEquipAuraDialogOpen}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-5xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel">
              Equip Aura to {character.name}
            </DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              Select an aura to equip to your character. Only unequipped auras are shown.
            </DialogDescription>
          </DialogHeader>

          <div className="my-4">
            {/* Element filter dropdown */}
            <div className="mb-4 flex items-center">
              <div className="mr-2 text-sm font-medium">Filter by element:</div>
              <select 
                className="bg-[#1A1A2E] border border-[#432874] rounded px-2 py-1 text-sm text-[#C8B8DB]"
                value={elementFilter}
                onChange={(e) => setElementFilter(e.target.value)}
              >
                <option value="all">All Elements</option>
                {uniqueElements.map(element => (
                  <option key={element} value={element}>{element}</option>
                ))}
              </select>
              
              {/* Total stats indicator */}
              <div className="ml-auto text-xs text-[#C8B8DB]/70">
                Sorted by total stat bonuses
              </div>
            </div>
            
            {unequippedAuras.length === 0 ? (
              <div className="py-8 text-center text-[#C8B8DB]/60">
                No available auras to equip. Craft new auras in the Forge.
              </div>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {unequippedAuras.map((aura) => (
                  <div
                    key={aura.id}
                    className={`p-4 rounded-lg border transition-all cursor-pointer ${
                      selectedAuraId === aura.id
                        ? "border-[#FF9D00] bg-[#432874]/40"
                        : "border-[#432874]/40 bg-[#1A1A2E] hover:bg-[#432874]/20"
                    }`}
                    onClick={() => setSelectedAuraId(aura.id)}
                  >
                    <div className="flex items-center justify-between mb-2">
                      <div className="flex items-center">
                        {getElementIcon(aura.element)} 
                        <span className="ml-2 font-semibold text-[#FF9D00]">{aura.name}</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className="text-xs px-2 py-0.5 bg-[#432874]/60 rounded-full">Level {aura.level}</span>
                        <span className="text-xs px-2 py-0.5 rounded bg-[#00B9AE]/20 text-[#00B9AE] font-semibold">
                          +{calculateTotalStats(aura)}%
                        </span>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-2 gap-2 text-xs mt-3">
                      {aura.attack !== null && (
                        <div className="flex items-center">
                          <Swords className="h-3 w-3 mr-1 text-red-400" />
                          <span>ATK: {aura.attack && aura.attack > 0 ? '+' : ''}{aura.attack}%</span>
                        </div>
                      )}
                      {aura.vitality !== null && (
                        <div className="flex items-center">
                          <Heart className="h-3 w-3 mr-1 text-red-400" />
                          <span>VIT: {aura.vitality && aura.vitality > 0 ? '+' : ''}{aura.vitality}%</span>
                        </div>
                      )}
                      {aura.speed !== null && (
                        <div className="flex items-center">
                          <Zap className="h-3 w-3 mr-1 text-yellow-400" />
                          <span>SPD: {aura.speed && aura.speed > 0 ? '+' : ''}{aura.speed}%</span>
                        </div>
                      )}
                      {aura.accuracy !== null && (
                        <div className="flex items-center">
                          <Target className="h-3 w-3 mr-1 text-blue-400" />
                          <span>ACC: {aura.accuracy && aura.accuracy > 0 ? '+' : ''}{aura.accuracy}%</span>
                        </div>
                      )}
                      {aura.defense !== null && (
                        <div className="flex items-center">
                          <Shield className="h-3 w-3 mr-1 text-green-400" />
                          <span>DEF: {aura.defense && aura.defense > 0 ? '+' : ''}{aura.defense}%</span>
                        </div>
                      )}
                      {aura.focus !== null && (
                        <div className="flex items-center">
                          <Eye className="h-3 w-3 mr-1 text-indigo-400" />
                          <span>FOC: {aura.focus && aura.focus > 0 ? '+' : ''}{aura.focus}%</span>
                        </div>
                      )}
                      {aura.resilience !== null && (
                        <div className="flex items-center">
                          <Anchor className="h-3 w-3 mr-1 text-purple-400" />
                          <span>RES: {aura.resilience && aura.resilience > 0 ? '+' : ''}{aura.resilience}%</span>
                        </div>
                      )}
                    </div>
                    
                    {/* Show related aura skills if they exist */}
                    {(() => {
                      try {
                        const skills = aura.skills ? 
                          (typeof aura.skills === 'string' ? JSON.parse(aura.skills) : aura.skills) : 
                          [];
                        
                        if (skills && skills.length > 0) {
                          return (
                            <div className="mt-2 border-t border-[#432874]/30 pt-2">
                              <div className="flex items-center text-xs text-[#FF9D00] mb-1">
                                <Sparkles className="h-3 w-3 mr-1" />
                                <span>Aura Skills</span>
                              </div>
                              <div className="text-xs text-[#C8B8DB]/80 space-y-1">
                                {skills.map((skill: any, index: number) => (
                                  <div key={index} className="border-b border-[#432874]/20 last:border-b-0 pb-1 last:pb-0">
                                    <div className="font-medium text-[#00B9AE]"> {skill.name}</div>
                                    {skill.description && <div className="text-[#C8B8DB]/70 text-2xs ml-2">{skill.description}</div>}
                                    {!skill.description && skill.logic && <div className="text-[#C8B8DB]/70 text-2xs ml-2">{generateSkillLogic(skill)}</div>}
                                  </div>
                                ))}
                              </div>
                            </div>
                          );
                        }
                      } catch (e) {
                        console.error('Failed to parse aura skills in grid:', e);
                      }
                      return null;
                    })()}
                  </div>
                ))}
              </div>
            )}

            {selectedAuraId && (
              <div className="mt-4 p-3 bg-[#432874]/20 rounded-lg">
                <h4 className="font-semibold mb-2 text-sm">Selected Aura Details</h4>
                {(() => {
                  const selectedAura = unequippedAuras.find(a => a.id === selectedAuraId);
                  if (!selectedAura) return <div>No aura selected</div>;

                  // Parse skills if they exist
                  const skills = selectedAura.skills ? 
                    typeof selectedAura.skills === 'string' ? 
                      JSON.parse(selectedAura.skills as string) : 
                      selectedAura.skills : 
                    [];

                  return (
                    <div className="text-sm">
                      <div className="flex items-center mb-1">
                        {getElementIcon(selectedAura.element)} 
                        <span className="ml-2 text-[#00B9AE]">{selectedAura.name}</span>
                      </div>
                      <div className="grid grid-cols-2 gap-x-4 gap-y-1 mb-2">
                        <div>Element: {selectedAura.element}</div>
                        <div>Level: {selectedAura.level}</div>
                        <div>Tier: {selectedAura.tier}</div>
                        <div className="text-[#00B9AE] font-semibold">
                          Total Bonus: +{calculateTotalStats(selectedAura)}%
                        </div>
                      </div>

                      {skills && skills.length > 0 && (
                        <div className="mt-3">
                          <div className="flex items-center mb-2 text-xs">
                            <Sparkles className="h-3 w-3 mr-1 text-[#FF9D00]" />
                            <h5 className="font-semibold text-[#FF9D00]">Aura Skills</h5>
                          </div>
                          <div className="space-y-2 border rounded-md border-[#432874]/40 p-2 bg-[#1A1A2E]/50">
                            {skills.map((skill: any, index: number) => (
                              <div key={index} className="border-b last:border-b-0 border-[#432874]/30 pb-2 last:pb-0">
                                <div className="font-medium text-xs text-[#00B9AE]">{skill.name}</div>
                                {skill.description ? (
                                  <div className="text-xs text-[#C8B8DB]/80 mt-0.5">{skill.description}</div>
                                ) : (
                                  <div className="text-xs text-[#C8B8DB]/80 mt-0.5">{generateSkillLogic(skill)}</div>
                                )}
                              </div>
                            ))}
                          </div>
                        </div>
                      )}

                      {/* Always show stat bonuses, even if all are 0 */}
                      {(selectedAura.attack !== null || selectedAura.accuracy !== null || selectedAura.defense !== null || 
                        selectedAura.vitality !== null || selectedAura.speed !== null || selectedAura.focus !== null || 
                        selectedAura.resilience !== null) && (
                        <div className="mt-3">
                          <div className="flex items-center mb-2 text-xs">
                            <Info className="h-3 w-3 mr-1 text-[#FF9D00]" />
                            <h5 className="font-semibold text-[#FF9D00]">Total Stat Bonuses</h5>
                          </div>
                          <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-xs bg-[#1A1A2E]/50 p-2 border border-[#432874]/40 rounded-md">
                            {selectedAura.attack !== null && (
                              <div className="flex justify-between">
                                <span>Attack:</span>
                                <span className={selectedAura.attack && selectedAura.attack > 0 ? "text-green-400" : selectedAura.attack < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.attack}%
                                </span>
                              </div>
                            )}
                            {selectedAura.accuracy !== null && (
                              <div className="flex justify-between">
                                <span>Accuracy:</span>
                                <span className={selectedAura.accuracy && selectedAura.accuracy > 0 ? "text-green-400" : selectedAura.accuracy < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.accuracy}%
                                </span>
                              </div>
                            )}
                            {selectedAura.defense !== null && (
                              <div className="flex justify-between">
                                <span>Defense:</span>
                                <span className={selectedAura.defense && selectedAura.defense > 0 ? "text-green-400" : selectedAura.defense < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.defense}%
                                </span>
                              </div>
                            )}
                            {selectedAura.vitality !== null && (
                              <div className="flex justify-between">
                                <span>Vitality:</span>
                                <span className={selectedAura.vitality && selectedAura.vitality > 0 ? "text-green-400" : selectedAura.vitality < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.vitality}%
                                </span>
                              </div>
                            )}
                            {selectedAura.speed !== null && (
                              <div className="flex justify-between">
                                <span>Speed:</span>
                                <span className={selectedAura.speed && selectedAura.speed > 0 ? "text-green-400" : selectedAura.speed < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.speed}%
                                </span>
                              </div>
                            )}
                            {selectedAura.focus !== null && (
                              <div className="flex justify-between">
                                <span>Focus:</span>
                                <span className={selectedAura.focus && selectedAura.focus > 0 ? "text-green-400" : selectedAura.focus < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.focus}%
                                </span>
                              </div>
                            )}
                            {selectedAura.resilience !== null && (
                              <div className="flex justify-between">
                                <span>Resilience:</span>
                                <span className={selectedAura.resilience && selectedAura.resilience > 0 ? "text-green-400" : selectedAura.resilience < 0 ? "text-red-400" : "text-[#C8B8DB]/60"}>
                                  {selectedAura.resilience}%
                                </span>
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })()}
              </div>
            )}
          </div>

          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setEquipAuraDialogOpen(false)}
              className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
            >
              Cancel
            </Button>
            <Button 
              onClick={equipAura} 
              disabled={!selectedAuraId || isEquipping}
              className="bg-[#432874] hover:bg-[#432874]/80"
            >
              {isEquipping ? "Equipping..." : "Equip Aura"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Character Details Dialog */}
      <Dialog open={detailDialogOpen} onOpenChange={setDetailDialogOpen}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-3xl">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel">
              {character.name} - Level {character.level} {character.class}
            </DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              Character details and equipped aura information
            </DialogDescription>
          </DialogHeader>
          
          <div className="my-4 space-y-6">
            {/* Character stats and details */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                <div className="flex items-center space-x-4">
                  <div className="relative">
                    <img
                      src={character.avatarUrl}
                      alt={character.name}
                      className="w-24 h-24 rounded-full object-cover border-2 border-[#432874]"
                    />
                    <div className="absolute -bottom-1 -right-1 bg-[#1A1A2E] rounded-full p-0.5 border border-[#432874]">
                      <div className="bg-[#432874] text-white text-xs w-6 h-6 rounded-full flex items-center justify-center font-bold">
                        {character.level}
                      </div>
                    </div>
                  </div>
                  
                  <div>
                    <h3 className="font-cinzel font-bold text-xl text-[#C8B8DB]">
                      {character.name}
                    </h3>
                    <div className="flex items-center space-x-2 mt-1">
                      <Badge className={`font-normal ${getClassColor(character.class)}`}>
                        {character.class}
                      </Badge>
                      <span className="text-sm text-[#C8B8DB]/80">
                        Level {character.level || 1}
                      </span>
                    </div>
                  </div>
                </div>
                
                <div className="grid grid-cols-2 gap-4 bg-[#432874]/20 p-4 rounded-lg">
                  <div className="flex items-center space-x-2">
                    <Swords className="h-4 w-4 text-red-400" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Attack</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.attack, aura.attack) : character.attack}
                        {aura && aura.attack !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.attack)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Target className="h-4 w-4 text-yellow-400" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Accuracy</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.accuracy, aura.accuracy) : character.accuracy}
                        {aura && aura.accuracy !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.accuracy)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Shield className="h-4 w-4 text-blue-400" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Defense</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.defense, aura.defense) : character.defense}
                        {aura && aura.defense !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.defense)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Heart className="h-4 w-4 text-red-500" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Vitality</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.vitality, aura.vitality) : character.vitality}
                        {aura && aura.vitality !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.vitality)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Zap className="h-4 w-4 text-cyan-400" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Speed</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.speed, aura.speed) : character.speed}
                        {aura && aura.speed !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.speed)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Brain className="h-4 w-4 text-purple-400" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Focus</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.focus || 0, aura.focus) : character.focus || 0}
                        {aura && aura.focus !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.focus)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <CircleOff className="h-4 w-4 text-purple-400" />
                    <div className="flex flex-col">
                      <span className="text-xs text-[#C8B8DB]/60">Resilience</span>
                      <span className="font-medium">
                        {aura ? getAdjustedStat(character.resilience || 0, aura.resilience) : character.resilience || 0}
                        {aura && aura.resilience !== 0 && (
                          <span className="ml-1 text-xs text-[#C8B8DB]/60">
                            ({getStatModifierText(aura.resilience)})
                          </span>
                        )}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
              
              <div className="space-y-4">
                {aura || equippedAura ? (
                  <>
                    <div className="bg-[#432874]/20 rounded-lg p-4">
                      <h4 className="font-semibold text-sm mb-2 text-[#00B9AE]">Equipped Aura</h4>
                      <div className="flex items-center mb-3">
                        <div className={`w-10 h-10 rounded-full flex items-center justify-center mr-3 ${getAuraElementClass((aura || equippedAura)?.element)}`}>
                          {getElementIcon((aura || equippedAura)?.element)}
                        </div>
                        <div>
                          <div className="text-[#00B9AE] font-semibold">{(aura || equippedAura)?.name}</div>
                          <div className="flex items-center gap-2">
                            <div className="text-xs text-[#C8B8DB]/80">
                              Level {(aura || equippedAura)?.level}  Tier {(aura || equippedAura)?.tier}  {(aura || equippedAura)?.element}
                            </div>
                            {(aura || equippedAura) && (
                              <div className="px-2 py-0.5 rounded bg-[#00B9AE]/20 text-[#00B9AE] text-xs font-semibold">
                                Total: +{calculateTotalStats(aura || equippedAura)}%
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-2 gap-2">
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <Swords className="h-3 w-3 mr-1 text-red-400" />
                            <span className="text-xs">Attack</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.attack || null)}
                          </div>
                        </div>
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <Target className="h-3 w-3 mr-1 text-yellow-400" />
                            <span className="text-xs">Accuracy</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.accuracy || null)}
                          </div>
                        </div>
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <Shield className="h-3 w-3 mr-1 text-blue-400" />
                            <span className="text-xs">Defense</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.defense || null)}
                          </div>
                        </div>
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <Heart className="h-3 w-3 mr-1 text-red-500" />
                            <span className="text-xs">Vitality</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.vitality || null)}
                          </div>
                        </div>
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <Zap className="h-3 w-3 mr-1 text-cyan-400" />
                            <span className="text-xs">Speed</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.speed || null)}
                          </div>
                        </div>
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <Brain className="h-3 w-3 mr-1 text-purple-400" />
                            <span className="text-xs">Focus</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.focus || null)}
                          </div>
                        </div>
                        <div className="flex justify-between items-center">
                          <div className="flex items-center">
                            <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                            <span className="text-xs">Resilience</span>
                          </div>
                          <div className="text-xs">
                            {getStatModifierText((aura || equippedAura)?.resilience || null)}
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <div className="bg-[#432874]/20 rounded-lg p-4">
                      <h4 className="font-semibold text-sm mb-2 text-[#00B9AE]">Aura Skills</h4>
                      <div className="space-y-2">
                        {auraSkills.length > 0 ? (
                          auraSkills.map((skill: any, index) => (
                            <div key={index} className="border-b border-[#432874]/30 pb-3 last:border-b-0 last:pb-0">
                              <div className="flex justify-between items-center">
                                <div className="text-xs font-medium text-[#00B9AE]">{skill.name}</div>
                                <div className="text-xs px-2 py-0.5 rounded-full bg-[#432874]/40 text-[#00B9AE]">
                                  Level {skill.level || 1}
                                </div>
                              </div>

                              {/* Full skill logic */}
                              <div className="text-xs text-amber-300 mt-1 italic">
                                "{skill.logic || generateSkillLogic(skill)}"
                              </div>
                              
                              <div className="text-xs text-[#C8B8DB]/80 mt-1">{skill.description}</div>
                              
                              {/* Enhanced skill details */}
                              <div className="mt-2 text-xs">
                                {skill.damage && (
                                  <div className="flex items-center">
                                    <Swords className="h-3 w-3 mr-1 text-red-400" />
                                    <span className="text-[#C8B8DB]/80">
                                      Damage Multiplier: <span className="text-amber-400">{skill.damage}x</span> (Deals {skill.damage}x of Attack as damage)
                                    </span>
                                  </div>
                                )}
                                
                                {skill.effect && (
                                  <div className="flex items-center mt-1">
                                    <Flame className="h-3 w-3 mr-1 text-orange-400" />
                                    <span className="text-[#C8B8DB]/80">
                                      Effect: <span className="text-purple-400">{skill.effect}</span>
                                      {skill.effectChance && <span className="ml-1 text-yellow-400">({skill.effectChance}% chance)</span>}
                                      {skill.effectStacks && <span className="ml-1 text-blue-400">({skill.effectStacks} stacks)</span>}
                                    </span>
                                  </div>
                                )}
                                
                                {skill.healing && (
                                  <div className="flex items-center mt-1">
                                    <Heart className="h-3 w-3 mr-1 text-green-400" />
                                    <span className="text-[#C8B8DB]/80">
                                      Healing: <span className="text-green-400">{skill.healing}%</span> of max health
                                      {skill.healTargets && <span className="ml-1 text-blue-400">({skill.healTargets > 1 ? `${skill.healTargets} targets` : '1 target'})</span>}
                                    </span>
                                  </div>
                                )}
                                
                                {skill.cooldown && (
                                  <div className="flex items-center mt-1">
                                    <Clock className="h-3 w-3 mr-1 text-blue-400" />
                                    <span className="text-[#C8B8DB]/80">
                                      Cooldown: <span className="text-blue-400">{skill.cooldown} turns</span>
                                    </span>
                                  </div>
                                )}
                              </div>
                              
                              <div className="flex justify-between mt-2 text-xs text-[#C8B8DB]/60">
                                <span>Type: 
                                  <span className={
                                    skill.type === "Ultimate" ? " text-amber-500" : 
                                    skill.type === "Advanced" ? " text-blue-500" : 
                                    " text-green-500"
                                  }>
                                    {" "}{skill.type}
                                  </span>
                                </span>
                                <span>Targets: {skill.targets || 1}</span>
                              </div>
                            </div>
                          ))
                        ) : (
                          <div className="text-xs text-[#C8B8DB]/60">No skills available</div>
                        )}
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="bg-[#432874]/20 rounded-lg p-6 text-center">
                    <Info className="h-8 w-8 text-[#C8B8DB]/60 mx-auto mb-2" />
                    <p className="text-sm text-[#C8B8DB]/80">No Aura Equipped</p>
                    <p className="text-xs text-[#C8B8DB]/60 mt-1">Equip an aura to enhance your character's abilities</p>
                  </div>
                )}
              </div>
            </div>
            
            {/* Character management section */}
            <div className="flex flex-col space-y-4">
              {/* Soul shard & duplicate info */}
              <div className="bg-[#432874]/20 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <div className="flex items-center space-x-2">
                    <Star className="h-4 w-4 text-purple-400" />
                    <span className="text-sm">Soul Shards: <span className="text-purple-400 font-semibold">{soulShardCount}</span></span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <span className="text-sm">Duplicates: <span className="text-blue-400 font-semibold">{duplicateCount}</span></span>
                  </div>
                </div>
              </div>

              {/* Action buttons */}
              <div className="flex justify-end space-x-3">
                {!character.isActive && (
                  <>
                    <Button
                      variant="outline"
                      className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
                      onClick={() => setDuplicatesDialogOpen(true)}
                    >
                      View Duplicates
                    </Button>
                    <Button
                      variant="outline"
                      className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
                      onClick={() => setUpgradeDialogOpen(true)}
                    >
                      Upgrade Level
                    </Button>
                    <Button
                      variant="outline"
                      className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
                      onClick={() => {
                        setDetailDialogOpen(false);
                        setEquipAuraDialogOpen(true);
                      }}
                    >
                      Equip Aura
                    </Button>
                    <Button className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]">
                      Assign Task
                    </Button>
                  </>
                )}
                {character.isActive && (
                  <div className="flex items-center text-[#DC143C]">
                    <Lock className="h-4 w-4 mr-1" />
                    <span>
                      Busy: {character.activityType} 
                      {character.activityEndTime && (
                        <span className="ml-1">
                          (<CountdownTimer endTime={character.activityEndTime} />)
                        </span>
                      )}
                    </span>
                  </div>
                )}
              </div>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Duplicates Dialog */}
      <Dialog open={duplicatesDialogOpen} onOpenChange={setDuplicatesDialogOpen}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-2xl">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel">
              {character.name} - Duplicates
            </DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              View and manage character duplicates to obtain Soul Shards
            </DialogDescription>
          </DialogHeader>
          
          <div className="my-4 space-y-4">
            {/* Soul Shard Summary */}
            <div className="flex items-center justify-between bg-[#432874]/20 p-3 rounded-lg">
              <div className="flex items-center space-x-3">
                <div className="w-10 h-10 rounded-full bg-purple-900/50 flex items-center justify-center">
                  <Star className="h-5 w-5 text-purple-400" />
                </div>
                <div>
                  <div className="text-sm text-[#C8B8DB]/80">Total Soul Shards</div>
                  <div className="text-xl font-bold text-purple-400">{soulShardCount}</div>
                </div>
              </div>
              
              <div className="text-sm text-[#C8B8DB]/60">
                Soul Shards are used to upgrade character levels.<br />
                Convert duplicates to gain more Soul Shards.
              </div>
            </div>
            
            {/* Character Duplicates List */}
            <div className="space-y-3">
              <h3 className="text-sm font-semibold text-[#C8B8DB]">
                Character Duplicates ({duplicateCount})
              </h3>
              
              {duplicateCount > 0 ? (
                <div className="space-y-3 max-h-60 overflow-y-auto pr-2">
                  {/* This would be mapped from actual duplicates - using example for now */}
                  {Array.from({ length: duplicateCount }).map((_, index) => (
                    <div key={index} className="bg-[#432874]/10 p-3 rounded-lg border border-[#432874]/20">
                      {/* Header with image and basic info */}
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center space-x-3">
                          <img
                            src={character.avatarUrl}
                            alt={character.name}
                            className="w-12 h-12 rounded-full object-cover border-2 border-[#432874]"
                          />
                          <div>
                            <div className="font-medium">{character.name}</div>
                            <div className="flex items-center space-x-2 text-xs text-[#C8B8DB]/80">
                              <Badge className={`font-normal ${getClassColor(character.class)}`}>
                                {character.class}
                              </Badge>
                              <span>Level {character.level}</span>
                            </div>
                          </div>
                        </div>
                        
                        {/* Set as primary button */}
                        <Button 
                          variant="outline" 
                          size="sm"
                          className="bg-transparent border-[#FF9D00]/30 hover:bg-[#FF9D00]/20 text-[#FF9D00]"
                          onClick={() => {
                            // Logic to set this duplicate as primary character
                            toast({
                              title: "Primary Character Changed",
                              description: `${character.name} has been set as your primary character.`,
                              variant: "default",
                            });
                          }}
                        >
                          <Zap className="h-4 w-4 mr-1" />
                          Set as Primary
                        </Button>
                      </div>
                      
                      {/* Character stats summary */}
                      <div className="grid grid-cols-2 gap-x-4 gap-y-1 my-2 text-sm text-[#C8B8DB]/90">
                        <div className="flex justify-between">
                          <span>Attack:</span> 
                          <span className="text-[#FF9D00]">{character.attack || 0}</span>
                        </div>
                        <div className="flex justify-between">
                          <span>Defense:</span> 
                          <span className="text-[#00B9AE]">{character.defense || 0}</span>
                        </div>
                        <div className="flex justify-between">
                          <span>Vitality:</span> 
                          <span className="text-green-500">{character.vitality || 0}</span>
                        </div>
                        <div className="flex justify-between">
                          <span>Accuracy:</span> 
                          <span className="text-blue-400">{character.accuracy || 0}</span>
                        </div>
                      </div>
                      
                      {/* Passive skills if available */}
                      {character.passiveSkills && character.passiveSkills.length > 0 && (
                        <div className="mb-2 text-sm">
                          <div className="text-xs font-semibold text-[#C8B8DB]/90 mb-1">Passive Skills:</div>
                          <div className="flex flex-wrap gap-1">
                            {character.passiveSkills?.map((skill, i) => (
                              <Badge key={i} variant="outline" className="bg-[#432874]/20 text-[#C8B8DB]">
                                {typeof skill === 'string' ? skill : 'Passive Skill'}
                              </Badge>
                            ))}
                          </div>
                        </div>
                      )}
                      
                      {/* Convert button */}
                      <div className="flex justify-end mt-3">
                        <Button 
                          variant="outline" 
                          size="sm"
                          className="bg-transparent border-purple-500/30 hover:bg-purple-900/20 text-purple-400"
                          onClick={() => {
                            // Logic to convert duplicate to soul shards
                            // Temporary implementation
                            toast({
                              title: "Character Converted",
                              description: `Gained +${20 + ((character.level || 1) * 5)} Soul Shards from conversion.`,
                              variant: "default",
                            });
                          }}
                        >
                          <Sparkles className="h-4 w-4 mr-1" />
                          Convert to Shards
                        </Button>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="py-8 text-center text-[#C8B8DB]/60 bg-[#432874]/10 rounded-lg">
                  No duplicates available for this character.
                </div>
              )}
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setDuplicatesDialogOpen(false)}
              className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* Upgrade Character Dialog */}
      <Dialog open={upgradeDialogOpen} onOpenChange={setUpgradeDialogOpen}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-lg">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel">
              Upgrade {character.name}
            </DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              Upgrade your character to increase their stats and abilities
            </DialogDescription>
          </DialogHeader>
          
          <div className="my-4 space-y-5">
            {/* Current Level */}
            <div className="flex items-center justify-center space-x-4">
              <div className="flex flex-col items-center">
                <div className="text-[#C8B8DB]/60 text-sm">Current Level</div>
                <div className="bg-[#432874]/40 h-16 w-16 rounded-full flex items-center justify-center border border-[#432874]/60">
                  <span className="text-2xl font-bold">{character.level}</span>
                </div>
              </div>
              
              <ChevronRight className="h-6 w-6 text-[#C8B8DB]/40" />
              
              <div className="flex flex-col items-center">
                <div className="text-[#C8B8DB]/60 text-sm">Next Level</div>
                <div className="bg-gradient-to-br from-[#432874] to-[#9370DB] h-16 w-16 rounded-full flex items-center justify-center shadow-lg shadow-purple-900/30">
                  <span className="text-2xl font-bold text-white">{(character.level || 1) + 1}</span>
                </div>
              </div>
            </div>
            
            {/* Resource Requirements */}
            <div className="bg-[#432874]/20 p-4 rounded-lg space-y-3">
              <h3 className="text-sm font-semibold text-[#C8B8DB]">Upgrade Requirements</h3>
              
              <div className="flex justify-between items-center">
                <div className="flex items-center space-x-2">
                  <Star className="h-5 w-5 text-purple-400" />
                  <span>Soul Shards</span>
                </div>
                <div className="flex items-center space-x-1">
                  <span className={soulShardCount >= (character.level || 1) * 5 ? "text-green-400" : "text-red-400"}>
                    {soulShardCount}
                  </span>
                  <span className="text-[#C8B8DB]/60">/</span>
                  <span>{(character.level || 1) * 5}</span>
                </div>
              </div>
              
              <div className="flex justify-between items-center">
                <div className="flex items-center space-x-2">
                  <Sparkles className="h-5 w-5 text-blue-400" />
                  <span>Essence</span>
                </div>
                <div className="flex items-center space-x-1">
                  <span className="text-blue-400">???</span>
                  <span className="text-[#C8B8DB]/60">/</span>
                  <span>{(character.level || 1) * 100}</span>
                </div>
              </div>
            </div>
            
            {/* Stat Improvements */}
            <div className="bg-[#432874]/20 p-4 rounded-lg">
              <h3 className="text-sm font-semibold text-[#C8B8DB] mb-2">Stat Improvements</h3>
              
              <div className="grid grid-cols-2 gap-3">
                <div className="flex justify-between items-center">
                  <div className="flex items-center space-x-2">
                    <Swords className="h-4 w-4 text-red-400" />
                    <span className="text-sm">Attack</span>
                  </div>
                  <div className="text-sm text-green-400">+{Math.ceil((character.attack || 0) * 0.1)}</div>
                </div>
                
                <div className="flex justify-between items-center">
                  <div className="flex items-center space-x-2">
                    <Shield className="h-4 w-4 text-blue-400" />
                    <span className="text-sm">Defense</span>
                  </div>
                  <div className="text-sm text-green-400">+{Math.ceil((character.defense || 0) * 0.1)}</div>
                </div>
                
                <div className="flex justify-between items-center">
                  <div className="flex items-center space-x-2">
                    <Heart className="h-4 w-4 text-red-500" />
                    <span className="text-sm">Vitality</span>
                  </div>
                  <div className="text-sm text-green-400">+{Math.ceil((character.vitality || 0) * 0.1)}</div>
                </div>
                
                <div className="flex justify-between items-center">
                  <div className="flex items-center space-x-2">
                    <Target className="h-4 w-4 text-yellow-400" />
                    <span className="text-sm">Accuracy</span>
                  </div>
                  <div className="text-sm text-green-400">+{Math.ceil((character.accuracy || 0) * 0.1)}</div>
                </div>
              </div>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setUpgradeDialogOpen(false)}
              className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
            >
              Cancel
            </Button>
            <Button 
              onClick={upgradeCharacter}
              disabled={isUpgrading || soulShardCount < (character.level || 1) * 5}
              className="bg-gradient-to-r from-[#432874] to-[#9370DB] text-white hover:from-[#9370DB] hover:to-[#432874]"
            >
              {isUpgrading ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Upgrading...
                </>
              ) : (
                "Upgrade Character"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* The clickable character card */}
      <div onClick={() => setDetailDialogOpen(true)}>
        <motion.div
          className="bg-[#1A1A2E] rounded-xl overflow-hidden border border-[#432874]/30 relative cursor-pointer"
          whileHover={{ y: -5, boxShadow: '0 5px 20px rgba(67, 40, 116, 0.3)' }}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* Activity Indicator */}
          {getActivityText()}
          
          <div className="p-4">
            <div className="flex items-center space-x-4">
              <div className="relative">
                <img
                  src={character.avatarUrl}
                  alt={character.name}
                  className="w-16 h-16 rounded-full object-cover border-2 border-[#432874]"
                />
                <div className="absolute -bottom-1 -right-1 bg-[#1A1A2E] rounded-full p-0.5 border border-[#432874]">
                  <div className="bg-[#432874] text-white text-xs w-5 h-5 rounded-full flex items-center justify-center font-bold">
                    {character.level}
                  </div>
                </div>
              </div>

              <div>
                <h3 className="font-cinzel font-bold text-lg text-[#C8B8DB]">
                  {character.name}
                </h3>
                <div className="flex items-center space-x-2 mt-1">
                  <Badge className={`font-normal ${getClassColor(character.class)}`}>
                    {character.class}
                  </Badge>
                  <span className="text-xs text-[#C8B8DB]/80">
                    Level {character.level || 1}
                  </span>
                </div>
              </div>
            </div>

            <div className="mt-4 grid grid-cols-4 gap-2 text-xs">
              <div className="flex items-center">
                <Swords className="h-3 w-3 mr-1 text-red-400" />
                <span>ATK: {character.attack}</span>
              </div>
              
              <div className="flex items-center">
                <Target className="h-3 w-3 mr-1 text-yellow-400" />
                <span>ACC: {character.accuracy}</span>
              </div>
              
              <div className="flex items-center">
                <Shield className="h-3 w-3 mr-1 text-blue-400" />
                <span>DEF: {character.defense}</span>
              </div>
              
              <div className="flex items-center">
                <Heart className="h-3 w-3 mr-1 text-red-500" />
                <span>VIT: {character.vitality}</span>
              </div>
              
              <div className="flex items-center">
                <Zap className="h-3 w-3 mr-1 text-cyan-400" />
                <span>SPD: {character.speed}</span>
              </div>
              
              <div className="flex items-center">
                <Brain className="h-3 w-3 mr-1 text-purple-400" />
                <span>FOC: {character.focus || 0}</span>
              </div>
              
              <div className="flex items-center">
                <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                <span>RES: {character.resilience || 0}</span>
              </div>
              {character.passiveSkills && Array.isArray(character.passiveSkills) && character.passiveSkills.length > 0 && (
                <div className="flex items-center">
                  <Check className="h-3 w-3 mr-1 text-green-400" />
                  <span>
                    {character.passiveSkills.length} passive{character.passiveSkills.length > 1 ? 's' : ''}
                  </span>
                </div>
              )}
            </div>

            {showDetailed && (
              <div className="mt-4 space-y-4">
                <div className="space-y-4">
                  {aura || equippedAura ? (
                    <>
                      {/* Equipped Aura Details */}
                      <div className="bg-[#432874]/20 rounded-lg p-3 mb-4">
                        <h4 className="font-semibold text-sm mb-2 text-[#00B9AE]">Aura Skills</h4>
                        <div className="space-y-2">
                          {auraSkills.length > 0 ? (
                            auraSkills.map((skill: any, index) => (
                              <div key={index} className="border-b border-[#432874]/30 pb-3 last:border-b-0 last:pb-0">
                                <div className="flex justify-between items-center">
                                  <div className="text-xs font-medium text-[#00B9AE]">{skill.name}</div>
                                  <div className="text-xs px-2 py-0.5 rounded-full bg-[#432874]/40 text-[#00B9AE]">
                                    Level {skill.level || 1}
                                  </div>
                                </div>

                                {/* Full skill logic */}
                                <div className="text-xs text-amber-300 mt-1 italic">
                                  "{skill.logic || generateSkillLogic(skill)}"
                                </div>
                                
                                <div className="text-xs text-[#C8B8DB]/80 mt-1">{skill.description}</div>
                                
                                {/* Enhanced skill details */}
                                <div className="mt-2 text-xs">
                                  {skill.damage && (
                                    <div className="flex items-center">
                                      <Swords className="h-3 w-3 mr-1 text-red-400" />
                                      <span className="text-[#C8B8DB]/80">
                                        Damage Multiplier: <span className="text-amber-400">{skill.damage}x</span> (Deals {skill.damage}x of Attack as damage)
                                      </span>
                                    </div>
                                  )}
                                  
                                  {skill.effect && (
                                    <div className="flex items-center mt-1">
                                      <Flame className="h-3 w-3 mr-1 text-orange-400" />
                                      <span className="text-[#C8B8DB]/80">
                                        Effect: <span className="text-purple-400">{skill.effect}</span>
                                        {skill.effectChance && <span className="ml-1 text-yellow-400">({skill.effectChance}% chance)</span>}
                                        {skill.effectStacks && <span className="ml-1 text-blue-400">({skill.effectStacks} stacks)</span>}
                                      </span>
                                    </div>
                                  )}
                                  
                                  {skill.healing && (
                                    <div className="flex items-center mt-1">
                                      <Heart className="h-3 w-3 mr-1 text-green-400" />
                                      <span className="text-[#C8B8DB]/80">
                                        Healing: <span className="text-green-400">{skill.healing}%</span> of max health
                                        {skill.healTargets && <span className="ml-1 text-blue-400">({skill.healTargets > 1 ? `${skill.healTargets} targets` : '1 target'})</span>}
                                      </span>
                                    </div>
                                  )}

                                  {skill.cooldown && (
                                    <div className="flex items-center mt-1">
                                      <Clock className="h-3 w-3 mr-1 text-blue-400" />
                                      <span className="text-[#C8B8DB]/80">
                                        Cooldown: <span className="text-blue-400">{skill.cooldown} turns</span>
                                      </span>
                                    </div>
                                  )}
                                </div>
                                
                                <div className="flex justify-between mt-2 text-xs text-[#C8B8DB]/60">
                                  <span>Type: 
                                    <span className={
                                      skill.type === "Ultimate" ? " text-amber-500" : 
                                      skill.type === "Advanced" ? " text-blue-500" : 
                                      " text-green-500"
                                    }>
                                      {" "}{skill.type}
                                    </span>
                                  </span>
                                  <span>Targets: {skill.targets || 1}</span>
                                </div>
                              </div>
                            ))
                          ) : (
                            <div className="text-xs text-[#C8B8DB]/60">No skills available</div>
                          )}
                        </div>
                      </div>

                      {/* Equipped Aura Stats */}
                      <div className="bg-[#432874]/20 rounded-lg p-3">
                        <h4 className="font-semibold text-sm mb-2">Equipped Aura</h4>
                        <div>
                          <div className="flex items-center mb-2">
                            <div className={`w-8 h-8 rounded-full flex items-center justify-center mr-2 ${getAuraElementClass((aura || equippedAura)?.element)}`}>
                              {getElementIcon((aura || equippedAura)?.element)}
                            </div>
                            <div>
                              <div className="text-[#00B9AE] text-sm">{(aura || equippedAura)?.name}</div>
                              <div className="flex items-center gap-2">
                                <div className="text-xs text-[#C8B8DB]/80">
                                  Level {(aura || equippedAura)?.level}  Tier {(aura || equippedAura)?.tier}
                                </div>
                                {(aura || equippedAura) && (
                                  <div className="px-2 py-0.5 rounded bg-[#00B9AE]/20 text-[#00B9AE] text-xs font-semibold">
                                    Total: +{calculateTotalStats(aura || equippedAura)}%
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                          
                          {/* Display Aura Skills */}
                          {(() => {
                            try {
                              const currentAura = aura || equippedAura;
                              if (!currentAura) return null;
                              
                              const skills = currentAura.skills ? 
                                (typeof currentAura.skills === 'string' ? 
                                  JSON.parse(currentAura.skills as string) : 
                                  currentAura.skills) : 
                                [];
                                
                              if (skills && skills.length > 0) {
                                return (
                                  <div className="mb-3 border-b border-[#432874]/30 pb-2">
                                    <div className="flex items-center mb-1 text-xs text-[#FF9D00]">
                                      <Sparkles className="h-3 w-3 mr-1" />
                                      <span>Aura Skills</span>
                                    </div>
                                    <div className="grid grid-cols-1 gap-1 text-xs">
                                      {skills.map((skill: any, index: number) => (
                                        <div key={index} className="flex items-start">
                                          <div className="text-[#C8B8DB]/60 mr-1"></div>
                                          <div className="flex-1 overflow-hidden">
                                            <span className="text-[#C8B8DB]">{skill.name}</span>
                                            {skill.description && (
                                              <div className="text-[#C8B8DB]/60 text-xs truncate">
                                                {skill.description}
                                              </div>
                                            )}
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                );
                              }
                            } catch (e) {
                              console.error('Failed to parse aura skills in character card view:', e);
                            }
                            return null;
                          })()}

                          {/* Total Stat Bonuses Header */}
                          <div className="flex items-center mb-1 text-xs text-[#FF9D00]">
                            <Info className="h-3 w-3 mr-1" />
                            <span>Total Stat Bonuses</span>
                          </div>

                          <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <Swords className="h-3 w-3 mr-1 text-red-400" />
                                <span className="text-xs">Attack</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.attack || null)}
                              </div>
                            </div>
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <Target className="h-3 w-3 mr-1 text-yellow-400" />
                                <span className="text-xs">Accuracy</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.accuracy || null)}
                              </div>
                            </div>
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <Shield className="h-3 w-3 mr-1 text-blue-400" />
                                <span className="text-xs">Defense</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.defense || null)}
                              </div>
                            </div>
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <Heart className="h-3 w-3 mr-1 text-red-500" />
                                <span className="text-xs">Vitality</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.vitality || null)}
                              </div>
                            </div>
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <Zap className="h-3 w-3 mr-1 text-cyan-400" />
                                <span className="text-xs">Speed</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.speed || null)}
                              </div>
                            </div>
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <Brain className="h-3 w-3 mr-1 text-purple-400" />
                                <span className="text-xs">Focus</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.focus || null)}
                              </div>
                            </div>
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                                <span className="text-xs">Resilience</span>
                              </div>
                              <div className="text-xs">
                                {getStatModifierText((aura || equippedAura)?.resilience || null)}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </>
                  ) : (
                    <div className="text-sm text-[#C8B8DB]/60">No Aura Equipped</div>
                  )}

                  {/* Character Passive Skills Section */}
                  {character.passiveSkills && Array.isArray(character.passiveSkills) && character.passiveSkills.length > 0 && (
                    <div className="bg-[#432874]/20 rounded-lg p-3 mt-4">
                      <h4 className="font-semibold text-sm mb-2 text-[#00B9AE]">Character Passive Skills</h4>
                      <div className="space-y-2">
                        {character.passiveSkills.map((passive: any, index) => (
                          <div key={index} className="border-b border-[#432874]/30 pb-2 last:border-b-0 last:pb-0">
                            <div className="text-xs font-medium text-[#00B9AE]">{passive.name}</div>
                            <div className="text-xs text-[#C8B8DB]/80">{passive.description}</div>
                            
                            <div className="mt-2 text-xs">
                              {passive.effect && (
                                <div className="flex items-center">
                                  <Star className="h-3 w-3 mr-1 text-amber-400" />
                                  <span className="text-[#C8B8DB]/80">
                                    Effect: <span className="text-purple-400">{passive.effect}</span>
                                  </span>
                                </div>
                              )}
                              
                              {passive.trigger && (
                                <div className="flex items-center mt-1">
                                  <Bolt className="h-3 w-3 mr-1 text-yellow-400" />
                                  <span className="text-[#C8B8DB]/80">
                                    Trigger: <span className="text-blue-400">{passive.trigger}</span>
                                  </span>
                                </div>
                              )}
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  <div className="mt-4 flex justify-end space-x-2">
                    {!character.isActive && (
                      <>
                        <Button 
                          variant="outline" 
                          className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
                          onClick={() => setEquipAuraDialogOpen(true)}
                        >
                          Equip Aura
                        </Button>
                        <Button className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]">
                          Assign Task
                        </Button>
                      </>
                    )}
                    {character.isActive && (
                      <div className="flex items-center text-[#DC143C]">
                        <Lock className="h-4 w-4 mr-1" />
                        <span>
                          Busy: {character.activityType} 
                          {character.activityEndTime && (
                            <span className="ml-1">
                              (<CountdownTimer endTime={character.activityEndTime} />)
                            </span>
                          )}
                        </span>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </div>
        </motion.div>
      </div>
    </>
  );
};

export { CharacterCard };

=== client/src/components/dungeons/new/BattleLog.tsx ===
import { useState, useEffect } from 'react';
import { 
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription,
  DialogFooter
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Progress } from '@/components/ui/progress';
import { Pause, Play, SkipForward, Swords, Heart, Shield, Zap } from 'lucide-react';
import { Badge } from '@/components/ui/badge';

/**
 * Types for battle system
 */
interface BattleUnit {
  id: string;
  name: string;
  hp: number;
  maxHp: number;
  attackMeter: number;
  stats: {
    attack: number;
    vitality: number;
    speed: number;
    [key: string]: number;
  };
  skills: {
    basic: BattleSkill;
    advanced: BattleSkill | null;
    ultimate: BattleSkill | null;
    [key: string]: BattleSkill | null;
  };
  statusEffects: StatusEffect[];
}

interface StatusEffect {
  name: string;
  type: string;
  value: number;
  duration: number;
  source?: string;
}

interface BattleSkill {
  name: string;
  damage: number;
  cooldown?: number;
  special?: string;
  aoe?: boolean;
}

interface BattleAction {
  actor: string;
  skill: string;
  target: string;
  damage: number;
  isCritical: boolean;
  healing?: boolean;
  message?: string;
  type?: string;
}

interface BattleEvent {
  type: string;
  timestamp?: number;
  
  // Round-specific properties
  number?: number;
  actions?: BattleAction[];
  remainingAllies?: number;
  remainingEnemies?: number;
  
  // Stage properties
  allies?: BattleUnit[];
  enemies?: BattleUnit[];
  currentStage?: number;
  totalStages?: number;
  message?: string;
  
  // System message
  system_message?: string;
  
  // Summary
  victory?: boolean;
  summary?: string;
  
  [key: string]: any;
}

interface BattleLogProps {
  isOpen: boolean;
  onClose: () => void;
  battleLog: BattleEvent[];
  runId: number;
  onCompleteDungeon: (runId: number) => void;
}

/**
 * BattleLog Component - Enhanced Version
 * Displays battle log events in a structured format with stage progression
 */
export default function BattleLog({ 
  isOpen, 
  onClose, 
  battleLog, 
  runId, 
  onCompleteDungeon 
}: BattleLogProps) {
  const [currentTab, setCurrentTab] = useState('battle');
  const [allies, setAllies] = useState<BattleUnit[]>([]);
  const [enemies, setEnemies] = useState<BattleUnit[]>([]);
  const [battleMessages, setBattleMessages] = useState<string[]>([]);
  const [currentRound, setCurrentRound] = useState(0);
  const [currentStage, setCurrentStage] = useState(1);
  const [totalStages, setTotalStages] = useState(1);
  const [stagesCompleted, setStagesCompleted] = useState(0);
  const [isVictory, setIsVictory] = useState<boolean | null>(null);
  const [currentView, setCurrentView] = useState<'start' | 'battle' | 'end'>('start');
  
  // Process battle log on initial load
  useEffect(() => {
    if (isOpen) {
      console.log('Processing battle log:', battleLog);
      
      // Reset state when opening a new battle log
      setCurrentStage(1);
      setStagesCompleted(0);
      setCurrentRound(0);
      setIsVictory(null);
      
      // Initialize messages
      const messages: string[] = [];
      
      // If there's no battle log data or it's empty, add a default message
      if (!battleLog || battleLog.length === 0) {
        messages.push('No battle data available. You can still complete this dungeon to free your characters.');
        setBattleMessages(messages);
        return;
      }
      
      console.log('Analyzing battle log for stage transitions');
      
      // Find the initial battle_start event to properly initialize character stats
      const battleStartEvent = battleLog.find(event => 
        event.type === 'battle_start' || 
        event.type === 'init' || 
        (event.type === 'stage_start' && event.currentStage === 1)
      );
      
      // Find the first stage event to correctly handle character HP
      if (battleStartEvent) {
        console.log('Found initial battle setup event:', battleStartEvent);
        
        // Set initial allies with proper HP
        if (battleStartEvent.allies && battleStartEvent.allies.length > 0) {
          // Make sure initial characters have their full HP
          const initialAllies = battleStartEvent.allies.map(ally => ({
            ...ally,
            hp: ally.maxHp // Start with full health
          }));
          setAllies(initialAllies);
          console.log(`Set ${initialAllies.length} initial allies with full HP`);
        }
        
        // Set initial enemies
        if (battleStartEvent.enemies && battleStartEvent.enemies.length > 0) {
          setEnemies(battleStartEvent.enemies);
          console.log(`Set ${battleStartEvent.enemies.length} initial enemies`);
        }
        
        // Set total stages if available
        if (battleStartEvent.totalStages) {
          setTotalStages(battleStartEvent.totalStages);
          console.log(`Set total stages to ${battleStartEvent.totalStages}`);
        }
      }
      
      // Look for stage_complete and stage_start events specifically
      const stageCompleteEvents = battleLog.filter(event => event.type === 'stage_complete');
      const stageStartEvents = battleLog.filter(event => event.type === 'stage_start');
      
      // Find the final battle result for proper stage counting
      const battleEndEvent = battleLog.find(event => event.type === 'battle_end');
      if (battleEndEvent) {
        if (battleEndEvent.completedStages) {
          setStagesCompleted(battleEndEvent.completedStages);
        }
        setIsVictory(!!battleEndEvent.victory);
      }
      
      console.log(`Found ${stageCompleteEvents.length} stage_complete events and ${stageStartEvents.length} stage_start events`);
      
      // Ensure battle log is processed in the right order
      messages.push('Battle begins! Your party enters the dungeon.');
      
      // Process each event in the log
      battleLog.forEach((event, index) => {
        // Extract battle configuration from battle_start event
        if (event.type === 'battle_start' || event.type === 'init') {
          if (event.allies) {
            setAllies(event.allies);
            console.log(`Set ${event.allies.length} initial allies`);
          }
          if (event.enemies) {
            setEnemies(event.enemies);
            console.log(`Set ${event.enemies.length} initial enemies`);
          }
          
          // Set total stages if available 
          if (event.totalStages) {
            setTotalStages(event.totalStages);
            console.log(`Set total stages to ${event.totalStages}`);
          }
          
          messages.push('Battle initialized.');
          messages.push(`Entering a dungeon with ${event.totalStages || 'multiple'} stages.`);
        }
        
        // Process round events
        if (event.type === 'round') {
          const roundNum = event.number || 0;
          setCurrentRound(roundNum);
          
          // Only add round begins message if this is a normal combat round (not a special transition round)
          if (event.actions && event.actions.length > 0) {
            messages.push(`Round ${roundNum} begins.`);
          }
          
          // Process actions in the round
          if (event.actions) {
            event.actions.forEach(action => {
              let actionText = '';
              
              if (action.healing) {
                actionText = `${action.actor} used ${action.skill} to heal ${action.target} for ${action.damage} HP`;
              } else {
                actionText = `${action.actor} used ${action.skill} on ${action.target} for ${action.damage} damage`;
                if (action.isCritical) actionText += ' (Critical hit!)';
              }
              
              if (action.message) {
                actionText = action.message;  // Override with custom message if provided
              }
              
              messages.push(actionText);
            });
          }
          
          // Update remaining combatants
          if (typeof event.remainingAllies === 'number' && typeof event.remainingEnemies === 'number') {
            if (event.remainingEnemies === 0) {
              messages.push(`All enemies defeated! End of round ${roundNum}.`);
            } else if (event.remainingAllies === 0) {
              messages.push(`Your party has been defeated! End of round ${roundNum}.`);
            } else {
              messages.push(`End of round ${roundNum}: ${event.remainingAllies} allies and ${event.remainingEnemies} enemies remaining.`);
            }
          }
        }
        
        // Process system messages
        if (event.type === 'system_message' && event.message) {
          messages.push(`System: ${event.message}`);
        }
        
        // Process stage transitions
        if (event.type === 'stage_complete') {
          console.log('Processing stage_complete event:', event);
          
          if (event.currentStage !== undefined) {
            setCurrentStage(event.currentStage);
            setStagesCompleted(event.currentStage);
            messages.push(`Stage ${event.currentStage} completed! ${event.message || ''}`);
          }
          
          // Update allies with the alive allies from this event
          if (event.aliveAllies && Array.isArray(event.aliveAllies)) {
            console.log(`Setting ${event.aliveAllies.length} alive allies from stage_complete event`);
            setAllies(event.aliveAllies);
          }
        }
        
        // Process new stage starting
        if (event.type === 'stage_start') {
          console.log('Processing stage_start event:', event);
          
          if (event.currentStage !== undefined) {
            setCurrentStage(event.currentStage);
            messages.push(`Stage ${event.currentStage} begins! ${event.message || ''}`);
          }
          
          // Update enemies with the new enemies for this stage
          if (event.enemies && Array.isArray(event.enemies)) {
            console.log(`Setting ${event.enemies.length} enemies from stage_start event`);
            setEnemies(event.enemies);
            messages.push(`New enemies appear for stage ${event.currentStage}!`);
          }
          
          // Mark start of a new stage in the battle log
          messages.push(`--- Stage ${event.currentStage || '?'} ---`);
        }
        
        // Process battle end
        if (event.type === 'battle_end') {
          setIsVictory(!!event.victory);
          
          // Set completed stages if provided
          if (event.completedStages !== undefined) {
            setStagesCompleted(event.completedStages);
          }
          
          if (event.summary) {
            messages.push(event.summary);
          } else {
            messages.push(event.victory 
              ? `Victory! Your party conquered ${event.completedStages || stagesCompleted}/${event.totalStages || totalStages} stages.` 
              : `Defeat! Your party was overwhelmed at stage ${event.currentStage || currentStage}.`);
          }
        }
      });
      
      // Update battle message state
      setBattleMessages(messages);
    }
  }, [isOpen, battleLog]);
  
  // Handle closing the dialog
  const handleClose = () => {
    // Reset all state
    setAllies([]);
    setEnemies([]);
    setBattleMessages([]);
    setCurrentRound(0);
    setCurrentStage(1);
    setTotalStages(1);
    setStagesCompleted(0);
    setIsVictory(null);
    onClose();
  };
  
  // Handle completing the dungeon
  const handleComplete = () => {
    onCompleteDungeon(runId);
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && handleClose()}>
      <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Swords className="h-5 w-5" />
              <span>
                {totalStages > 1 
                  ? `Battle Report - Stage ${currentStage}/${totalStages}` 
                  : 'Battle Report'} 
                {currentRound > 0 && ` (Round ${currentRound})`}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <Button 
                variant="outline" 
                size="sm" 
                className="h-8 px-2 py-0 text-xs"
                onClick={() => setCurrentStage(1)}
              >
                <Play className="h-3 w-3 mr-1" />
                Restart
              </Button>
            </div>
          </DialogTitle>
          <DialogDescription>
            {isVictory === true && `Your party completed ${stagesCompleted}/${totalStages} stages successfully!`}
            {isVictory === false && `Your party was defeated at stage ${currentStage}.`}
            {isVictory === null && `Multi-stage dungeon - battle through all ${totalStages} stages to complete`}
          </DialogDescription>
        </DialogHeader>
        
        {/* Stage Progress Bar */}
        {totalStages > 1 && (
          <div className="mb-4">
            <div className="flex justify-between text-xs mb-1">
              <span>Stage Progress</span>
              <span>{stagesCompleted}/{totalStages} Stages</span>
            </div>
            <div className="h-2 bg-[#1D1128] rounded-full overflow-hidden">
              <div 
                className="h-full bg-gradient-to-r from-[#7B4AE2] to-[#4AE292]"
                style={{ width: `${(stagesCompleted / totalStages) * 100}%` }}
              />
            </div>
          </div>
        )}
        
        <Tabs value={currentTab} onValueChange={setCurrentTab} className="flex-1 min-h-0 flex flex-col">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="battle">Battle Log</TabsTrigger>
            <TabsTrigger value="units">Combatants</TabsTrigger>
          </TabsList>
          
          {/* Battle Log Tab */}
          <TabsContent value="battle" className="flex-1 min-h-0 flex flex-col">
            <ScrollArea className="flex-1 rounded-md border border-[#432874] p-4 bg-[#251942]">
              {battleMessages.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-full text-[#C8B8DB] space-y-2 py-8">
                  <div className="text-center">
                    <p className="font-medium text-[#E5DBFF]">No battle data available</p>
                    <p className="text-sm mt-1">Click the "Complete Dungeon & Claim Rewards" button below to free your characters</p>
                  </div>
                </div>
              ) : (
                <div className="space-y-2">
                  {battleMessages.map((message, i) => (
                    <div 
                      key={i} 
                      className={`px-3 py-2 rounded-md ${
                        message.includes('Critical') ? 'bg-[#432874]' : 
                        message.includes('System:') ? 'bg-[#1D1128] border border-[#432874]' :
                        message.includes('Stage') && message.includes('begins') ? 'bg-[#432874] border border-[#7B4AE2] mt-4 font-medium' :
                        message.includes('Stage') && message.includes('completed') ? 'bg-[#1D4136] border border-[#4AE292] mt-2 font-medium' :
                        i % 2 === 0 ? 'bg-[#321959]/50' : 'bg-transparent'
                      }`}
                    >
                      {message}
                    </div>
                  ))}
                </div>
              )}
            </ScrollArea>
          </TabsContent>
          
          {/* Units Tab */}
          <TabsContent value="units" className="flex-1 min-h-0 flex flex-col">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Allies Column */}
              <div className="space-y-3">
                <h3 className="text-sm font-semibold text-[#E5DBFF]">Your Party</h3>
                {allies.length === 0 ? (
                  <div className="text-[#C8B8DB] text-center py-4">No ally data</div>
                ) : (
                  <div className="space-y-2">
                    {allies.map(unit => (
                      <div key={unit.id} className="bg-[#321959] rounded-md p-3 relative">
                        <div className="flex justify-between items-start mb-1">
                          <div className="font-medium text-[#E5DBFF]">{unit.name}</div>
                          <Badge variant={unit.hp <= 0 ? "destructive" : "outline"}>
                            {unit.hp <= 0 ? 'Defeated' : 'Active'}
                          </Badge>
                        </div>
                        
                        {/* Health Bar */}
                        <div className="space-y-1 mb-2">
                          <div className="flex justify-between text-xs">
                            <span>HP: {Math.max(0, unit.hp)} / {unit.maxHp}</span>
                            <span>{Math.floor((unit.hp / unit.maxHp) * 100)}%</span>
                          </div>
                          <Progress 
                            value={Math.max(0, (unit.hp / unit.maxHp) * 100)} 
                            className="h-2"
                          />
                        </div>
                        
                        {/* Stats */}
                        <div className="grid grid-cols-3 gap-2 text-xs text-[#C8B8DB]">
                          <div className="flex items-center gap-1">
                            <Swords className="h-3 w-3" /> ATK: {unit.stats.attack}
                          </div>
                          <div className="flex items-center gap-1">
                            <Heart className="h-3 w-3" /> VIT: {unit.stats.vitality}
                          </div>
                          <div className="flex items-center gap-1">
                            <Zap className="h-3 w-3" /> SPD: {unit.stats.speed}
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
              
              {/* Enemies Column */}
              <div className="space-y-3">
                <h3 className="text-sm font-semibold text-[#E5DBFF]">Enemies</h3>
                {enemies.length === 0 ? (
                  <div className="text-[#C8B8DB] text-center py-4">No enemy data</div>
                ) : (
                  <div className="space-y-2">
                    {enemies.map(unit => (
                      <div key={unit.id} className="bg-[#321959] rounded-md p-3 relative">
                        <div className="flex justify-between items-start mb-1">
                          <div className="font-medium text-[#E5DBFF]">{unit.name}</div>
                          <Badge variant={unit.hp <= 0 ? "destructive" : "outline"}>
                            {unit.hp <= 0 ? 'Defeated' : 'Active'}
                          </Badge>
                        </div>
                        
                        {/* Health Bar */}
                        <div className="space-y-1 mb-2">
                          <div className="flex justify-between text-xs">
                            <span>HP: {Math.max(0, unit.hp)} / {unit.maxHp}</span>
                            <span>{Math.floor((unit.hp / unit.maxHp) * 100)}%</span>
                          </div>
                          <Progress 
                            value={Math.max(0, (unit.hp / unit.maxHp) * 100)} 
                            className="h-2"
                          />
                        </div>
                        
                        {/* Stats */}
                        <div className="grid grid-cols-3 gap-2 text-xs text-[#C8B8DB]">
                          <div className="flex items-center gap-1">
                            <Swords className="h-3 w-3" /> ATK: {unit.stats.attack}
                          </div>
                          <div className="flex items-center gap-1">
                            <Heart className="h-3 w-3" /> VIT: {unit.stats.vitality}
                          </div>
                          <div className="flex items-center gap-1">
                            <Zap className="h-3 w-3" /> SPD: {unit.stats.speed}
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </TabsContent>
        </Tabs>
        
        <DialogFooter className="flex flex-col gap-2 sm:gap-0">
          {/* Always show a button to claim rewards/complete dungeon, 
              regardless of battle log state */}
          <Button 
            onClick={handleComplete} 
            className="w-full"
            variant="default"
            size="lg"
          >
            Complete Dungeon & Claim Rewards
          </Button>
          
          <div className="text-xs text-center text-muted-foreground mt-1">
            Completing this dungeon will free your characters for other tasks
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

=== client/src/components/dungeons/DungeonView.tsx ===
import { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { toast } from '@/hooks/use-toast';
import { useStore } from '@/lib/zustandStore';
import { format, formatDistanceToNow } from 'date-fns';

// UI Components
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Alert, AlertDescription } from "@/components/ui/alert";

// Icons
import {
  Compass,
  Skull,
  FileText,
  Hourglass,
  CheckCircle,
  XCircle,
  FlaskConical,
  Clock,
  ChevronRight,
  Swords,
  Loader2,
  Flame,
  User
} from 'lucide-react';

// Custom components
import BattleLog from './new/BattleLog';
// We'll handle character selection directly in this component for now
// import CharacterSelection from '../characters/CharacterSelection';

// Types for the dungeon system
interface DungeonType {
  id: number;
  name: string;
  description: string;
  baseDuration: number;
  difficulty: string;
  level: number;
  element: string;           // Frontend uses 'element'
  elementalType: string;     // Backend uses 'elementalType'
  rewards: any;
}

interface DungeonRun {
  id: number;
  userId: number;
  dungeonTypeId: number;
  dungeonName: string;
  dungeonLevel: number;
  characterIds: number[];
  startTime: string;
  endTime: string;
  completed: boolean;
  success: boolean;
  battleLog?: any[];
}

/**
 * Main component for dungeon system
 */
export default function DungeonView() {
  // State for dungeon selection and runs
  const [selectedDungeonId, setSelectedDungeonId] = useState<number | null>(null);
  const [selectedCharacters, setSelectedCharacters] = useState<number[]>([]);
  const [runDuration, setRunDuration] = useState<number>(1); // in minutes
  const [showBattleLog, setShowBattleLog] = useState<boolean>(false);
  const [activeBattleLog, setActiveBattleLog] = useState<any[]>([]);
  const [activeRunId, setActiveRunId] = useState<number | null>(null);
  const [filterCompleted, setFilterCompleted] = useState<boolean>(false);
  
  // Access global state for user settings
  const { selectedCharacterIds, setSelectedCharacterIds } = useStore();
  
  // Query client for cache management
  const queryClient = useQueryClient();
  
  // Fetch dungeon types
  const {
    data: dungeonTypes,
    isLoading: isLoadingDungeonTypes,
    error: dungeonTypesError
  } = useQuery({
    queryKey: ['/api/dungeons/types'],
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
  
  // Fetch active dungeon runs
  const {
    data: dungeonRuns,
    isLoading: isLoadingRuns,
    error: runsError
  } = useQuery({
    queryKey: ['/api/dungeons/runs'],
    refetchInterval: 10000, // Refresh every 10 seconds to update run progress
  });
  
  // Fetch available characters
  const {
    data: characters,
    isLoading: isLoadingCharacters,
    error: charactersError
  } = useQuery({
    queryKey: ['/api/characters'],
  });
  
  // Mutation to start a dungeon run
  const startDungeonMutation = useMutation({
    mutationFn: (data: any) => {
      return apiRequest('POST', '/api/dungeons/start', data);
    },
    onSuccess: () => {
      toast({
        title: 'Dungeon run started',
        description: 'Your party has entered the dungeon!',
      });
      queryClient.invalidateQueries({ queryKey: ['/api/dungeons/runs'] });
    },
    onError: (error: any) => {
      toast({
        title: 'Failed to start dungeon run',
        description: error.message || 'An error occurred',
        variant: 'destructive',
      });
    },
  });
  
  // Mutation to complete a dungeon run
  const completeDungeonMutation = useMutation({
    mutationFn: (runId: number) => {
      return apiRequest('POST', `/api/dungeons/complete/${runId}`);
    },
    onSuccess: (data: any) => {
      toast({
        title: data?.success ? 'Dungeon completed successfully!' : 'Dungeon run failed',
        description: data?.success ? 'Your party has conquered the dungeon!' : 'Your party was defeated!',
      });
      queryClient.invalidateQueries({ queryKey: ['/api/dungeons/runs'] });
      setShowBattleLog(false);
    },
    onError: (error: any) => {
      toast({
        title: 'Failed to complete dungeon run',
        description: error.message || 'An error occurred',
        variant: 'destructive',
      });
    },
  });
  
  // Effect to initialize selectedCharacters from global state
  useEffect(() => {
    if (selectedCharacterIds && selectedCharacterIds.length > 0) {
      setSelectedCharacters(selectedCharacterIds);
    }
  }, [selectedCharacterIds]);
  
  // Function to handle character selection
  const handleCharacterSelection = (characterIds: number[]) => {
    setSelectedCharacters(characterIds);
    setSelectedCharacterIds(characterIds);
  };
  
  // Function to start a dungeon run
  const handleStartDungeon = () => {
    if (!selectedDungeonId) {
      toast({
        title: 'No dungeon selected',
        description: 'Please select a dungeon to enter',
        variant: 'destructive',
      });
      return;
    }
    
    if (selectedCharacters.length === 0) {
      toast({
        title: 'No characters selected',
        description: 'Please select at least one character for your party',
        variant: 'destructive',
      });
      return;
    }
    
    const selectedDungeon = (dungeonTypes as DungeonType[])?.find((d: DungeonType) => d.id === selectedDungeonId);
    if (!selectedDungeon) return;
    
    // Calculate end time based on dungeon duration
    const startTime = new Date();
    const endTime = new Date(startTime.getTime() + (runDuration * 60 * 1000));
    
    startDungeonMutation.mutate({
      dungeonTypeId: selectedDungeonId,
      dungeonName: selectedDungeon.name,
      dungeonLevel: selectedDungeon.level || 1,  // Ensure we have a valid level
      elementalType: selectedDungeon.elementalType || selectedDungeon.element || 'neutral', // Prefer elementalType, fallback to element
      characterIds: selectedCharacters,
      startTime: startTime.toISOString(),
      endTime: endTime.toISOString(),
    });
  };
  
  // Function to view battle log for a run
  const handleViewBattleLog = async (run: DungeonRun) => {
    // If the run is not yet completed but the endTime has passed, 
    // we should fetch the battle log or generate it
    if (!run.completed && new Date(run.endTime) <= new Date()) {
      try {
        // First try to fetch the battle log if it exists
        if (!run.battleLog) {
          const response = await fetch(`/api/dungeons/runs/${run.id}/battlelog`);
          if (response.ok) {
            const data = await response.json();
            if (data && Array.isArray(data)) {
              setActiveBattleLog(data);
            } else {
              // If no battle log exists, we'll just show an empty array
              // The BattleLog component should handle this gracefully
              setActiveBattleLog([]);
            }
          } else {
            setActiveBattleLog([]);
          }
        } else {
          setActiveBattleLog(run.battleLog);
        }
      } catch (error) {
        console.error("Error fetching battle log:", error);
        toast({
          title: 'Error fetching battle log',
          description: 'There was a problem retrieving the battle data',
          variant: 'destructive',
        });
        setActiveBattleLog([]);
      }
    } else {
      // For already completed runs, just use the battleLog from the run
      setActiveBattleLog(run.battleLog || []);
    }
    
    setActiveRunId(run.id);
    setShowBattleLog(true);
  };
  
  // Function to handle completing a dungeon after viewing battle log
  const handleCompleteDungeon = (runId: number) => {
    completeDungeonMutation.mutate(runId);
  };
  
  // Function to calculate progress percentage of an active run
  const calculateProgress = (run: DungeonRun): number => {
    const now = new Date().getTime();
    const start = new Date(run.startTime).getTime();
    const end = new Date(run.endTime).getTime();
    
    if (now >= end) return 100;
    const progress = ((now - start) / (end - start)) * 100;
    return Math.min(Math.max(0, progress), 100);
  };
  
  // Function to calculate remaining time text
  const getRemainingTimeText = (run: DungeonRun): string => {
    const endTime = new Date(run.endTime);
    const now = new Date();
    
    if (now >= endTime) {
      return 'Complete - Collect rewards';
    }
    
    return formatDistanceToNow(endTime, { addSuffix: true });
  };
  
  // Filter dungeon runs based on completion status
  const filteredRuns = dungeonRuns 
    ? (dungeonRuns as DungeonRun[]).filter((run: DungeonRun) => filterCompleted ? run.completed : true)
    : [];
  
  // Fix dungeon display issues: Show any run that's not completed
  const activeRuns = filteredRuns.filter((run: DungeonRun) => {
    // Convert endTime to Date object for proper comparison
    const endTimeDate = new Date(run.endTime);
    
    // Debug information (will remove once fixed)
    console.log(`Run ${run.id} - completed: ${run.completed}, endTime: ${endTimeDate}, now: ${new Date()}`);
    
    // Any run that is not marked as completed should be shown in active runs
    // regardless of end time to match dashboard behavior
    return !run.completed;
  });
  
  const completedRuns = filteredRuns.filter((run: DungeonRun) => 
    // Only show runs explicitly marked as completed
    run.completed === true
  );
  
  // Loading states
  const isLoading = isLoadingDungeonTypes || isLoadingRuns;
  const startingDungeon = startDungeonMutation.isPending;
  const completingDungeon = completeDungeonMutation.isPending;
  
  return (
    <div className="container mx-auto py-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Dungeon Selection Panel */}
        <Card className="md:col-span-1">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Compass className="h-5 w-5" />
              <span>Dungeon Selection</span>
            </CardTitle>
            <CardDescription>
              Choose a dungeon and select your party members
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {isLoadingDungeonTypes ? (
              <div className="space-y-2">
                <Skeleton className="h-10 w-full" />
                <Skeleton className="h-40 w-full" />
                <Skeleton className="h-10 w-full" />
              </div>
            ) : dungeonTypesError ? (
              <Alert variant="destructive">
                <AlertDescription>
                  Failed to load dungeons. Please try refreshing.
                </AlertDescription>
              </Alert>
            ) : (
              <>
                <div className="space-y-2">
                  <Label htmlFor="dungeon-select">Select Dungeon</Label>
                  <Select
                    value={selectedDungeonId?.toString() || ""}
                    onValueChange={(value) => setSelectedDungeonId(parseInt(value))}
                  >
                    <SelectTrigger id="dungeon-select">
                      <SelectValue placeholder="Select a dungeon" />
                    </SelectTrigger>
                    <SelectContent>
                      {(dungeonTypes as DungeonType[])?.map((dungeon: DungeonType) => (
                        <SelectItem key={dungeon.id} value={dungeon.id.toString()}>
                          {dungeon.name} (Lvl {dungeon.level})
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                
                {selectedDungeonId && (
                  <div className="bg-[#251942] rounded-md p-3 text-sm">
                    {(dungeonTypes as DungeonType[])?.find((d: DungeonType) => d.id === selectedDungeonId)?.description || 'No description available.'}
                    
                    <div className="mt-3 flex flex-wrap gap-2">
                      <Badge variant="outline" className="bg-[#1D1128]">
                        <Flame className="w-3 h-3 mr-1" />
                        {(dungeonTypes as DungeonType[])?.find((d: DungeonType) => d.id === selectedDungeonId)?.element || 'Unknown'}
                      </Badge>
                      <Badge variant="outline" className="bg-[#1D1128]">
                        <Skull className="w-3 h-3 mr-1" />
                        {(dungeonTypes as DungeonType[])?.find((d: DungeonType) => d.id === selectedDungeonId)?.difficulty || 'Normal'}
                      </Badge>
                    </div>
                  </div>
                )}
                
                <div className="space-y-2">
                  <Label htmlFor="time-select">Run Time (for testing)</Label>
                  <Select
                    value={runDuration.toString()}
                    onValueChange={(value) => setRunDuration(parseInt(value))}
                  >
                    <SelectTrigger id="time-select">
                      <SelectValue placeholder="Select duration" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="1">1 minute</SelectItem>
                      <SelectItem value="2">2 minutes</SelectItem>
                      <SelectItem value="5">5 minutes</SelectItem>
                      <SelectItem value="10">10 minutes</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div className="space-y-2">
                  <Label>Select Characters</Label>
                  {isLoadingCharacters ? (
                    <div className="space-y-2">
                      <Skeleton className="h-10 w-full" />
                      <Skeleton className="h-20 w-full" />
                    </div>
                  ) : charactersError ? (
                    <Alert variant="destructive">
                      <AlertDescription>
                        Failed to load characters. Please try refreshing.
                      </AlertDescription>
                    </Alert>
                  ) : (characters as any[])?.length === 0 ? (
                    <div className="text-center py-4 text-muted-foreground">
                      <p>No characters available</p>
                      <p className="text-sm mt-1">Create characters in the Character section</p>
                    </div>
                  ) : (
                    <div className="grid grid-cols-4 gap-2">
                      {(characters as any[])?.map((character: any) => (
                        <Button
                          key={character.id}
                          variant={selectedCharacters.includes(character.id) ? "default" : "outline"}
                          size="sm"
                          className="p-2 h-auto flex flex-col justify-center items-center"
                          onClick={() => {
                            if (selectedCharacters.includes(character.id)) {
                              handleCharacterSelection(selectedCharacters.filter(cid => cid !== character.id));
                            } else if (selectedCharacters.length < 4) {
                              handleCharacterSelection([...selectedCharacters, character.id]);
                            }
                          }}
                        >
                          <div className="w-7 h-7 rounded-full bg-[#432874] mb-1 flex items-center justify-center overflow-hidden">
                            {character.avatarUrl ? (
                              <img src={character.avatarUrl} alt={character.name} className="w-full h-full object-cover" />
                            ) : (
                              <User className="w-4 h-4" />
                            )}
                          </div>
                          <span className="text-xs line-clamp-1">{character.name}</span>
                        </Button>
                      ))}
                    </div>
                  )}
                  <p className="text-xs text-muted-foreground mt-1">
                    {selectedCharacters.length}/4 characters selected
                  </p>
                </div>
                
                <Button
                  onClick={handleStartDungeon}
                  disabled={!selectedDungeonId || selectedCharacters.length === 0 || startingDungeon}
                  className="w-full"
                >
                  {startingDungeon ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Starting...
                    </>
                  ) : (
                    <>
                      <Swords className="mr-2 h-4 w-4" />
                      Enter Dungeon
                    </>
                  )}
                </Button>
              </>
            )}
          </CardContent>
        </Card>
        
        {/* Active Dungeon Runs */}
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Hourglass className="h-5 w-5" />
              <span>Active Dungeon Runs</span>
            </CardTitle>
            <CardDescription>
              Your party's ongoing adventures in the dungeons
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {isLoadingRuns ? (
              <div className="space-y-2">
                <Skeleton className="h-20 w-full" />
                <Skeleton className="h-20 w-full" />
              </div>
            ) : runsError ? (
              <Alert variant="destructive">
                <AlertDescription>
                  Failed to load dungeon runs. Please try refreshing.
                </AlertDescription>
              </Alert>
            ) : activeRuns.length === 0 ? (
              <div className="text-center py-10 text-muted-foreground">
                <Compass className="h-8 w-8 mx-auto mb-3 opacity-50" />
                <p>No active dungeon runs</p>
                <p className="text-sm mt-1">Select a dungeon and start a new adventure</p>
              </div>
            ) : (
              <div className="space-y-3">
                {activeRuns.map((run: DungeonRun) => {
                  const progress = calculateProgress(run);
                  return (
                    <div 
                      key={run.id} 
                      className="bg-[#251942] rounded-lg p-4 relative"
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div>
                          <h4 className="font-semibold text-[#E5DBFF]">{run.dungeonName}</h4>
                          <p className="text-sm text-[#C8B8DB]">Level {run.dungeonLevel}</p>
                        </div>
                        <Badge variant={progress >= 100 ? "default" : "outline"}>
                          {progress >= 100 ? 'Complete' : 'In Progress'}
                        </Badge>
                      </div>
                      
                      <Progress value={progress} className="h-2 mb-3" />
                      
                      <div className="flex justify-between items-center text-xs text-[#C8B8DB]">
                        <div className="flex items-center">
                          <Clock className="h-3 w-3 mr-1" />
                          <span>{getRemainingTimeText(run)}</span>
                        </div>
                        
                        <div className="flex items-center">
                          <span>Characters: {run.characterIds.length}</span>
                        </div>
                      </div>
                      
                      <Button
                        variant="default"
                        size="sm"
                        className="mt-3 w-full"
                        onClick={() => handleViewBattleLog(run)}
                      >
                        <FileText className="h-4 w-4 mr-2" />
                        View Battle Report
                      </Button>
                    </div>
                  );
                })}
              </div>
            )}
          </CardContent>
        </Card>
      </div>
      
      {/* Completed Dungeon Runs */}
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle className="flex items-center gap-2">
              <FileText className="h-5 w-5" />
              <span>Dungeon History</span>
            </CardTitle>
            <Button 
              variant="outline" 
              size="sm"
              onClick={() => setFilterCompleted(!filterCompleted)}
            >
              {filterCompleted ? 'Show All' : 'Only Completed'}
            </Button>
          </div>
          <CardDescription>
            Records of your past dungeon expeditions
          </CardDescription>
        </CardHeader>
        <CardContent>
          {isLoadingRuns ? (
            <div className="space-y-2">
              <Skeleton className="h-10 w-full" />
              <Skeleton className="h-10 w-full" />
            </div>
          ) : completedRuns.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <FileText className="h-8 w-8 mx-auto mb-3 opacity-50" />
              <p>No dungeon history yet</p>
              <p className="text-sm mt-1">Complete some dungeons to see your records</p>
            </div>
          ) : (
            <Accordion type="multiple" className="space-y-2">
              {completedRuns.map((run: DungeonRun) => (
                <AccordionItem 
                  key={run.id} 
                  value={run.id.toString()}
                  className="border border-[#432874] rounded-md overflow-hidden"
                >
                  <AccordionTrigger className="px-4 py-2 hover:bg-[#432874]/20">
                    <div className="flex items-center justify-between w-full pr-4">
                      <div className="flex items-center gap-2">
                        <Badge variant={run.success ? "default" : "destructive"} className="h-6">
                          {run.success ? (
                            <CheckCircle className="h-3 w-3 mr-1" />
                          ) : (
                            <XCircle className="h-3 w-3 mr-1" />
                          )}
                          <span>{run.success ? 'Success' : 'Failed'}</span>
                        </Badge>
                        <span className="font-medium">{run.dungeonName}</span>
                      </div>
                      <div className="text-sm text-muted-foreground">
                        {format(new Date(run.endTime), 'PPp')}
                      </div>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent className="px-4 py-2 bg-[#251942]">
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <div className="space-y-1">
                        <p className="text-sm text-[#C8B8DB]">Dungeon Level</p>
                        <p className="font-medium">{run.dungeonLevel}</p>
                      </div>
                      <div className="space-y-1">
                        <p className="text-sm text-[#C8B8DB]">Characters</p>
                        <p className="font-medium">{run.characterIds.length} adventurers</p>
                      </div>
                      <div className="space-y-1">
                        <p className="text-sm text-[#C8B8DB]">Duration</p>
                        <p className="font-medium">
                          {formatDistanceToNow(new Date(run.startTime), { 
                            addSuffix: false 
                          })}
                        </p>
                      </div>
                    </div>
                    
                    <div className="mt-4 flex justify-end">
                      <Button 
                        size="sm"
                        onClick={() => handleViewBattleLog(run)}
                      >
                        <FileText className="h-4 w-4 mr-2" />
                        View Battle Report
                      </Button>
                    </div>
                  </AccordionContent>
                </AccordionItem>
              ))}
            </Accordion>
          )}
        </CardContent>
      </Card>
      
      {/* Battle Log Dialog */}
      {showBattleLog && (
        <BattleLog
          isOpen={showBattleLog}
          onClose={() => setShowBattleLog(false)}
          battleLog={activeBattleLog}
          runId={activeRunId}
          onCompleteDungeon={handleCompleteDungeon}
        />
      )}
    </div>
  );
}


=== client/src/components/farming/FarmingView.tsx ===
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import { useGameStore } from '@/lib/zustandStore';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger,
  DialogFooter,
  DialogDescription
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  Plus, 
  Lock, 
  Clock, 
  CheckCircle2, 
  UserX, 
  Gem, 
  Timer, 
  HelpCircle,
  ArrowUp
} from 'lucide-react';
import CountdownTimer from '../common/CountdownTimer';
import type { Character, FarmingTask } from '@shared/schema';

// Available farming resources
const farmingResources = [
  { 
    id: 1, 
    name: "Celestial Ore", 
    description: "A rare material used in forging and crafting high-level Auras.",
    image: "https://images.unsplash.com/photo-1518709594023-6ebd2b555f4e?w=150&h=150&fit=crop",
    type: "rare",
    baseTime: 60 * 45 // 45 minutes in seconds
  },
  { 
    id: 2, 
    name: "Moonsilver", 
    description: "A shimmering metallic material that enhances the power of water Auras.",
    image: "https://images.unsplash.com/photo-1505356822725-08ad25f3ffe4?w=150&h=150&fit=crop",
    type: "common",
    baseTime: 60 * 30 // 30 minutes in seconds
  },
  { 
    id: 3, 
    name: "Dragon Scale", 
    description: "Tough scales from fallen dragons, essential for crafting fire Auras.",
    image: "https://images.unsplash.com/photo-1563589425059-d2524a5a1dfc?w=150&h=150&fit=crop",
    type: "rare",
    baseTime: 60 * 45 // 45 minutes in seconds
  },
  { 
    id: 4, 
    name: "Phoenix Feather", 
    description: "Brilliant feathers from phoenixes, used in creating powerful Auras.",
    image: "https://images.unsplash.com/photo-1592364395653-83e648b22fa4?w=150&h=150&fit=crop",
    type: "epic",
    baseTime: 60 * 60 // 60 minutes in seconds
  }
];

const FarmingView = () => {
  const { characters, fetchFarmingTasks } = useGameStore();
  const { toast } = useToast();
  const [selectedSlot, setSelectedSlot] = useState<number | null>(null);
  const [selectedResource, setSelectedResource] = useState<any>(null);
  const [selectedCharacter, setSelectedCharacter] = useState<number | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [upgradeSlot, setUpgradeSlot] = useState<number | null>(null);
  // State for tracking which skill path is selected (1: quantity path, 2: quality/speed path)
  const [selectedUpgradePath, setSelectedUpgradePath] = useState<number>(1);
  
  // Get all building upgrades for current user
  const { data: userBuildingUpgrades = { farmSlots: [], forgeSlots: [], marketUpgrades: [], buildings: [] } } = useQuery<any>({
    queryKey: ['/api/buildings/upgrades'],
  });
  
  // Get farming tasks
  const { data: farmingTasks = [], isLoading, refetch: refetchFarmingTasks } = useQuery<FarmingTask[]>({ 
    queryKey: ['/api/farming/tasks'],
    refetchInterval: 5000, // Refresh even more frequently (every 5 seconds)
    staleTime: 1000, // Mark data as stale after 1 second
  });
  
  // Get truly available characters (not assigned to any active tasks)
  const availableCharacters = characters.filter(char => {
    // Check if character is assigned to any active forging task
    const isInForgingTask = useGameStore.getState().forgingTasks.some(task => 
      !task.completed && task.characterId === char.id
    );
    
    // Check if character is assigned to any active farming task
    const isInFarmingTask = farmingTasks.some(task => 
      !task.completed && task.characterId === char.id
    );
    
    // Check if character is in a dungeon run
    const isInDungeonRun = useGameStore.getState().dungeonRuns.some(run => 
      !run.completed && run.characterIds && run.characterIds.includes(char.id)
    );
    
    // Character is available if not assigned to any active task
    return !isInForgingTask && !isInFarmingTask && !isInDungeonRun;
  });
  
  // Calculate available farming slots based on townhall level (for MVP, we'll use 3)
  const maxFarmingSlots = 3;
  
  // Create slots array
  const farmingSlots = Array.from({ length: maxFarmingSlots }, (_, index) => {
    const slot = index + 1;
    const task = farmingTasks.find(t => t.slotIndex === slot && !t.completed);
    return { slot, task };
  });

  const startFarmingTask = async () => {
    if (!selectedResource || !selectedCharacter || selectedSlot === null) {
      toast({
        title: "Incomplete Selection",
        description: "Please select a resource, character, and farming slot.",
        variant: "destructive"
      });
      return;
    }
    
    setIsSubmitting(true);
    
    try {
      // Calculate farming duration (based on character level and resource type)
      const character = characters.find(c => c.id === selectedCharacter);
      
      if (!character) {
        throw new Error("Selected character not found");
      }
      
      // Adjust time based on character's level (higher level = faster farming)
      const levelMultiplier = Math.max(0.6, 1 - (character.level || 1) * 0.02); // 2% reduction per level, min 40% reduction
      const farmingDuration = selectedResource.baseTime * levelMultiplier;
      
      // Calculate end time
      const now = new Date();
      const endTime = new Date(now.getTime() + farmingDuration * 1000);
      
      console.log('Sending farming request with endTime:', endTime.toISOString());
      
      // Send request to start farming task
      const response = await apiRequest('POST', '/api/farming/tasks', {
        characterId: selectedCharacter,
        resourceName: selectedResource.name,
        endTime: endTime.toISOString(), // Convert Date to ISO string
        slotIndex: selectedSlot
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to start farming task");
      }
      
      // Show success message
      toast({
        title: "Farming Started",
        description: `${character.name} is now farming ${selectedResource.name}.`,
      });
      
      // Reset selections
      setSelectedSlot(null);
      setSelectedResource(null);
      setSelectedCharacter(null);
      
      // Refresh farming tasks immediately
      fetchFarmingTasks();
      // Also update the query cache immediately
      refetchFarmingTasks();
    } catch (error: any) {
      console.error('Error starting farming task:', error);
      toast({
        title: "Error",
        description: error.message || "Failed to start farming task.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleCollectResources = async (taskId: number) => {
    setIsSubmitting(true);
    try {
      const response = await apiRequest('POST', `/api/farming/complete/${taskId}`, undefined);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to collect resources");
      }
      
      const data = await response.json();
      
      toast({
        title: "Resources Collected",
        description: `Gained ${data.amount} ${data.resource}.`,
      });
      
      // Refresh farming tasks immediately
      fetchFarmingTasks();
      // Also update the query cache immediately
      refetchFarmingTasks();
    } catch (error) {
      console.error('Error collecting resources:', error);
      toast({
        title: "Error",
        description: "Failed to collect resources.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const getTypeStyles = (type: string) => {
    switch (type) {
      case 'common':
        return 'bg-slate-700/30 text-slate-300 border-slate-600/30';
      case 'rare':
        return 'bg-blue-700/30 text-blue-300 border-blue-600/30';
      case 'epic':
        return 'bg-purple-700/30 text-purple-300 border-purple-600/30';
      case 'legendary':
        return 'bg-yellow-700/30 text-yellow-300 border-yellow-600/30';
      default:
        return 'bg-slate-700/30 text-slate-300 border-slate-600/30';
    }
  };
  
  // Calculate bonuses for a given farming slot based on its upgrades
  const calculateSlotBonuses = (slotIndex: number) => {
    // Find the upgrade for this slot
    const slotUpgrades = userBuildingUpgrades?.farmSlots || [];
    const slotUpgrade = slotUpgrades.find((upgrade: any) => upgrade.slotId === slotIndex + 1);
    
    // Default values if no upgrades found
    const defaultBonuses = {
      level: 1,
      path: "Not Upgraded",
      yieldBonus: 0,
      speedBonus: 0,
      qualityBonus: 0,
      bonusChance: 0
    };
    
    if (!slotUpgrade) return defaultBonuses;
    
    // Get upgrade level and path
    const level = slotUpgrade.level || 1;
    const path = slotUpgrade.pathName || "Not Upgraded";
    
    // Calculate different bonuses based on the path and level
    const isBountifulPath = path === "Bountiful Harvest";
    
    // Base bonuses
    const baseYieldBonus = isBountifulPath ? level * 5 : level * 2;
    const baseSpeedBonus = isBountifulPath ? level * 2 : level * 4;
    const baseQualityBonus = isBountifulPath ? level * 1 : level * 3;
    const baseBonusChance = isBountifulPath ? level * 3 : level * 1;
    
    // Enhanced bonuses based on path specialization
    const yieldBonus = isBountifulPath ? baseYieldBonus + level * 3 : baseYieldBonus;
    const speedBonus = !isBountifulPath ? baseSpeedBonus + level * 2 : baseSpeedBonus;
    const qualityBonus = !isBountifulPath ? baseQualityBonus + level * 2 : baseQualityBonus;
    const bonusChance = isBountifulPath ? baseBonusChance + level * 2 : baseBonusChance;
    
    return {
      level,
      path,
      yieldBonus,
      speedBonus,
      qualityBonus,
      bonusChance
    };
  };

  const handleUpgradeSlot = async (slot: number) => {
    setIsSubmitting(true);
    try {
      // In a real implementation, this would be an API call to upgrade the slot
      const response = await apiRequest('POST', '/api/buildings/upgrade', {
        buildingType: 'farmingSlot',
        slotId: slot,
        upgradePath: selectedUpgradePath,
        pathName: selectedUpgradePath === 1 ? 'Bountiful Harvest' : 'Swift Cultivation'
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to upgrade farming slot");
      }
      
      toast({
        title: "Slot Upgraded",
        description: `Farming Slot ${slot} has been upgraded with ${selectedUpgradePath === 1 ? 'Bountiful Harvest' : 'Swift Cultivation'} path.`,
      });
      
      // Close the upgrade dialog
      setUpgradeSlot(null);
      // Reset selected path for next time
      setSelectedUpgradePath(1);
      
      // Refresh data to show the upgraded slot
      fetchFarmingTasks();
      refetchFarmingTasks();
    } catch (error: any) {
      console.error('Error upgrading farming slot:', error);
      toast({
        title: "Upgrade Failed",
        description: error.message || "Could not upgrade the farming slot.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Render content based on loading state and prepare main UI
  const renderMainContent = () => {
    if (isLoading) {
      return (
        <div className="flex justify-center items-center h-64">
          <div className="text-[#FF9D00] text-xl">Loading farming data...</div>
        </div>
      );
    }

    return (
      <>
        <div className="mb-6">
          <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Farming</h1>
          <p className="text-[#C8B8DB]/80">
            Gather valuable materials for crafting Auras and upgrading your characters.
          </p>
        </div>
        
        {/* Farming Slots */}
        <div className="grid gap-4 md:grid-cols-3 mb-8">
          {farmingSlots.map(({ slot, task }) => {
            // Find character if a task is active
            const character = task ? characters.find(c => c.id === task.characterId) : null;
            
            return (
              <motion.div
                key={`slot-${slot}`}
                whileHover={{ scale: 1.02 }}
                className={`bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden ${!task && 'cursor-pointer'}`}
                onClick={() => !task && setSelectedSlot(slot)}
              >
                {task ? (
                  // Active farming task
                  <div>
                    <div className="p-4">
                      <div className="flex justify-between items-start mb-3">
                        <div>
                          <div className="flex items-center gap-2">
                            <h3 className="font-cinzel font-bold text-lg text-[#C8B8DB]">
                              Farming Slot {slot}
                            </h3>
                            <Button 
                              variant="outline" 
                              size="sm" 
                              className="h-6 px-2 py-0 text-xs bg-[#228B22]/10 border-[#228B22]/30 text-[#228B22] hover:bg-[#228B22]/20"
                              onClick={(e) => {
                                e.stopPropagation();
                                setUpgradeSlot(slot);
                              }}
                            >
                              Upgrade
                            </Button>
                          </div>
                          <Badge className="bg-[#228B22]/20 text-[#228B22] border-[#228B22]/30">
                            Active
                          </Badge>
                        </div>
                        {/* Countdown timer */}
                        <div className="text-sm text-[#C8B8DB]/70 flex items-center">
                          <Clock className="h-4 w-4 mr-1" />
                          <CountdownTimer 
                            endTime={task.endTime} 
                            onComplete={() => task && handleCollectResources(task.id)}
                          />
                        </div>
                      </div>
                      
                      {/* Farm Plot Bonuses */}
                      {(() => {
                        const bonuses = calculateSlotBonuses(slot - 1);
                        
                        // Only show if there are any bonuses (slot level > 1)
                        if (bonuses.level > 1) {
                          const isBountifulPath = bonuses.path === 'Bountiful Harvest';
                          return (
                            <div className={`mb-3 p-2 rounded-md text-xs ${
                              isBountifulPath ? 'bg-[#228B22]/10 border border-[#228B22]/20' : 'bg-[#00B9AE]/10 border border-[#00B9AE]/20'
                            }`}>
                              <div className="flex justify-between items-center mb-1">
                                <div className="flex items-center">
                                  {isBountifulPath ? (
                                    <Gem className="h-3 w-3 mr-1 text-[#228B22]" />
                                  ) : (
                                    <Timer className="h-3 w-3 mr-1 text-[#00B9AE]" />
                                  )}
                                  <span className={isBountifulPath ? 'text-[#228B22]' : 'text-[#00B9AE]'}>
                                    {bonuses.path} (Level {bonuses.level})
                                  </span>
                                </div>
                              </div>
                              <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[#C8B8DB]/80">
                                <div className="flex items-center">
                                  <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                  <span>+{bonuses.yieldBonus}% Yield</span>
                                </div>
                                <div className="flex items-center">
                                  <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                  <span>+{bonuses.speedBonus}% Speed</span>
                                </div>
                                <div className="flex items-center">
                                  <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                  <span>+{bonuses.qualityBonus}% Quality</span>
                                </div>
                                <div className="flex items-center">
                                  <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                  <span>+{bonuses.bonusChance}% Bonus</span>
                                </div>
                              </div>
                            </div>
                          );
                        }
                        return null;
                      })()}
                      
                      {/* Resource and character info */}
                      <div className="flex justify-between items-center mb-4">
                        <div className="flex items-center">
                          <img
                            src={farmingResources.find(r => r.name === task.resourceName)?.image || "https://via.placeholder.com/40"}
                            alt={task.resourceName}
                            className="w-12 h-12 rounded-full object-cover border-2 border-[#228B22]/50"
                          />
                          <div className="ml-2">
                            <div className="text-sm font-semibold">{task.resourceName}</div>
                            <div className="text-xs text-[#C8B8DB]/70">
                              {farmingResources.find(r => r.name === task.resourceName)?.type || "common"}
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex flex-col items-end">
                          <div className="text-sm font-semibold">{character?.name || "Character"}</div>
                          <div className="text-xs text-[#C8B8DB]/70">Level {character?.level || "?"}</div>
                        </div>
                      </div>
                      
                      {/* Collect button (only shown if task is complete) */}
                      {new Date(task.endTime) <= new Date() && (
                        <Button 
                          className="w-full bg-[#228B22] hover:bg-[#228B22]/80"
                          onClick={() => handleCollectResources(task.id)}
                          disabled={isSubmitting}
                        >
                          <CheckCircle2 className="h-4 w-4 mr-2" />
                          {isSubmitting ? "Collecting..." : "Collect Resources"}
                        </Button>
                      )}
                    </div>
                  </div>
                ) : (
                  // Empty farming slot
                  <Dialog>
                    <DialogTrigger asChild>
                      <div className="h-full min-h-[200px] flex flex-col items-center justify-center p-6">
                        <div className="w-16 h-16 rounded-full bg-[#432874]/20 flex items-center justify-center mb-3">
                          <Plus className="h-8 w-8 text-[#C8B8DB]/70" />
                        </div>
                        <h3 className="font-cinzel font-bold text-lg text-[#C8B8DB] mb-1">
                          Farming Slot {slot}
                        </h3>
                        
                        {/* Farm Plot Bonuses */}
                        {(() => {
                          const bonuses = calculateSlotBonuses(slot - 1);
                          
                          // Only show if there are any bonuses (slot level > 1)
                          if (bonuses.level > 1) {
                            const isBountifulPath = bonuses.path === 'Bountiful Harvest';
                            return (
                              <div className={`mb-2 p-2 rounded-md text-xs ${
                                isBountifulPath ? 'bg-[#228B22]/10 border border-[#228B22]/20' : 'bg-[#00B9AE]/10 border border-[#00B9AE]/20'
                              }`}>
                                <div className="flex justify-between items-center mb-1">
                                  <div className="flex items-center">
                                    {isBountifulPath ? (
                                      <Gem className="h-3 w-3 mr-1 text-[#228B22]" />
                                    ) : (
                                      <Timer className="h-3 w-3 mr-1 text-[#00B9AE]" />
                                    )}
                                    <span className={isBountifulPath ? 'text-[#228B22]' : 'text-[#00B9AE]'}>
                                      {bonuses.path} (Level {bonuses.level})
                                    </span>
                                  </div>
                                </div>
                                <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[#C8B8DB]/80">
                                  <div className="flex items-center">
                                    <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                    <span>+{bonuses.yieldBonus}% Yield</span>
                                  </div>
                                  <div className="flex items-center">
                                    <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                    <span>+{bonuses.speedBonus}% Speed</span>
                                  </div>
                                  <div className="flex items-center">
                                    <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                    <span>+{bonuses.qualityBonus}% Quality</span>
                                  </div>
                                  <div className="flex items-center">
                                    <div className={`w-2 h-2 rounded-full ${isBountifulPath ? 'bg-[#228B22]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                    <span>+{bonuses.bonusChance}% Bonus</span>
                                  </div>
                                </div>
                              </div>
                            );
                          }
                          return null;
                        })()}
                        
                        <Button 
                          variant="outline" 
                          size="sm" 
                          className="h-6 px-2 py-0 mb-2 text-xs bg-[#228B22]/10 border-[#228B22]/30 text-[#228B22] hover:bg-[#228B22]/20"
                          onClick={(e) => {
                            e.stopPropagation();
                            setUpgradeSlot(slot);
                          }}
                        >
                          Upgrade
                        </Button>
                        <p className="text-sm text-[#C8B8DB]/70 text-center">
                          Click to assign a character to farm resources.
                        </p>
                      </div>
                    </DialogTrigger>
                    
                    <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
                      <DialogHeader>
                        <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">
                          Start Farming - Slot {slot}
                        </DialogTitle>
                      </DialogHeader>
                      
                      <div className="py-4">
                        {/* Select Resource */}
                        <h3 className="font-semibold mb-2">Select Resource to Farm</h3>
                        <div className="grid grid-cols-2 gap-2 mb-4">
                          {farmingResources.map(resource => (
                            <div
                              key={resource.id}
                              className={`flex items-center p-2 rounded-md border cursor-pointer ${
                                selectedResource?.id === resource.id
                                  ? 'bg-[#432874]/40 border-[#228B22]/50'
                                  : 'bg-[#1F1D36]/50 border-[#432874]/30'
                              }`}
                              onClick={() => setSelectedResource(resource)}
                            >
                              <img
                                src={resource.image}
                                alt={resource.name}
                                className="w-10 h-10 rounded-full object-cover border border-[#432874]/50"
                              />
                              <div className="ml-2">
                                <div className="text-sm font-semibold">{resource.name}</div>
                                <Badge className={`text-xs ${getTypeStyles(resource.type)}`}>
                                  {resource.type}
                                </Badge>
                              </div>
                            </div>
                          ))}
                        </div>
                        
                        {/* Resource Details (if selected) */}
                        {selectedResource && (
                          <div className="bg-[#432874]/20 p-3 rounded-md mb-4">
                            <h4 className="text-sm font-semibold mb-1">{selectedResource.name}</h4>
                            <p className="text-xs text-[#C8B8DB]/80 mb-2">{selectedResource.description}</p>
                            <div className="flex items-center text-xs">
                              <Timer className="h-3 w-3 mr-1 text-[#C8B8DB]/70" />
                              <span>Base Time: {Math.floor(selectedResource.baseTime / 60)} minutes</span>
                            </div>
                          </div>
                        )}
                        
                        {/* Select Character */}
                        <h3 className="font-semibold mb-2">Select Character</h3>
                        {availableCharacters.length === 0 ? (
                          <div className="bg-[#432874]/20 p-4 rounded-md text-center mb-4">
                            <UserX className="h-8 w-8 mx-auto mb-2 text-[#DC143C]" />
                            <p className="text-[#C8B8DB]/80 text-sm">
                              All characters are currently busy. Wait for them to complete their current tasks or recruit new ones.
                            </p>
                          </div>
                        ) : (
                          <div className="grid grid-cols-1 gap-2 max-h-48 overflow-y-auto mb-4">
                            {availableCharacters.map(character => (
                              <div
                                key={character.id}
                                className={`flex items-center p-2 rounded-md border cursor-pointer ${
                                  selectedCharacter === character.id
                                    ? 'bg-[#432874]/40 border-[#228B22]/50'
                                    : 'bg-[#1F1D36]/50 border-[#432874]/30'
                                }`}
                                onClick={() => setSelectedCharacter(character.id)}
                              >
                                <img
                                  src={character.avatarUrl}
                                  alt={character.name}
                                  className="w-10 h-10 rounded-full object-cover border border-[#432874]/50"
                                />
                                <div className="ml-2 flex-1">
                                  <div className="flex justify-between">
                                    <span className="text-sm font-semibold">{character.name}</span>
                                    <span className="text-xs">Lvl {character.level}</span>
                                  </div>
                                  <div className="text-xs text-[#C8B8DB]/70">
                                    {/* Character can farm faster based on level */}
                                    Farming Efficiency: +{Math.min(40, (character.level || 1) * 2)}%
                                  </div>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                        
                        {/* Farming Time Estimate */}
                        {selectedResource && selectedCharacter && (
                          <div className="bg-[#228B22]/10 p-3 rounded-md border border-[#228B22]/30 mb-4">
                            <div className="flex justify-between items-center">
                              <h4 className="text-sm font-semibold flex items-center">
                                <Clock className="h-4 w-4 mr-1 text-[#228B22]" />
                                Estimated Farming Time
                              </h4>
                              <HelpCircle className="h-4 w-4 text-[#C8B8DB]/50" />
                            </div>
                            <div className="text-sm mt-1">
                              {(() => {
                                const character = characters.find(c => c.id === selectedCharacter);
                                const levelMultiplier = Math.max(0.6, 1 - (character?.level || 1) * 0.02);
                                const minutes = Math.ceil((selectedResource.baseTime * levelMultiplier) / 60);
                                return `${minutes} minutes`;
                              })()}
                            </div>
                          </div>
                        )}
                      </div>
                      
                      <DialogFooter>
                        <Button
                          className="bg-[#228B22] hover:bg-[#228B22]/80"
                          onClick={startFarmingTask}
                          disabled={isSubmitting || !selectedResource || !selectedCharacter || availableCharacters.length === 0}
                        >
                          <Gem className="h-4 w-4 mr-2" />
                          {isSubmitting ? "Starting..." : "Start Farming"}
                        </Button>
                      </DialogFooter>
                    </DialogContent>
                  </Dialog>
                )}
              </motion.div>
            );
          })}
        </div>
        
        {/* Tips Section */}
        <div className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-6">
          <h2 className="text-xl font-cinzel font-bold text-[#FF9D00] mb-4">Farming Tips</h2>
          <div className="space-y-3">
            <div className="flex">
              <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
                <span className="text-[#FF9D00] font-bold">1</span>
              </div>
              <p className="text-[#C8B8DB]/80">
                Higher-level characters farm resources faster, with up to 40% reduction in farming time.
              </p>
            </div>
            <div className="flex">
              <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
                <span className="text-[#FF9D00] font-bold">2</span>
              </div>
              <p className="text-[#C8B8DB]/80">
                Rare and epic resource types take longer to farm but provide better materials for crafting higher-quality Auras.
              </p>
            </div>
            <div className="flex">
              <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
                <span className="text-[#FF9D00] font-bold">3</span>
              </div>
              <p className="text-[#C8B8DB]/80">
                Upgrade your Townhall to unlock additional farming slots and increase your material production.
              </p>
            </div>
          </div>
        </div>
      </>
    );
  };
  
  // Store the main content in a variable
  const mainContent = renderMainContent();
  
  // Render the upgrade dialog
  return (
    <>
      {/* Render the main component content */}
      {mainContent}
      
      {/* Upgrade Slot Dialog */}
      <Dialog open={upgradeSlot !== null} onOpenChange={(open) => !open && setUpgradeSlot(null)}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">
              Upgrade Farming Slot {upgradeSlot}
            </DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              Enhance your farming capabilities with upgraded slots.
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            {/* Upgrade path selection */}
            <div className="grid grid-cols-2 gap-4 mb-4">
              {/* Path 1: Quantity Focus */}
              <div 
                className={`p-4 rounded-lg border-2 cursor-pointer ${
                  selectedUpgradePath === 1 
                    ? 'bg-[#432874]/30 border-[#228B22]' 
                    : 'bg-[#432874]/10 border-[#432874]/30 hover:bg-[#432874]/20'
                }`}
                onClick={() => setSelectedUpgradePath(1)}
              >
                <h3 className="font-semibold mb-2 flex items-center">
                  <Gem className="h-4 w-4 mr-2 text-[#228B22]" />
                  Bountiful Harvest
                </h3>
                <p className="text-xs mb-2 text-[#C8B8DB]/80">Focus on increasing the quantity of resources gathered from each farming session.</p>
                <ul className="space-y-1 text-sm">
                  <li className="flex items-center">
                    <span className="bg-[#228B22]/20 text-[#228B22] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>15% increase in resource yield</span>
                  </li>
                  <li className="flex items-center">
                    <span className="bg-[#228B22]/20 text-[#228B22] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>Chance for bonus materials</span>
                  </li>
                </ul>
              </div>
              
              {/* Path 2: Speed/Quality Focus */}
              <div 
                className={`p-4 rounded-lg border-2 cursor-pointer ${
                  selectedUpgradePath === 2 
                    ? 'bg-[#432874]/30 border-[#00B9AE]' 
                    : 'bg-[#432874]/10 border-[#432874]/30 hover:bg-[#432874]/20'
                }`}
                onClick={() => setSelectedUpgradePath(2)}
              >
                <h3 className="font-semibold mb-2 flex items-center">
                  <Timer className="h-4 w-4 mr-2 text-[#00B9AE]" />
                  Swift Cultivation
                </h3>
                <p className="text-xs mb-2 text-[#C8B8DB]/80">Focus on reducing farming time and improving the quality of gathered resources.</p>
                <ul className="space-y-1 text-sm">
                  <li className="flex items-center">
                    <span className="bg-[#00B9AE]/20 text-[#00B9AE] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>20% reduction in farming time</span>
                  </li>
                  <li className="flex items-center">
                    <span className="bg-[#00B9AE]/20 text-[#00B9AE] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>Increased chance for rare resources</span>
                  </li>
                </ul>
              </div>
            </div>
            
            {/* Current upgrade level and benefits */}
            <div className="bg-[#432874]/20 p-4 rounded-lg mb-4">
              <h3 className="font-semibold mb-2 flex items-center">
                <ArrowUp className="h-4 w-4 mr-2 text-[#FF9D00]" />
                Current Level Benefits
              </h3>
              <div className="text-sm mb-3">
                <span className="font-medium">Current Level:</span> 
                <span className="ml-2 bg-[#FF9D00]/20 text-[#FF9D00] px-2 py-0.5 rounded">Level 2</span>
                <span className="ml-2 text-[#C8B8DB]/70">(Max Level: 5 - Limited by Townhall)</span>
              </div>
              <ul className="space-y-1 text-sm">
                <li className="flex items-center">
                  <span className={`${selectedUpgradePath === 1 ? 'bg-[#228B22]/20 text-[#228B22]' : 'bg-[#00B9AE]/20 text-[#00B9AE]'} w-5 h-5 rounded-full flex items-center justify-center mr-2`}>+</span>
                  <span>{selectedUpgradePath === 1 ? '15% increase in resource yield' : '20% reduction in farming time'}</span>
                </li>
              </ul>
            </div>
            
            <div className="bg-[#1F1D36] p-4 rounded-lg border border-[#432874]/30">
              <div className="flex justify-between items-center mb-2">
                <span className="font-semibold">Cost:</span>
                <div className="flex items-center">
                  <Gem className="h-4 w-4 mr-1 text-[#FF9D00]" />
                  <span className="text-[#FF9D00]">500 Forge Tokens</span>
                </div>
              </div>
              <div className="flex justify-between items-center">
                <span className="font-semibold">Required Townhall Level:</span>
                <span>3</span>
              </div>
            </div>
          </div>
          
          <DialogFooter>
            <Button
              className="bg-[#432874] hover:bg-[#432874]/80 text-white"
              onClick={() => setUpgradeSlot(null)}
            >
              Cancel
            </Button>
            <Button
              className={`${selectedUpgradePath === 1 
                ? 'bg-[#228B22] hover:bg-[#228B22]/80' 
                : 'bg-[#00B9AE] hover:bg-[#00B9AE]/80'}`}
              onClick={() => upgradeSlot !== null && handleUpgradeSlot(upgradeSlot)}
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <>Upgrading...</>
              ) : (
                <>
                  <ArrowUp className="h-4 w-4 mr-2" />
                  Upgrade Slot
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
};

export default FarmingView;


=== client/src/components/forge/ForgeView.tsx ===
import { useEffect, useState } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useGameStore } from "@/lib/zustandStore";
import { useDiscordAuth } from "@/lib/discordAuth";
import { motion } from "framer-motion";
import { ArrowUpCircle, Clock, Flame, Hammer, LayoutGrid, Sparkles, User, Info } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Progress } from "@/components/ui/progress";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Aura, BuildingUpgrade, Character, ForgingTask } from "@shared/schema";
import CountdownTimer from "../common/CountdownTimer";

const ForgeView = () => {
  const { auras = [], resources = [], characters = [], fetchAuras, fetchResources, fetchForgingTasks, fetchCharacters } = useGameStore();
  const { toast } = useToast();
  
  // Get all building upgrades for current user
  const { data: userBuildingUpgrades = { farmSlots: [], forgeSlots: [], marketUpgrades: [], buildings: [] } } = useQuery<any>({
    queryKey: ['/api/buildings/upgrades'],
  });
  
  // Get individual building data
  const buildings = userBuildingUpgrades.buildings || [];
  
  // Get townhall building level (for slot unlocking)
  const townhallUpgrade = buildings.find((b: any) => b.buildingType === 'townhall');
  const townhallLevel = townhallUpgrade?.currentLevel || 1;
  
  // Determine available crafting slots based on forge level (1 by default, +1 per level up to 3)
  // The 4th slot is locked until townhall is upgraded
  const forgeUpgrade = buildings.find((b: any) => b.buildingType === 'forge');
  const forgeLevel = forgeUpgrade?.currentLevel || 1;
  
  // Get forge slot upgrades
  const forgeSlotUpgrades = userBuildingUpgrades.forgeSlots || [];
  
  // Calculate available slots: 
  // - Base: 3 slots (slots 1, 2, and 3 are now unlocked by default)
  // - Townhall Level 3+: Unlocks 4th slot
  // Note: Previously this was tiered to forge level, but we're now unlocking all 3 slots by default
  const baseSlots = 3; // All 3 basic slots are available
  const bonusSlots = townhallLevel >= 3 ? 1 : 0;
  
  // Use the admin status from the user to determine if unlimited slots are available
  const { user } = useDiscordAuth();
  const isAdmin = user?.isAdmin || false;
  const maxCraftingSlots = isAdmin ? 999 : baseSlots + bonusSlots; // Admin gets unlimited slots (999)
  
  // Additional state for slot selection
  const [selectedSlot, setSelectedSlot] = useState<number | null>(null);
  const [showSlotUpgradeDialog, setShowSlotUpgradeDialog] = useState(false);
  // State for tracking which skill path is selected (1: base stats path, 2: fusion bonus path)
  const [selectedUpgradePath, setSelectedUpgradePath] = useState<number>(1);
  
  // Original state
  const [selectedTab, setSelectedTab] = useState('slots'); // Changed default to slots
  const [selectedElement, setSelectedElement] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [primaryAura, setPrimaryAura] = useState<Aura | null>(null);
  const [secondaryAura, setSecondaryAura] = useState<Aura | null>(null);
  const [selectedCharacterId, setSelectedCharacterId] = useState<number | null>(null);
  
  // Get forging tasks
  const { data: forgingTasks = [], isLoading: isTasksLoading } = useQuery<ForgingTask[]>({ 
    queryKey: ['/api/forge/tasks'],
    refetchInterval: 2000, // Refresh every 2 seconds for more immediate updates
    staleTime: 1000, // Consider data stale after 1 second
    refetchOnWindowFocus: true // Refresh when window gets focus
  });
  
  // Get currently available characters (not assigned to any active tasks)
  const availableCharacters = characters.filter(char => {
    // Check if character is assigned to any active forging task
    const isInForgingTask = forgingTasks.some(task => 
      !task.completed && task.characterId === char.id
    );
    
    // Check if character is assigned to any active farming task
    const isInFarmingTask = useGameStore.getState().farmingTasks.some(task => 
      !task.completed && task.characterId === char.id
    );
    
    // Check if character is in a dungeon run
    const isInDungeonRun = useGameStore.getState().dungeonRuns.some(run => 
      !run.completed && run.characterIds && run.characterIds.includes(char.id)
    );
    
    // Character is available if not assigned to any active task
    return !isInForgingTask && !isInFarmingTask && !isInDungeonRun;
  });

  // Filter auras that are not currently being used in fusion
  const availableAuras = auras.filter(aura => !aura.isFusing);
  const activeForgingTasks = forgingTasks.filter(task => !task.completed);
  
  // Reset selections when changing tabs
  useEffect(() => {
    setPrimaryAura(null);
    setSecondaryAura(null);
    setSelectedElement(null);
    setSelectedCharacterId(null);
  }, [selectedTab]);
  
  // Start crafting a new aura
  const startCrafting = async () => {
    if (!selectedElement) {
      toast({
        title: "Element Required",
        description: "Please select an element for your new aura.",
        variant: "destructive"
      });
      return;
    }
    
    if (!selectedCharacterId) {
      toast({
        title: "Character Required",
        description: "Please select a character to assist with crafting.",
        variant: "destructive"
      });
      return;
    }
    
    // Check if there are available slots
    if (activeForgingTasks.length >= maxCraftingSlots) {
      toast({
        title: "No Available Slots",
        description: `You can only have ${maxCraftingSlots} active crafting tasks. Upgrade your Forge to unlock more slots.`,
        variant: "destructive"
      });
      return;
    }
    
    // Check if user has enough materials (essence)
    const essence = resources.find(r => r.name === 'Essence');
    if (!essence || (essence.quantity || 0) < 500) {
      toast({
        title: "Insufficient Materials",
        description: `You need 500 Essence to craft a new aura. You have ${essence?.quantity || 0}.`,
        variant: "destructive"
      });
      return;
    }
    
    setIsSubmitting(true);
    try {
      // Create task with required materials
      // Calculate completion time (5 minutes for crafting)
      const now = new Date();
      const endTime = new Date(now.getTime() + 5 * 60 * 1000); // Add 5 minutes in milliseconds
      
      console.log('Sending forge request with endTime:', endTime.toISOString());
      
      const response = await apiRequest('POST', '/api/forge/craft', {
        targetElement: selectedElement,
        characterId: selectedCharacterId, // Add the selected character ID
        endTime: endTime.toISOString(), // Server expects ISO string format
        requiredMaterials: {
          'Essence': 500
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to start crafting");
      }
      
      const data = await response.json();
      
      toast({
        title: "Crafting Started",
        description: `You've started crafting a new ${selectedElement} Aura. It will be ready in 5 minutes.`,
      });
      
      // Refresh resources and forging tasks
      fetchResources();
      fetchForgingTasks();
      fetchCharacters(); // Refresh characters to update their activity status
      setSelectedElement(null);
      setSelectedCharacterId(null);
    } catch (error: any) {
      console.error('Error starting craft:', error);
      toast({
        title: "Error",
        description: error.message || "Failed to start crafting.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  // Complete a forging task
  const [showResultDialog, setShowResultDialog] = useState(false);
const [completedAura, setCompletedAura] = useState<Aura | null>(null);

const completeForging = async (taskId: number) => {
    setIsSubmitting(true);
    try {
      const response = await apiRequest('POST', `/api/forge/complete/${taskId}`, undefined);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to complete forging task");
      }
      
      const data = await response.json();
      
      // Store the completed aura and show dialog
      setCompletedAura(data.aura);
      setShowResultDialog(true);
      
      // Refresh forging tasks, auras, and characters
      fetchForgingTasks();
      fetchAuras();
      fetchCharacters(); // Refresh characters to update their activity status
    } catch (error: any) {
      console.error('Error completing forging task:', error);
      toast({
        title: "Error",
        description: error.message || "Failed to complete forging task.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };
  
  // Add slot upgrade dialog
  const [upgradeSlotDetails, setUpgradeSlotDetails] = useState({
    slot: 0,
    currentLevel: 1,
    maxLevel: 5,
    speedBonus: 5, // % reduction in crafting time per level
    qualityBonus: 2, // % increase in quality per level
    upgradePath: 1 // Default to Master Artisan path
  });
  
  const closeSlotUpgradeDialog = () => {
    setShowSlotUpgradeDialog(false);
  };
  
  // Initialize the query client
  const queryClient = useQueryClient();
  
  // Function to get slot upgrade details from the database
  const getSlotUpgradeDetails = (slotIndex: number) => {
    // Look for existing upgrade path info
    const slotInfo = forgeSlotUpgrades.find((slot: any) => slot.slotId === slotIndex);
    
    // Set defaults if no existing data
    const currentLevel = slotInfo?.level || 1;
    const currentPath = slotInfo?.upgradePath || 1;
    
    return {
      slot: slotIndex,
      currentLevel: currentLevel,
      maxLevel: 5,
      speedBonus: 5, // % reduction in crafting time per level
      qualityBonus: 2, // % increase in quality per level
      upgradePath: currentPath
    };
  };
  
  // Function to calculate the actual bonuses for a slot based on its level and path
  const calculateSlotBonuses = (slotIndex: number) => {
    const slotInfo = forgeSlotUpgrades.find((slot: any) => slot.slotId === slotIndex);
    
    if (!slotInfo) {
      return {
        level: 1,
        path: 'None',
        statBonus: 0,
        fusionBonus: 0,
        speedBonus: 0,
        qualityBonus: 0
      };
    }
    
    const level = slotInfo.level || 1;
    const path = slotInfo.upgradePath || 1;
    
    // Different bonuses based on path
    // Path 1: Master Artisan - higher base stats on crafted auras
    // Path 2: Fusion Specialist - better fusion bonuses
    
    if (path === 1) {
      // Master Artisan path (orange): Better base stats, small fusion bonus
      return {
        level,
        path: 'Master Artisan',
        statBonus: level * 5, // 5% better stats per level
        fusionBonus: level * 2, // 2% better fusion per level
        speedBonus: level * 2, // 2% faster per level
        qualityBonus: level * 3 // 3% better quality per level
      };
    } else {
      // Fusion Specialist path (teal): Better fusion results, small stat bonus
      return {
        level,
        path: 'Fusion Specialist',
        statBonus: level * 2, // 2% better stats per level
        fusionBonus: level * 5, // 5% better fusion per level
        speedBonus: level * 3, // 3% faster per level
        qualityBonus: level * 2 // 2% better quality per level
      };
    }
  };
  
  const upgradeSlot = () => {
    setIsSubmitting(true);
    
    // Make API call to upgrade the slot with selected path
    apiRequest('POST', '/api/buildings/upgrade', {
      buildingType: 'forgeSlot',
      slotId: upgradeSlotDetails.slot,
      upgradePath: selectedUpgradePath,
      pathName: selectedUpgradePath === 1 ? 'Master Artisan' : 'Fusion Specialist'
    })
    .then(response => {
      if (response.ok) {
        toast({
          title: "Slot Upgraded",
          description: `Forge Slot ${upgradeSlotDetails.slot + 1} has been upgraded with ${selectedUpgradePath === 1 ? 'Master Artisan' : 'Fusion Specialist'} path.`,
        });
        
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ['/api/buildings/upgrades'] });
      } else {
        throw new Error("Failed to upgrade slot");
      }
    })
    .catch(error => {
      console.error('Error upgrading slot:', error);
      toast({
        title: "Upgrade Failed",
        description: error.message || "Failed to upgrade slot. Please try again.",
        variant: "destructive"
      });
    })
    .finally(() => {
      setIsSubmitting(false);
      closeSlotUpgradeDialog();
    });
  };
  
  return (
    <>
      {/* Slot Upgrade Dialog */}
      <Dialog open={showSlotUpgradeDialog} onOpenChange={setShowSlotUpgradeDialog}>
        <DialogContent className="bg-[#1A1A2E] border-[#432874]/50 text-[#C8B8DB] max-w-md">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Upgrade Crafting Slot</DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              Upgrade this slot to improve crafting speed and aura quality.
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <div className="flex justify-between items-center mb-4">
              <div>
                <h4 className="font-semibold">Crafting Slot {upgradeSlotDetails.slot + 1}</h4>
                <p className="text-sm text-[#C8B8DB]/70">
                  Current Level: {upgradeSlotDetails.currentLevel}/{upgradeSlotDetails.maxLevel}
                </p>
              </div>
              <div className="bg-[#432874]/30 px-3 py-1 rounded">
                <span className="text-[#FF9D00] font-semibold">Lv.{upgradeSlotDetails.currentLevel}</span>
              </div>
            </div>
            
            {/* Upgrade path selection */}
            <div className="grid grid-cols-2 gap-4 mb-4">
              {/* Path 1: Forge Quality Focus */}
              <div 
                className={`p-4 rounded-lg border-2 cursor-pointer ${
                  selectedUpgradePath === 1 
                    ? 'bg-[#432874]/30 border-[#FF9D00]' 
                    : 'bg-[#432874]/10 border-[#432874]/30 hover:bg-[#432874]/20'
                }`}
                onClick={() => setSelectedUpgradePath(1)}
              >
                <h3 className="font-semibold mb-2 flex items-center">
                  <Hammer className="h-4 w-4 mr-2 text-[#FF9D00]" />
                  Master Artisan
                </h3>
                <p className="text-xs mb-2 text-[#C8B8DB]/80">Focus on improving the base stats of newly crafted Auras.</p>
                <ul className="space-y-1 text-sm">
                  <li className="flex items-center">
                    <span className="bg-[#FF9D00]/20 text-[#FF9D00] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>15% higher base stats</span>
                  </li>
                  <li className="flex items-center">
                    <span className="bg-[#FF9D00]/20 text-[#FF9D00] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>Chance for rare skills</span>
                  </li>
                </ul>
              </div>
              
              {/* Path 2: Fusion Bonus Focus */}
              <div 
                className={`p-4 rounded-lg border-2 cursor-pointer ${
                  selectedUpgradePath === 2 
                    ? 'bg-[#432874]/30 border-[#00B9AE]' 
                    : 'bg-[#432874]/10 border-[#432874]/30 hover:bg-[#432874]/20'
                }`}
                onClick={() => setSelectedUpgradePath(2)}
              >
                <h3 className="font-semibold mb-2 flex items-center">
                  <Sparkles className="h-4 w-4 mr-2 text-[#00B9AE]" />
                  Fusion Specialist
                </h3>
                <p className="text-xs mb-2 text-[#C8B8DB]/80">Focus on enhancing fusion bonuses when combining Auras.</p>
                <ul className="space-y-1 text-sm">
                  <li className="flex items-center">
                    <span className="bg-[#00B9AE]/20 text-[#00B9AE] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>20% fusion bonus effect</span>
                  </li>
                  <li className="flex items-center">
                    <span className="bg-[#00B9AE]/20 text-[#00B9AE] w-5 h-5 rounded-full flex items-center justify-center mr-2">+</span>
                    <span>Additional skill transfers</span>
                  </li>
                </ul>
              </div>
            </div>
            
            {upgradeSlotDetails.currentLevel < upgradeSlotDetails.maxLevel ? (
              <>
                <div className="space-y-3 mb-4">
                  <div className="bg-[#15152C] p-3 rounded-md">
                    <div className="flex justify-between items-center">
                      <div className="flex items-center">
                        {selectedUpgradePath === 1 ? (
                          <Hammer className="h-4 w-4 text-[#FF9D00] mr-2" />
                        ) : (
                          <Sparkles className="h-4 w-4 text-[#00B9AE] mr-2" />
                        )}
                        <span>{selectedUpgradePath === 1 ? 'Base Aura Quality' : 'Fusion Bonus Effect'}</span>
                      </div>
                      <Badge variant="outline" className={`${selectedUpgradePath === 1 ? 'border-[#FF9D00]/30 text-[#FF9D00]' : 'border-[#00B9AE]/30 text-[#00B9AE]'}`}>
                        +{(selectedUpgradePath === 1 ? upgradeSlotDetails.qualityBonus : upgradeSlotDetails.speedBonus) * upgradeSlotDetails.currentLevel}%
                      </Badge>
                    </div>
                    <p className="text-xs text-[#C8B8DB]/60 mt-1 ml-6">
                      Next Level: +{(selectedUpgradePath === 1 ? upgradeSlotDetails.qualityBonus : upgradeSlotDetails.speedBonus) * (upgradeSlotDetails.currentLevel + 1)}%
                    </p>
                  </div>
                </div>
                
                <div className="bg-[#1F1D36] p-3 rounded-md mb-4">
                  <h4 className="font-semibold mb-2">Upgrade Cost</h4>
                  <div className="grid grid-cols-2 gap-2">
                    <div className="flex items-center">
                      <div className="w-6 h-6 rounded-full bg-[#432874]/30 flex items-center justify-center mr-2">
                        <span className="text-[#FF9D00] text-xs">RC</span>
                      </div>
                      <span>{1000 * upgradeSlotDetails.currentLevel} Rogue Credits</span>
                    </div>
                    <div className="flex items-center">
                      <div className="w-6 h-6 rounded-full bg-[#432874]/30 flex items-center justify-center mr-2">
                        <span className="text-[#00B9AE] text-xs">FT</span>
                      </div>
                      <span>{100 * upgradeSlotDetails.currentLevel} Forge Tokens</span>
                    </div>
                  </div>
                </div>
                
                <Button 
                  className={`w-full ${selectedUpgradePath === 1 
                    ? 'bg-[#FF9D00] hover:bg-[#FF9D00]/80' 
                    : 'bg-[#00B9AE] hover:bg-[#00B9AE]/80'} text-[#1A1A2E]`}
                  onClick={upgradeSlot}
                  disabled={isSubmitting}
                >
                  <ArrowUpCircle className="h-4 w-4 mr-2" />
                  Upgrade Slot
                </Button>
              </>
            ) : (
              <div className="bg-[#432874]/20 p-4 rounded-md text-center">
                <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] mb-2">Maximum Level</Badge>
                <p className="text-sm">This crafting slot has reached its maximum level.</p>
                <div className="mt-4 grid grid-cols-2 gap-4 text-sm">
                  <div className="bg-[#1F1D36] p-2 rounded">
                    <div className="text-[#00B9AE] font-semibold">-{upgradeSlotDetails.speedBonus * upgradeSlotDetails.maxLevel}%</div>
                    <div className="text-[#C8B8DB]/70">Crafting Time</div>
                  </div>
                  <div className="bg-[#1F1D36] p-2 rounded">
                    <div className="text-[#FF9D00] font-semibold">+{upgradeSlotDetails.qualityBonus * upgradeSlotDetails.maxLevel}%</div>
                    <div className="text-[#C8B8DB]/70">Aura Quality</div>
                  </div>
                </div>
              </div>
            )}
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={closeSlotUpgradeDialog}>
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">The Forge</h1>
        <p className="text-[#C8B8DB]/80">
          Craft new Auras and fuse existing ones to create more powerful versions.
        </p>
        
        {isAdmin && (
          <div className="mt-2 bg-[#FF9D00]/10 border border-[#FF9D00]/30 rounded-md p-2 flex items-center">
            <Sparkles className="h-4 w-4 text-[#FF9D00] mr-2" />
            <span className="text-sm text-[#FF9D00]">Admin Mode: Unlimited crafting slots unlocked</span>
          </div>
        )}
      </div>
      
      {/* Active Tasks */}
      {activeForgingTasks.length > 0 && (
        <motion.div 
          className="mb-8"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <h2 className="text-xl font-cinzel font-bold mb-4">Active Forging</h2>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {activeForgingTasks.map(task => {
              // Calculate progress percentage
              const startTime = new Date(task.startTime || Date.now()).getTime();
              const endTime = new Date(task.endTime || Date.now()).getTime();
              const now = new Date().getTime();
              const progress = Math.min(
                100,
                Math.max(0, ((now - startTime) / (endTime - startTime)) * 100)
              );
              
              // Check if task is complete
              const isComplete = now >= endTime;
              
              return (
                <Card key={task.id} className="bg-[#1A1A2E] border-[#432874]/30">
                  <CardHeader className="pb-2">
                    <div className="flex justify-between items-start">
                      <div>
                        <CardTitle className="text-lg">
                          {task.taskType === 'craft' ? 'Crafting' : 'Fusion'}
                        </CardTitle>
                        <CardDescription>
                          {task.taskType === 'craft' 
                            ? `New ${task.targetElement} Aura` 
                            : 'Fusing Auras'
                          }
                        </CardDescription>
                      </div>
                      <Badge 
                        className={task.taskType === 'craft' 
                          ? 'bg-purple-700/30 text-purple-300 border-purple-600/30'
                          : 'bg-orange-700/30 text-orange-300 border-orange-600/30'
                        }
                      >
                        {task.taskType === 'craft' ? 'New' : 'Fusion'}
                      </Badge>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <div className="mb-4">
                      <Progress value={progress} max={100} className="h-2 bg-[#432874]/20" />
                    </div>
                    
                    {isComplete ? (
                      <div className="flex justify-center items-center py-2">
                        <span className="text-green-400 flex items-center">
                          <Sparkles className="h-4 w-4 mr-1" />
                          Ready to claim!
                        </span>
                      </div>
                    ) : (
                      <div className="flex justify-between items-center text-sm">
                        <span className="text-[#C8B8DB]/80 flex items-center">
                          <Clock className="h-4 w-4 mr-1" />
                          Completes in <CountdownTimer 
                            endTime={task.endTime} 
                            onComplete={() => completeForging(task.id)}
                          />
                        </span>
                      </div>
                    )}
                  </CardContent>
                  {isComplete && (
                    <CardFooter>
                      <Button
                        className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                        onClick={() => completeForging(task.id)}
                        disabled={isSubmitting}
                      >
                        <Sparkles className="h-4 w-4 mr-2" />
                        {isSubmitting ? 'Completing...' : 'Complete Forging'}
                      </Button>
                    </CardFooter>
                  )}
                </Card>
              );
            })}
          </div>
        </motion.div>
      )}
      
      {/* Forge Interface */}
      <div className="bg-[#1A1A2E] rounded-xl border border-[#432874]/30 p-6">
        <Tabs defaultValue="slots" value={selectedTab} onValueChange={setSelectedTab} className="w-full">
          <TabsList className="bg-[#432874]/20 mb-6">
            <TabsTrigger value="slots" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
              <LayoutGrid className="h-4 w-4 mr-2" />
              Crafting Slots
            </TabsTrigger>
            <TabsTrigger value="craft" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]" disabled={selectedSlot === null}>
              <Hammer className="h-4 w-4 mr-2" />
              Craft Aura
            </TabsTrigger>
            <TabsTrigger value="fusion" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]" disabled={selectedSlot === null}>
              <Flame className="h-4 w-4 mr-2" />
              Aura Fusion
            </TabsTrigger>
          </TabsList>
          
          {/* Crafting Slots Tab */}
          <TabsContent value="slots" className="space-y-6">
            <div>
              <h3 className="text-lg font-semibold mb-4">Select a Crafting Slot</h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                {/* Display maximum 4 crafting slots */}
                {Array.from({ length: 4 }).map((_, index) => {
                  const isUnlocked = index < baseSlots || (index === 3 && bonusSlots > 0);
                  const isInUse = activeForgingTasks[index] !== undefined;
                  const task = activeForgingTasks[index];
                  
                  // Calculate progress for in-use slots
                  const progress = isInUse ? (() => {
                    const startTime = new Date(task?.startTime || Date.now()).getTime();
                    const endTime = new Date(task?.endTime || Date.now()).getTime();
                    const now = new Date().getTime();
                    return Math.min(100, Math.max(0, ((now - startTime) / (endTime - startTime)) * 100));
                  })() : 0;
                  
                  // Determine if task is complete
                  const isComplete = isInUse && new Date().getTime() >= new Date(task?.endTime || Date.now()).getTime();
                  
                  return (
                    <div 
                      key={index}
                      className={`border rounded-lg p-4 ${
                        !isUnlocked ? 'bg-[#1F1D36]/50 border-[#432874]/20 opacity-70' :
                        isInUse ? 'bg-[#15152C] border-[#432874]/50' :
                        selectedSlot === index ? 'bg-[#432874]/30 border-[#432874] cursor-pointer' :
                        'bg-[#15152C] border-[#432874]/30 hover:border-[#432874] cursor-pointer'
                      }`}
                      onClick={() => {
                        if (isUnlocked && !isInUse) {
                          setSelectedSlot(index);
                          // Change to craft tab when slot is selected
                          setSelectedTab('craft');
                        } else if (isUnlocked && isInUse && isComplete) {
                          // Complete task if it's ready
                          completeForging(task?.id || 0);
                        }
                      }}
                    >
                      <div className="flex justify-between items-start mb-2">
                        <h4 className="font-semibold">Crafting Slot {index + 1}</h4>
                        {isUnlocked ? (
                          isInUse ? (
                            <Badge className={isComplete ? 'bg-green-700/30 text-green-300' : 'bg-blue-700/30 text-blue-300'}>
                              {isComplete ? 'Ready' : 'In Use'}
                            </Badge>
                          ) : (
                            <Badge className="bg-[#432874]/30 text-[#C8B8DB]">Available</Badge>
                          )
                        ) : (
                          <Badge className="bg-red-700/30 text-red-300">Locked</Badge>
                        )}
                      </div>
                      
                      {isUnlocked ? (
                        isInUse ? (
                          <div>
                            <div className="text-sm mb-2">
                              {task?.taskType === 'craft' 
                                ? `Crafting ${task?.targetElement} Aura` 
                                : 'Fusing Auras'
                              }
                            </div>
                            <Progress value={progress} max={100} className="h-2 bg-[#432874]/20 mb-2" />
                            {isComplete ? (
                              <div className="flex items-center text-green-400 text-sm">
                                <Sparkles className="h-4 w-4 mr-1" />
                                Ready to claim!
                              </div>
                            ) : (
                              <div className="flex items-center text-sm text-[#C8B8DB]/80">
                                <Clock className="h-4 w-4 mr-1" />
                                <CountdownTimer 
                                  endTime={task?.endTime} 
                                  onComplete={() => completeForging(task?.id || 0)}
                                />
                              </div>
                            )}
                          </div>
                        ) : (
                          <>
                            <div className="text-sm text-[#C8B8DB]/70 mb-3">
                              Select an operation for this slot
                            </div>
                            
                            {/* Show Slot Bonuses */}
                            {(() => {
                              const bonuses = calculateSlotBonuses(index);
                              // Only show if there are any bonuses (slot level > 1)
                              if (bonuses.level > 1) {
                                const isArtisanPath = bonuses.path === 'Master Artisan';
                                return (
                                  <div className={`mb-3 p-2 rounded-md text-xs ${
                                    isArtisanPath ? 'bg-[#FF9D00]/10 border border-[#FF9D00]/20' : 'bg-[#00B9AE]/10 border border-[#00B9AE]/20'
                                  }`}>
                                    <div className="flex justify-between items-center mb-1">
                                      <div className="flex items-center">
                                        {isArtisanPath ? (
                                          <Hammer className="h-3 w-3 mr-1 text-[#FF9D00]" />
                                        ) : (
                                          <Sparkles className="h-3 w-3 mr-1 text-[#00B9AE]" />
                                        )}
                                        <span className={isArtisanPath ? 'text-[#FF9D00]' : 'text-[#00B9AE]'}>
                                          {bonuses.path} (Level {bonuses.level})
                                        </span>
                                      </div>
                                    </div>
                                    <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[#C8B8DB]/80">
                                      <div className="flex items-center">
                                        <div className={`w-2 h-2 rounded-full ${isArtisanPath ? 'bg-[#FF9D00]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                        <span>+{bonuses.statBonus}% Stats</span>
                                      </div>
                                      <div className="flex items-center">
                                        <div className={`w-2 h-2 rounded-full ${isArtisanPath ? 'bg-[#FF9D00]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                        <span>+{bonuses.fusionBonus}% Fusion</span>
                                      </div>
                                      <div className="flex items-center">
                                        <div className={`w-2 h-2 rounded-full ${isArtisanPath ? 'bg-[#FF9D00]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                        <span>+{bonuses.speedBonus}% Speed</span>
                                      </div>
                                      <div className="flex items-center">
                                        <div className={`w-2 h-2 rounded-full ${isArtisanPath ? 'bg-[#FF9D00]/50' : 'bg-[#00B9AE]/50'} mr-1`}></div>
                                        <span>+{bonuses.qualityBonus}% Quality</span>
                                      </div>
                                    </div>
                                  </div>
                                );
                              }
                              return null;
                            })()}
                            
                            <div className="grid grid-cols-3 gap-1">
                              <Button 
                                variant="outline" 
                                size="sm" 
                                className="text-xs border-[#432874]/30 hover:bg-[#432874]/20"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setSelectedSlot(index);
                                  setSelectedTab('craft');
                                }}
                              >
                                <Hammer className="h-3 w-3 mr-1" />
                                Forge
                              </Button>
                              <Button 
                                variant="outline" 
                                size="sm" 
                                className="text-xs border-[#432874]/30 hover:bg-[#432874]/20"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setSelectedSlot(index);
                                  setSelectedTab('fusion');
                                }}
                              >
                                <Flame className="h-3 w-3 mr-1" />
                                Fuse
                              </Button>
                              <Button 
                                variant="outline" 
                                size="sm" 
                                className="text-xs border-[#432874]/30 hover:bg-[#432874]/20"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  // Get slot upgrade details from database
                                  const slotDetails = getSlotUpgradeDetails(index);
                                  setUpgradeSlotDetails(slotDetails);
                                  // Set the selected upgrade path based on current path
                                  setSelectedUpgradePath(slotDetails.upgradePath);
                                  setShowSlotUpgradeDialog(true);
                                }}
                              >
                                <ArrowUpCircle className="h-3 w-3 mr-1" />
                                Upgrade
                              </Button>
                            </div>
                          </>
                        )
                      ) : (
                        <div className="text-sm text-[#C8B8DB]/70">
                          Requires Townhall Level 3 to unlock
                        </div>
                      )}
                      
                      {/* Removed duplicate slot upgrade button */}
                    </div>
                  );
                })}
              </div>
              
              <div className="bg-[#1F1D36]/50 p-4 rounded-lg mt-4">
                <h4 className="font-semibold mb-2 flex items-center">
                  <Info className="h-4 w-4 mr-2 text-[#00B9AE]" />
                  About Crafting Slots
                </h4>
                <div className="text-sm text-[#C8B8DB]/80 space-y-2">
                  <p> You have 3 crafting slots available by default</p>
                  <p> The 4th slot requires Townhall Level 3 to unlock</p>
                  <p> Each slot can be upgraded to improve crafting speed and quality</p>
                  <p> Use the Forge, Fuse, or Upgrade buttons for each slot</p>
                </div>
              </div>
            </div>
          </TabsContent>
          
          {/* Crafting Interface */}
          <TabsContent value="craft" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Left side: Element and Character selection */}
              <div className="bg-[#15152C] rounded-lg border border-[#432874]/20 p-4">
                <h3 className="text-lg font-semibold mb-4">Select Character & Element</h3>
                
                {/* Character Selection */}
                <div className="mb-6">
                  <h4 className="text-md font-semibold mb-3 flex items-center">
                    Assign Character
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <span className="ml-2 cursor-help">
                            <Info className="h-4 w-4 text-[#C8B8DB]/60" />
                          </span>
                        </TooltipTrigger>
                        <TooltipContent className="max-w-sm">
                          <p>You must assign a character to assist with crafting. This character will be unavailable for other tasks until crafting is complete.</p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                  </h4>
                  
                  {availableCharacters.length > 0 ? (
                    <Select 
                      value={selectedCharacterId ? String(selectedCharacterId) : ""} 
                      onValueChange={(value) => setSelectedCharacterId(Number(value))}
                    >
                      <SelectTrigger className="bg-[#1A1A2E] border-[#432874]/30">
                        <SelectValue placeholder="Select a character" />
                      </SelectTrigger>
                      <SelectContent>
                        {availableCharacters.map(character => (
                          <SelectItem key={character.id} value={String(character.id)}>
                            {character.name} (Lvl {character.level} {character.class})
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <div className="text-sm text-amber-400 py-2 px-4 bg-amber-950/20 border border-amber-900/30 rounded-md">
                      <span className="flex items-center">
                        <Info className="h-4 w-4 mr-2" />
                        All characters are currently busy. Wait for them to complete their tasks.
                      </span>
                    </div>
                  )}
                </div>
                
                {/* Element Selection */}
                <h4 className="text-md font-semibold mb-3">Element Type</h4>
                <Select value={selectedElement || ''} onValueChange={setSelectedElement}>
                  <SelectTrigger className="bg-[#1A1A2E] border-[#432874]/30">
                    <SelectValue placeholder="Select element" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="fire">Fire</SelectItem>
                    <SelectItem value="water">Water</SelectItem>
                    <SelectItem value="earth">Earth</SelectItem>
                    <SelectItem value="wind">Wind</SelectItem>
                  </SelectContent>
                </Select>
                
                <div className="mt-8">
                  <h4 className="text-md font-semibold mb-3">Required Materials:</h4>
                  <div className="flex justify-between items-center p-3 bg-[#1A1A2E] rounded border border-[#432874]/20">
                    <div className="flex items-center">
                      <div className="w-8 h-8 rounded-full bg-purple-800/50 flex items-center justify-center mr-3">
                        <span className="text-purple-300">E</span>
                      </div>
                      <span>Essence</span>
                    </div>
                    <div className="flex flex-col items-end">
                      <span className="text-sm">500</span>
                      <span className="text-xs text-[#C8B8DB]/60">
                        You have: {resources.find(r => r.name === 'Essence')?.quantity || 0}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
              
              {/* Right side: Crafting summary */}
              <div className="bg-[#15152C] rounded-lg border border-[#432874]/20 p-4">
                <h3 className="text-lg font-semibold mb-4">Crafting Summary</h3>
                
                <div className="mb-6">
                  <div className="flex items-center mb-2">
                    <div className={`w-3 h-3 rounded-full mr-2 ${selectedElement 
                      ? selectedElement === 'fire' ? 'bg-red-500' 
                      : selectedElement === 'water' ? 'bg-blue-500'
                      : selectedElement === 'earth' ? 'bg-green-500' 
                      : selectedElement === 'wind' ? 'bg-cyan-500'
                      : 'bg-gray-500'
                      : 'bg-gray-500'}`} 
                    />
                    <span className="capitalize">
                      {selectedElement || 'No element selected'}
                    </span>
                  </div>
                  
                  <p className="text-sm text-[#C8B8DB]/70">
                    Crafting a new Aura with random stat multipliers.
                  </p>
                </div>
                
                <div className="mb-6">
                  <h4 className="text-md font-semibold mb-2">Crafting Time:</h4>
                  <div className="flex items-center text-[#C8B8DB]/80">
                    <Clock className="h-4 w-4 mr-2" />
                    <span>5 minutes</span>
                  </div>
                </div>
                
                <div className="mb-6">
                  <h4 className="text-md font-semibold mb-2">Forge Capacity:</h4>
                  <div className="text-sm">
                    <div className="flex justify-between mb-1">
                      <span>Active Tasks:</span>
                      <span className={activeForgingTasks.length >= maxCraftingSlots ? 'text-red-400' : 'text-green-400'}>
                        {activeForgingTasks.length} / {maxCraftingSlots}
                      </span>
                    </div>
                    <p className="text-xs text-[#C8B8DB]/60">
                      {isAdmin 
                        ? "Admin buff: Unlimited crafting slots available!" 
                        : "Upgrade your Forge building to increase capacity."}
                    </p>
                  </div>
                </div>
                
                <Button 
                  className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                  onClick={startCrafting}
                  disabled={
                    isSubmitting || 
                    !selectedElement || 
                    !selectedCharacterId ||
                    activeForgingTasks.length >= maxCraftingSlots
                  }
                >
                  <Hammer className="h-4 w-4 mr-2" />
                  {isSubmitting ? 'Starting...' : 'Start Crafting'}
                </Button>
              </div>
            </div>
          </TabsContent>
          
          {/* Fusion Interface */}
          <TabsContent value="fusion" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Left side: Character & Aura selection */}
              <div className="bg-[#15152C] rounded-lg border border-[#432874]/20 p-4">
                <h3 className="text-lg font-semibold mb-4">Choose Auras to Fuse</h3>
                
                {/* Character Selection for Fusion */}
                <div className="mb-6">
                  <h4 className="text-md font-semibold mb-3 flex items-center">
                    Assign Character
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <span className="ml-2 cursor-help">
                            <Info className="h-4 w-4 text-[#C8B8DB]/60" />
                          </span>
                        </TooltipTrigger>
                        <TooltipContent className="max-w-sm">
                          <p>You must assign a character to perform the fusion process. This character will be unavailable for other tasks until fusion is complete.</p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                  </h4>
                  
                  {availableCharacters.length > 0 ? (
                    <Select 
                      value={selectedCharacterId ? String(selectedCharacterId) : ""} 
                      onValueChange={(value) => setSelectedCharacterId(Number(value))}
                    >
                      <SelectTrigger className="bg-[#1A1A2E] border-[#432874]/30">
                        <SelectValue placeholder="Select a character" />
                      </SelectTrigger>
                      <SelectContent>
                        {availableCharacters.map(character => (
                          <SelectItem key={character.id} value={String(character.id)}>
                            {character.name} (Lvl {character.level} {character.class})
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <div className="text-sm text-amber-400 py-2 px-4 bg-amber-950/20 border border-amber-900/30 rounded-md">
                      <span className="flex items-center">
                        <Info className="h-4 w-4 mr-2" />
                        All characters are currently busy. Wait for them to complete their tasks.
                      </span>
                    </div>
                  )}
                </div>
                
                <div className="mb-6">
                  <h4 className="text-md font-semibold mb-3">Primary Aura:</h4>
                  <div className="grid grid-cols-1 gap-3 max-h-[200px] overflow-y-auto">
                    {availableAuras.length === 0 ? (
                      <div className="text-center py-4 text-[#C8B8DB]/70">
                        No available auras to use as primary.
                      </div>
                    ) : (
                      availableAuras.map(aura => (
                        <div 
                          key={`primary-${aura.id}`}
                          className={`p-3 rounded border ${primaryAura?.id === aura.id 
                            ? 'bg-[#432874]/30 border-[#432874]' 
                            : 'bg-[#1A1A2E] border-[#432874]/20 hover:border-[#432874]/40 cursor-pointer'
                          }`}
                          onClick={() => setPrimaryAura(aura)}
                        >
                          <div className="flex justify-between items-center">
                            <div className="flex items-center">
                              <div className={`w-8 h-8 rounded-full flex items-center justify-center mr-3 ${
                                aura.element === 'fire' ? 'bg-red-500/30 text-red-300' 
                                : aura.element === 'water' ? 'bg-blue-500/30 text-blue-300'
                                : aura.element === 'earth' ? 'bg-green-500/30 text-green-300' 
                                : aura.element === 'wind' ? 'bg-cyan-500/30 text-cyan-300'
                                : 'bg-purple-500/30 text-purple-300'
                              }`}>
                                {aura.element?.charAt(0).toUpperCase()}
                              </div>
                              <div>
                                <h4 className="font-medium capitalize">
                                  {aura.name || `${aura.element} Aura`}
                                </h4>
                                <Badge className='bg-purple-700/30 text-purple-300 border-purple-600/30'>
                                  Level {aura.level}
                                </Badge>
                              </div>
                            </div>
                          </div>
                          <p className="text-sm text-[#C8B8DB]/70 mt-1">
                            {aura.attack ? `Attack: ${aura.attack > 0 ? '+' : ''}${aura.attack}% ` : ''}
                            {aura.accuracy ? `Accuracy: ${aura.accuracy > 0 ? '+' : ''}${aura.accuracy}% ` : ''}
                            {aura.defense ? `Defense: ${aura.defense > 0 ? '+' : ''}${aura.defense}% ` : ''}
                            {aura.vitality ? `Vitality: ${aura.vitality > 0 ? '+' : ''}${aura.vitality}% ` : ''}
                            {aura.speed ? `Speed: ${aura.speed > 0 ? '+' : ''}${aura.speed}% ` : ''}
                            {aura.focus ? `Focus: ${aura.focus > 0 ? '+' : ''}${aura.focus}% ` : ''}
                            {aura.resilience ? `Resilience: ${aura.resilience > 0 ? '+' : ''}${aura.resilience}% ` : ''}
                          </p>
                        </div>
                      ))
                    )}
                  </div>
                </div>
                
                <div>
                  <h4 className="text-md font-semibold mb-3">Secondary Aura:</h4>
                  <div className="grid grid-cols-1 gap-3 max-h-[200px] overflow-y-auto">
                    {availableAuras.filter(a => a.id !== primaryAura?.id).length === 0 ? (
                      <div className="text-center py-4 text-[#C8B8DB]/70">
                        No available auras to use as secondary.
                      </div>
                    ) : (
                      availableAuras
                        .filter(a => a.id !== primaryAura?.id)
                        .map(aura => (
                          <div 
                            key={`secondary-${aura.id}`}
                            className={`p-3 rounded border ${secondaryAura?.id === aura.id 
                              ? 'bg-[#432874]/30 border-[#432874]' 
                              : 'bg-[#1A1A2E] border-[#432874]/20 hover:border-[#432874]/40 cursor-pointer'
                            }`}
                            onClick={() => setSecondaryAura(aura)}
                          >
                            <div className="flex justify-between items-center">
                              <div className="flex items-center">
                                <div className={`w-8 h-8 rounded-full flex items-center justify-center mr-3 ${
                                  aura.element === 'fire' ? 'bg-red-500/30 text-red-300' 
                                  : aura.element === 'water' ? 'bg-blue-500/30 text-blue-300'
                                  : aura.element === 'earth' ? 'bg-green-500/30 text-green-300' 
                                  : aura.element === 'wind' ? 'bg-cyan-500/30 text-cyan-300'
                                  : 'bg-purple-500/30 text-purple-300'
                                }`}>
                                  {aura.element?.charAt(0).toUpperCase()}
                                </div>
                                <div>
                                  <h4 className="font-medium capitalize">
                                    {aura.name || `${aura.element} Aura`}
                                  </h4>
                                  <Badge className='bg-purple-700/30 text-purple-300 border-purple-600/30'>
                                    Level {aura.level}
                                  </Badge>
                                </div>
                              </div>
                            </div>
                            <p className="text-sm text-[#C8B8DB]/70 mt-1">
                              {aura.attack ? `Attack: ${aura.attack > 0 ? '+' : ''}${aura.attack}% ` : ''}
                              {aura.accuracy ? `Accuracy: ${aura.accuracy > 0 ? '+' : ''}${aura.accuracy}% ` : ''}
                              {aura.defense ? `Defense: ${aura.defense > 0 ? '+' : ''}${aura.defense}% ` : ''}
                              {aura.vitality ? `Vitality: ${aura.vitality > 0 ? '+' : ''}${aura.vitality}% ` : ''}
                              {aura.speed ? `Speed: ${aura.speed > 0 ? '+' : ''}${aura.speed}% ` : ''}
                              {aura.focus ? `Focus: ${aura.focus > 0 ? '+' : ''}${aura.focus}% ` : ''}
                              {aura.resilience ? `Resilience: ${aura.resilience > 0 ? '+' : ''}${aura.resilience}% ` : ''}
                            </p>
                          </div>
                        ))
                    )}
                  </div>
                </div>
              </div>
              
              {/* Right side: Fusion summary */}
              <div className="bg-[#15152C] rounded-lg border border-[#432874]/20 p-4">
                <h3 className="text-lg font-semibold mb-4">Fusion Summary</h3>
                
                {primaryAura && secondaryAura ? (
                  <>
                    <div className="bg-[#1A1A2E] rounded-lg border border-[#432874]/30 p-4 mb-6">
                      <h4 className="text-md font-semibold mb-2">Result Preview:</h4>
                      <div className="flex items-center mb-3">
                        <div className={`w-6 h-6 rounded-full flex items-center justify-center mr-2 ${
                          primaryAura.element === 'fire' ? 'bg-red-500/30 text-red-300' 
                          : primaryAura.element === 'water' ? 'bg-blue-500/30 text-blue-300'
                          : primaryAura.element === 'earth' ? 'bg-green-500/30 text-green-300' 
                          : primaryAura.element === 'wind' ? 'bg-cyan-500/30 text-cyan-300'
                          : 'bg-purple-500/30 text-purple-300'
                        }`}>
                          {primaryAura.element?.charAt(0).toUpperCase()}
                        </div>
                        <span className="capitalize">
                          Enhanced {primaryAura.element} Aura
                        </span>
                        <Badge className="ml-2 bg-purple-700/30 text-purple-300 border-purple-600/30">
                          Level {(primaryAura.level || 1) + 1}
                        </Badge>
                      </div>
                      
                      <p className="text-sm text-[#C8B8DB]/80 mb-3">
                        Fusion will create an enhanced version of the primary aura with improved stats.
                      </p>
                      
                      <div className="text-xs text-[#C8B8DB]/70">
                        <div className="grid grid-cols-2 gap-1">
                          <div> Primary element retained</div>
                          <div> Level increased by 1</div>
                          <div> Stats enhanced by ~20%</div>
                          <div> Secondary aura consumed</div>
                        </div>
                      </div>
                    </div>
                    
                    <div className="mb-6">
                      <h4 className="text-md font-semibold mb-2">Fusion Time:</h4>
                      <div className="flex items-center text-[#C8B8DB]/80">
                        <Clock className="h-4 w-4 mr-2" />
                        <span>10 minutes</span>
                      </div>
                    </div>
                    
                    <div className="mb-6">
                      <h4 className="text-md font-semibold mb-2">Forge Capacity:</h4>
                      <div className="text-sm">
                        <div className="flex justify-between mb-1">
                          <span>Active Tasks:</span>
                          <span className={activeForgingTasks.length >= maxCraftingSlots ? 'text-red-400' : 'text-green-400'}>
                            {activeForgingTasks.length} / {maxCraftingSlots}
                          </span>
                        </div>
                        <p className="text-xs text-[#C8B8DB]/60">
                          {isAdmin 
                            ? "Admin buff: Unlimited crafting slots available!" 
                            : "Upgrade your Forge building to increase capacity."}
                        </p>
                      </div>
                    </div>
                    
                    <Button 
                      className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                      onClick={() => {
                        if (!selectedCharacterId) {
                          toast({
                            title: "Character Required",
                            description: "Please select a character to assist with fusion.",
                            variant: "destructive"
                          });
                          return;
                        }
                        console.log("Fusion not yet implemented");
                        toast({
                          title: "Feature Coming Soon",
                          description: "Fusion functionality will be available in a future update.",
                        });
                      }}
                      disabled={!selectedCharacterId || true} // Keep 'true' until fusion is implemented
                    >
                      <Flame className="h-4 w-4 mr-2" />
                      Fusion Coming Soon
                    </Button>
                  </>
                ) : (
                  <div className="text-center py-8 text-[#C8B8DB]/70">
                    Select two auras to see fusion details
                  </div>
                )}
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </div>

      {/* Forge Result Dialog */}
      <Dialog 
        open={showResultDialog} 
        onOpenChange={(open) => {
          // Only allow closing via the Close button, not by clicking outside
          if (!open) {
            // Do nothing - prevent automatic closing
            return;
          }
          setShowResultDialog(open);
        }}
      >
        <DialogContent className="bg-[#1A1A2E] border-[#432874] max-w-2xl" onEscapeKeyDown={(e) => e.preventDefault()}>
          <DialogHeader>
            <DialogTitle className="text-2xl font-cinzel text-[#FF9D00]">
              Forging Complete!
            </DialogTitle>
          </DialogHeader>
          
          {completedAura && (
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                <div className={`w-16 h-16 rounded-full flex items-center justify-center ${
                  completedAura.element === 'fire' ? 'bg-red-500/30 text-red-300' 
                  : completedAura.element === 'water' ? 'bg-blue-500/30 text-blue-300'
                  : completedAura.element === 'earth' ? 'bg-green-500/30 text-green-300' 
                  : completedAura.element === 'wind' ? 'bg-cyan-500/30 text-cyan-300'
                  : 'bg-purple-500/30 text-purple-300'
                }`}>
                  <span className="text-2xl">{completedAura.element?.charAt(0).toUpperCase()}</span>
                </div>
                <div>
                  <h3 className="text-xl font-semibold capitalize">
                    {completedAura.name || `${completedAura.element} Aura`}
                  </h3>
                  <div className="flex gap-2">
                    <Badge className="bg-purple-700/30 text-purple-300 border-purple-600/30">
                      Level {completedAura.level}
                    </Badge>
                    <Badge className="bg-[#432874]/30 text-[#C8B8DB]">
                      {completedAura.tier ? `Tier ${completedAura.tier}` : 'Basic Tier'}
                    </Badge>
                  </div>
                </div>
              </div>

              <div className="bg-[#432874]/20 rounded-lg p-4">
                <h4 className="font-semibold mb-2">Stat Multipliers</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-[#C8B8DB]">
                  {completedAura.attack && (
                    <div>Attack: <span className="text-[#FF9D00]">+{completedAura.attack}%</span></div>
                  )}
                  {completedAura.defense && (
                    <div>Defense: <span className="text-[#FF9D00]">+{completedAura.defense}%</span></div>
                  )}
                  {completedAura.vitality && (
                    <div>Vitality: <span className="text-[#FF9D00]">+{completedAura.vitality}%</span></div>
                  )}
                  {completedAura.speed && (
                    <div>Speed: <span className="text-[#FF9D00]">+{completedAura.speed}%</span></div>
                  )}
                  {completedAura.accuracy && (
                    <div>Accuracy: <span className="text-[#FF9D00]">+{completedAura.accuracy}%</span></div>
                  )}
                  {completedAura.focus && (
                    <div>Focus: <span className="text-[#FF9D00]">+{completedAura.focus}%</span></div>
                  )}
                  {completedAura.resilience && (
                    <div>Resilience: <span className="text-[#FF9D00]">+{completedAura.resilience}%</span></div>
                  )}
                </div>
                <div className="mt-3 pt-3 border-t border-[#432874]/30">
                  <div className="text-sm font-semibold">Total Stat Value</div>
                  <div className="text-[#FF9D00] text-lg">
                    +{(completedAura.attack || 0) + 
                       (completedAura.defense || 0) + 
                       (completedAura.vitality || 0) + 
                       (completedAura.speed || 0) + 
                       (completedAura.accuracy || 0) + 
                       (completedAura.focus || 0) + 
                       (completedAura.resilience || 0)}%
                  </div>
                </div>
              </div>

              {completedAura.skills && completedAura.skills.length > 0 && (
                <div className="bg-[#432874]/20 rounded-lg p-4">
                  <h4 className="font-semibold mb-2">Skills</h4>
                  <div className="space-y-3">
                    {completedAura.skills.map((skill: any, index: number) => (
                      <div key={index} className="border border-[#432874]/40 rounded p-3">
                        <div className="flex justify-between items-start mb-2">
                          <div>
                            <div className="font-medium text-[#FF9D00]">{skill.name}</div>
                            <div className="text-xs text-[#C8B8DB]/60">{skill.type} Skill</div>
                          </div>
                          <Badge className={
                            skill.type === 'Basic' ? 'bg-blue-500/20 text-blue-300' :
                            skill.type === 'Advanced' ? 'bg-purple-500/20 text-purple-300' :
                            'bg-amber-500/20 text-amber-300'
                          }>
                            Level {skill.level}
                          </Badge>
                        </div>
                        <div className="text-sm text-[#C8B8DB]/80">{skill.description}</div>
                        <div className="mt-2 space-y-1 text-xs">
                          {skill.damage && (
                            <div className="text-red-400">Base Damage: {skill.damage}x</div>
                          )}
                          {skill.effect && (
                            <div className="text-emerald-400">{skill.effect}</div>
                          )}
                          {skill.targets && (
                            <div className="text-blue-400">Targets: {skill.targets}</div>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Description section removed as it's not in the schema */}

              {/* No duplicate skills section needed */}
            </div>
          )}
          
          <DialogFooter className="flex flex-col sm:flex-row gap-2">
            <div className="text-sm text-[#C8B8DB]/60 mb-2 sm:mb-0 sm:mr-auto">
              Click the button below to close this dialog
            </div>
            <Button 
              onClick={() => setShowResultDialog(false)}
              className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E] font-semibold px-6 py-2 text-base"
            >
              Close Dialog
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ForgeView;


=== client/src/components/blackmarket/BlackMarketView.tsx ===
import { useState } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle,
  DialogDescription,
  DialogFooter
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  ShoppingBag, 
  Coins, 
  Clock, 
  Sparkles, 
  Users, 
  Shield, 
  Gem, 
  AlertTriangle,
  Lock,
  Scroll,
  CheckCircle2
} from 'lucide-react';

import type { BlackMarketListing } from '@shared/schema';

const BlackMarketView = () => {
  const { user, fetchUser } = useDiscordAuth();
  const { fetchResources, fetchCharacters, fetchAuras } = useGameStore();
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [confirmDialog, setConfirmDialog] = useState<{open: boolean, listing: BlackMarketListing | null}>({
    open: false,
    listing: null
  });
  
  // Fetch user's Black Market level
  const blackMarketLevel = user?.blackMarketLevel || 1;
  const maxItemsPerCategory = blackMarketLevel < 3 ? (blackMarketLevel + 2) : 6; // 3 slots at level 1, 4 at level 2, etc.
  const [showUpgradeDialog, setShowUpgradeDialog] = useState(false);
  
  // Fetch black market listings
  const { data: listings = [], isLoading, refetch: refetchListings } = useQuery<BlackMarketListing[]>({ 
    queryKey: ['/api/blackmarket/listings'],
    refetchInterval: 60000 // Refresh every minute
  });

  // Filter listings by different categories
  const premiumListings = listings.filter(listing => 
    (listing.isPremium === true || listing.currencyType === 'forgeTokens') && !listing.sold
  ).slice(0, maxItemsPerCategory);
  
  const standardListings = listings.filter(listing => 
    listing.currencyType === 'rogueCredits' && !listing.isPremium && !listing.sold
  ).slice(0, maxItemsPerCategory);
  
  // Add placeholder slots to show locked slots
  const addLockedSlots = (listings: BlackMarketListing[], count: number) => {
    const result = [...listings];
    // Add one more slot than current capacity, showing the "next" locked slot
    if (result.length < maxItemsPerCategory + 1) {
      const placeholdersNeeded = maxItemsPerCategory + 1 - result.length;
      for (let i = 0; i < placeholdersNeeded; i++) {
        result.push({
          id: `placeholder-${i}`,
          itemType: 'placeholder',
          itemData: { name: 'Locked Slot' },
          price: 0,
          currencyType: 'rogueCredits',
          sold: false,
          isPlaceholder: true
        } as any);
      }
    }
    return result;
  };
  
  const premiumListingsWithPlaceholders = addLockedSlots(premiumListings, maxItemsPerCategory + 1);
  const standardListingsWithPlaceholders = addLockedSlots(standardListings, maxItemsPerCategory + 1);

  // Generate time until refresh
  const getTimeUntilRefresh = () => {
    const now = new Date();
    const tomorrow = new Date();
    tomorrow.setHours(24, 0, 0, 0);
    
    const diffMs = tomorrow.getTime() - now.getTime();
    const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    return `${diffHrs}h ${diffMins}m`;
  };

  const handlePurchase = async (listing: BlackMarketListing) => {
    setIsSubmitting(true);
    try {
      const response = await apiRequest('POST', `/api/blackmarket/buy/${listing.id}`, undefined);
      const data = await response.json();
      
      toast({
        title: "Purchase Successful!",
        description: `You have acquired a new ${listing.itemType}.`,
      });
      
      // Refresh data
      fetchUser();
      refetchListings();
      
      // Refresh related collections based on purchased item type
      if (listing.itemType === 'character') {
        fetchCharacters();
      } else if (listing.itemType === 'aura') {
        fetchAuras();
      } else if (listing.itemType === 'resource') {
        fetchResources();
      }
      
      setConfirmDialog({ open: false, listing: null });
    } catch (error) {
      console.error('Purchase error:', error);
      toast({
        title: "Purchase Failed",
        description: "You may not have enough currency or the item is no longer available.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Stock images for items based on their types and rarity/element
  const stockImages = {
    character: {
      warrior: "https://i.imgur.com/eYhqUWb.jpg", // Knight with armor
      mage: "https://i.imgur.com/uEyo0gB.jpg", // Mage casting spell
      rogue: "https://i.imgur.com/9xEcTOx.jpg", // Rogue with daggers
      archer: "https://i.imgur.com/pK2uFQG.jpg", // Archer with bow
      healer: "https://i.imgur.com/STy2tX0.jpg", // Healer with staff
      default: "https://i.imgur.com/jlQM1tJ.jpg" // Generic fantasy character
    },
    aura: {
      fire: "https://i.imgur.com/zZFXEfS.jpg", // Fire element
      water: "https://i.imgur.com/HlVLv7M.jpg", // Water element
      earth: "https://i.imgur.com/EkuS2Iy.jpg", // Earth element
      air: "https://i.imgur.com/JA4a3kY.jpg", // Air element
      light: "https://i.imgur.com/0bKk5n9.jpg", // Light element
      dark: "https://i.imgur.com/rCQjyfY.jpg", // Dark element
      default: "https://i.imgur.com/sBsT4s3.jpg" // Generic magic aura
    },
    resource: {
      crystal: "https://i.imgur.com/fv7qOVB.jpg", // Magical crystals
      herb: "https://i.imgur.com/Z5YZEBS.jpg", // Herbs and plants
      metal: "https://i.imgur.com/gPlqXH4.jpg", // Metal ores and ingots
      gem: "https://i.imgur.com/6O1Usyw.jpg", // Gemstones
      wood: "https://i.imgur.com/B2v8XDM.jpg", // Rare woods
      default: "https://i.imgur.com/RHszhSh.jpg" // Generic resource pile
    },
    default: "https://i.imgur.com/sBsT4s3.jpg" // Fallback image
  };

  const getItemInfo = (listing: BlackMarketListing) => {
    if (!listing) return {
      title: 'Unknown Item',
      description: 'Item details unavailable',
      detailLines: [],
      image: stockImages.default
    };
    
    const itemData = listing.itemData as any;
    
    switch (listing.itemType) {
      case 'character':
        // Determine character class for appropriate image
        let characterClass = (itemData?.class || '').toLowerCase();
        let characterImageKey = stockImages.character[characterClass as keyof typeof stockImages.character] 
          ? characterClass : 'default';
          
        return {
          title: itemData?.name || 'Mystery Character',
          description: `${itemData?.rarity || 'Unknown'} ${itemData?.class || 'Character'} - Level ${itemData?.level || '?'}`,
          detailLines: [
            itemData?.stats ? `STR: ${itemData.stats.strength || 0} | AGI: ${itemData.stats.agility || 0}` : '',
            itemData?.stats ? `INT: ${itemData.stats.intelligence || 0} | VIT: ${itemData.stats.vitality || 0}` : '',
            itemData?.passiveSkills?.length > 0 ? `Skills: ${itemData.passiveSkills.map((s: any) => s.name).join(', ')}` : 'No special skills'
          ],
          image: itemData?.avatarUrl || stockImages.character[characterImageKey as keyof typeof stockImages.character]
        };
        
      case 'aura':
        // Determine aura element for appropriate image
        let auraElement = (itemData?.element || '').toLowerCase();
        let auraImageKey = stockImages.aura[auraElement as keyof typeof stockImages.aura] 
          ? auraElement : 'default';
          
        return {
          title: itemData?.name || 'Mystery Aura',
          description: `${itemData?.element || 'Unknown'} Element - Level ${itemData?.level || '?'}`,
          detailLines: [
            itemData?.statMultipliers ? `Multipliers: STR ${itemData.statMultipliers.strength?.toFixed(1) || '1.0'}, AGI ${itemData.statMultipliers.agility?.toFixed(1) || '1.0'}` : '',
            itemData?.statMultipliers ? `INT ${itemData.statMultipliers.intelligence?.toFixed(1) || '1.0'}, VIT ${itemData.statMultipliers.vitality?.toFixed(1) || '1.0'}` : '',
            itemData?.skills?.length > 0 ? `Skills: ${itemData.skills.map((s: any) => s.name).join(', ')}` : 'No skills'
          ],
          image: stockImages.aura[auraImageKey as keyof typeof stockImages.aura]
        };
        
      case 'resource':
        // Determine resource type for appropriate image
        let resourceType = (itemData?.type || '').toLowerCase();
        let resourceImageKey = stockImages.resource[resourceType as keyof typeof stockImages.resource] 
          ? resourceType : 'default';
          
        return {
          title: itemData?.name || 'Rare Materials',
          description: `${itemData?.quantity || '?'} ${itemData?.type || 'material'} units`,
          detailLines: [
            itemData?.description || 'Valuable crafting resource'
          ],
          image: itemData?.iconUrl || stockImages.resource[resourceImageKey as keyof typeof stockImages.resource]
        };
        
      default:
        return {
          title: 'Market Item',
          description: 'A valuable item for your collection',
          detailLines: ['Unknown item details'],
          image: stockImages.default
        };
    }
  };

  const getCurrencyIcon = (currencyType: string) => {
    if (currencyType === 'forgeTokens') {
      return "https://i.imgur.com/fv7qOVB.jpg"; // Forge tokens
    } else {
      return "https://i.imgur.com/6O1Usyw.jpg"; // Rogue credits
    }
  };

  const canAfford = (listing: BlackMarketListing) => {
    if (!user) return false;
    
    if (listing.currencyType === 'forgeTokens') {
      return (user.forgeTokens || 0) >= listing.price;
    } else {
      return (user.rogueCredits || 0) >= listing.price;
    }
  };

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl animate-pulse">Loading market data...</div>
      </div>
    );
  }

  return (
    <>
      {/* Black Market Upgrade Dialog */}
      <Dialog open={showUpgradeDialog} onOpenChange={setShowUpgradeDialog}>
        <DialogContent className="bg-[#1A1A2E] border-[#432874]/50 text-[#C8B8DB] max-w-4xl">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Upgrade Black Market</DialogTitle>
            <DialogDescription className="text-[#C8B8DB]/80">
              Upgrade your Black Market to unlock better items, more slots, and exclusive deals.
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            {/* Timeline UI for upgrade path */}
            <div className="relative mb-8 pt-6">
              {/* Progress line */}
              <div className="absolute left-0 right-0 top-1/2 h-1 bg-[#432874]/30 -translate-y-1/2 z-0"></div>
              
              {/* Timeline nodes */}
              <div className="relative z-10 flex justify-between">
                {/* Define the upgrade tiers with themed names */}
                {[
                  { level: 1, name: "Street Stall", icon: <ShoppingBag />, unlocks: "Basic marketplace" },
                  { level: 2, name: "Shadow Bazaar", icon: <Users />, unlocks: "+1 slot per category" },
                  { level: 3, name: "Twilight Exchange", icon: <Gem />, unlocks: "Rare item availability" },
                  { level: 4, name: "Phantom Emporium", icon: <Scroll />, unlocks: "Improved refresh rates" },
                  { level: 5, name: "Rogue's Gallery", icon: <Shield />, unlocks: "Epic item availability" },
                  { level: 6, name: "Syndicate Nexus", icon: <Sparkles />, unlocks: "Premium discounts" },
                  { level: 7, name: "Void Market", icon: <AlertTriangle />, unlocks: "Mythic item availability" }
                ].map((tier, index) => (
                  <div
                    key={tier.level}
                    className={`flex flex-col items-center w-16 group ${
                      tier.level <= blackMarketLevel ? 'cursor-default' : 'opacity-80'
                    }`}
                  >
                    {/* Timeline node */}
                    <div 
                      className={`w-10 h-10 rounded-full flex items-center justify-center mb-2 relative ${
                        tier.level === blackMarketLevel 
                          ? 'bg-[#FF9D00] text-[#1A1A2E]' 
                          : tier.level < blackMarketLevel 
                            ? 'bg-[#00B9AE] text-[#1A1A2E]' 
                            : 'bg-[#432874]/40 text-[#C8B8DB]/70'
                      }`}
                    >
                      {tier.level <= blackMarketLevel + 2 ? (
                        tier.icon
                      ) : (
                        <Lock className="w-5 h-5" />
                      )}
                      {tier.level === blackMarketLevel && (
                        <div className="absolute -top-1 -right-1 w-4 h-4 bg-[#FF9D00] rounded-full border-2 border-[#1A1A2E] animate-pulse"></div>
                      )}
                    </div>
                    
                    {/* Label with rotation for space efficiency */}
                    <div className={`text-xs font-medium ${
                      tier.level === blackMarketLevel 
                        ? 'text-[#FF9D00]' 
                        : tier.level < blackMarketLevel 
                          ? 'text-[#00B9AE]' 
                          : 'text-[#C8B8DB]/70'
                    }`}>
                      {tier.level <= blackMarketLevel + 2 ? (
                        <>Level {tier.level}</>
                      ) : (
                        <>???</>
                      )}
                    </div>
                    
                    {/* Detailed tooltip on hover */}
                    <div className="absolute bottom-full mb-2 w-48 bg-[#1F1D36] rounded-md p-2 border border-[#432874]/50 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-20">
                      <h5 className={`font-semibold text-sm ${
                        tier.level === blackMarketLevel 
                          ? 'text-[#FF9D00]' 
                          : tier.level < blackMarketLevel 
                            ? 'text-[#00B9AE]' 
                            : 'text-[#C8B8DB]'
                      }`}>
                        {tier.level <= blackMarketLevel + 2 ? tier.name : "Unknown Tier"}
                      </h5>
                      <p className="text-xs text-[#C8B8DB]/80 mt-1">
                        {tier.level <= blackMarketLevel + 2 ? tier.unlocks : "Mysteries yet to be uncovered"}
                      </p>
                      {tier.level === blackMarketLevel && (
                        <div className="mt-1 text-xs text-[#FF9D00]">Current Level</div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
            
            <div className="flex justify-between items-start mb-6">
              <div>
                <h4 className="font-semibold text-lg">Current Level: {blackMarketLevel}</h4>
                <p className="text-sm text-[#C8B8DB]/70">
                  {blackMarketLevel === 1 ? "Street Stall" : 
                   blackMarketLevel === 2 ? "Shadow Bazaar" :
                   blackMarketLevel === 3 ? "Twilight Exchange" :
                   blackMarketLevel === 4 ? "Phantom Emporium" :
                   blackMarketLevel === 5 ? "Rogue's Gallery" :
                   blackMarketLevel === 6 ? "Syndicate Nexus" : "Void Market"}
                </p>
              </div>
              <div className="bg-[#432874]/30 px-3 py-1 rounded">
                <span className="text-[#FF9D00] font-semibold">Lv.{blackMarketLevel}</span>
              </div>
            </div>
            
            {/* Detailed view of next upgrade */}
            <div className="grid grid-cols-2 gap-4">
              <div className="bg-[#15152C] p-4 rounded-md">
                <h4 className="font-semibold mb-3 flex items-center">
                  <Scroll className="h-4 w-4 text-[#00B9AE] mr-2" />
                  Required Materials
                </h4>
                <div className="space-y-3">
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="w-8 h-8 rounded-full bg-[#432874]/30 flex items-center justify-center mr-2">
                        <Scroll className="h-4 w-4 text-[#00B9AE]" />
                      </div>
                      <span>Market Expansion Plans</span>
                    </div>
                    <Badge className="bg-[#15152C] border-[#432874]">
                      {blackMarketLevel * 2} pcs
                    </Badge>
                  </div>
                  
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="w-8 h-8 rounded-full bg-[#432874]/30 flex items-center justify-center mr-2">
                        <span className="text-[#FF9D00] text-xs">RC</span>
                      </div>
                      <span>Rogue Credits</span>
                    </div>
                    <Badge className="bg-[#15152C] border-[#432874]">
                      {blackMarketLevel * 1000}
                    </Badge>
                  </div>
                  
                  {blackMarketLevel >= 3 && (
                    <div className="flex justify-between items-center">
                      <div className="flex items-center">
                        <div className="w-8 h-8 rounded-full bg-[#432874]/30 flex items-center justify-center mr-2">
                          <Gem className="h-4 w-4 text-purple-400" />
                        </div>
                        <span>Soul Shards</span>
                      </div>
                      <Badge className="bg-[#15152C] border-[#432874]">
                        {blackMarketLevel * 5}
                      </Badge>
                    </div>
                  )}
                </div>
              </div>
              
              <div className="bg-[#15152C] p-4 rounded-md">
                <h4 className="font-semibold mb-3 flex items-center">
                  <Sparkles className="h-4 w-4 text-[#FF9D00] mr-2" />
                  Unlocks at Level {blackMarketLevel + 1}
                </h4>
                <div className="space-y-3 text-sm">
                  <div className="flex items-center">
                    <CheckCircle2 className="h-4 w-4 text-[#00B9AE] mr-2 flex-shrink-0" />
                    <div>
                      <div className="font-medium">+1 Item Slot per Category</div>
                      <div className="text-xs text-[#C8B8DB]/70">More items will be available in each refresh</div>
                    </div>
                  </div>
                  
                  <div className="flex items-center">
                    <CheckCircle2 className="h-4 w-4 text-[#00B9AE] mr-2 flex-shrink-0" />
                    <div>
                      <div className="font-medium">
                        {blackMarketLevel + 1 === 3 ? "Rare Item Availability" : 
                         blackMarketLevel + 1 === 5 ? "Epic Item Availability" :
                         blackMarketLevel + 1 === 7 ? "Mythic Item Availability" :
                         "Better Price Offerings"}
                      </div>
                      <div className="text-xs text-[#C8B8DB]/70">
                        {blackMarketLevel + 1 === 3 ? "Uncommon and rare quality items will appear" : 
                         blackMarketLevel + 1 === 5 ? "Epic quality items will start to appear" :
                         blackMarketLevel + 1 === 7 ? "Mythic quality items may rarely appear" :
                         "Items will be available at better prices"}
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center">
                    <CheckCircle2 className="h-4 w-4 text-[#00B9AE] mr-2 flex-shrink-0" />
                    <div>
                      <div className="font-medium">Improved Market Connections</div>
                      <div className="text-xs text-[#C8B8DB]/70">
                        Faster refresh rates and better merchant relations
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <DialogFooter className="flex justify-between items-center">
            <Button variant="outline" onClick={() => setShowUpgradeDialog(false)}>
              Cancel
            </Button>
            <Button 
              className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
              onClick={() => {
                toast({
                  title: "Coming Soon",
                  description: "Black Market upgrade functionality will be available in a future update."
                });
                setShowUpgradeDialog(false);
              }}
            >
              <Shield className="h-4 w-4 mr-2" />
              Upgrade
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      <div className="mb-6">
        <div className="flex justify-between items-start">
          <div>
            <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Black Market</h1>
            <p className="text-[#C8B8DB]/80">
              Purchase rare characters, auras, and valuable materials with your currencies.
            </p>
          </div>
          
          {/* Upgrade Button */}
          <Button 
            variant="outline" 
            size="sm" 
            className="border-[#FF9D00]/50 text-[#FF9D00] hover:bg-[#FF9D00]/10"
            onClick={() => setShowUpgradeDialog(true)}
          >
            <Shield className="h-4 w-4 mr-2" />
            Upgrade Market
          </Button>
        </div>
      </div>
      
      {/* Market Header */}
      <div className="bg-gradient-to-r from-[#432874]/60 to-[#1A1A2E] rounded-xl p-6 mb-6 relative overflow-hidden">
        <div className="absolute top-0 right-0 w-64 h-64 bg-[#FF9D00]/10 rounded-full -mr-32 -mt-32 blur-md"></div>
        <div className="absolute -bottom-16 -left-16 w-64 h-64 bg-[#00B9AE]/10 rounded-full blur-md"></div>
        
        <div className="flex flex-col md:flex-row md:justify-between md:items-center relative z-10">
          <div>
            <h2 className="text-2xl font-cinzel font-bold text-[#FF9D00] mb-2">Today's Offerings</h2>
            <div className="flex items-center text-[#C8B8DB]/70">
              <Clock className="h-4 w-4 mr-1" />
              <span>Refreshes in {getTimeUntilRefresh()}</span>
            </div>
            <div className="flex items-center text-[#C8B8DB]/70 mt-2">
              <Shield className="h-4 w-4 mr-1" />
              <span>Black Market Level: {blackMarketLevel} (Slots: {maxItemsPerCategory})</span>
            </div>
          </div>
          
          <div className="flex items-center space-x-4 mt-4 md:mt-0">
            <div className="flex items-center bg-[#1A1A2E]/50 rounded-lg px-3 py-2">
              <img 
                src="https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=250&h=250&fit=crop" 
                alt="Forge Tokens" 
                className="w-6 h-6 rounded-full mr-2"
              />
              <span className="text-[#FFD700]">{user?.forgeTokens || 0}</span>
            </div>
            <div className="flex items-center bg-[#1A1A2E]/50 rounded-lg px-3 py-2">
              <img 
                src="https://images.unsplash.com/photo-1543486958-d783bfbf7f8e?w=250&h=250&fit=crop" 
                alt="Rogue Credits" 
                className="w-6 h-6 rounded-full mr-2"
              />
              <span className="text-[#C8B8DB]">{user?.rogueCredits || 0}</span>
            </div>
          </div>
        </div>
      </div>
      
      {/* Premium Items */}
      <div className="mb-8">
        <div className="flex items-center mb-4">
          <Gem className="h-5 w-5 mr-2 text-[#FF9D00]" />
          <h3 className="text-xl font-cinzel font-bold text-[#FF9D00]">Premium Items</h3>
        </div>
        <motion.div
          variants={container}
          initial="hidden"
          animate="show"
          className="grid gap-6 md:grid-cols-2 lg:grid-cols-3"
        >
          {premiumListingsWithPlaceholders.length === 0 ? (
            <div className="col-span-full bg-[#1A1A2E] rounded-xl p-8 text-center">
              <ShoppingBag className="h-12 w-12 mx-auto mb-4 text-[#C8B8DB]/50" />
              <p className="text-[#C8B8DB]/80 mb-4">
                No premium items are available at the moment. Check back later!
              </p>
            </div>
          ) : (
            premiumListingsWithPlaceholders.map((listing, index) => {
              const itemInfo = getItemInfo(listing);
              const isLocked = index >= blackMarketLevel + 2 || (listing as any).isPlaceholder;
              
              return (
                <motion.div
                  key={listing.id}
                  variants={item}
                  className={`bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden relative ${isLocked ? 'opacity-60' : ''}`}
                >
                  {isLocked && (
                    <div className="absolute inset-0 bg-[#1A1A2E]/60 backdrop-blur-sm z-10 flex flex-col items-center justify-center p-4">
                      <Lock className="h-12 w-12 text-[#432874] mb-4" />
                      <p className="text-center text-[#C8B8DB] font-semibold">
                        Upgrade your Black Market to Level {Math.ceil((index + 1) / 3)} to unlock this slot
                      </p>
                      <Button 
                        variant="outline" 
                        size="sm" 
                        className="mt-4 border-[#FF9D00]/50 text-[#FF9D00] hover:bg-[#FF9D00]/10"
                        onClick={() => setShowUpgradeDialog(true)}
                      >
                        <Shield className="h-4 w-4 mr-2" />
                        Upgrade Market
                      </Button>
                    </div>
                  )}
                  
                  <div className="relative h-40">
                    <img 
                      src={itemInfo.image} 
                      alt={itemInfo.title} 
                      className="w-full h-full object-cover"
                    />
                    <div className="absolute inset-0 bg-gradient-to-t from-[#1A1A2E] to-transparent"></div>
                    <div className="absolute top-2 right-2">
                      <Badge className="bg-[#FFD700]/20 text-[#FFD700] border-[#FFD700]/30">
                        Premium
                      </Badge>
                    </div>
                    <div className="absolute bottom-0 left-0 right-0 p-4">
                      <h3 className="text-xl font-cinzel font-bold text-[#FF9D00]">{itemInfo.title}</h3>
                      <p className="text-sm text-[#C8B8DB]/80">{itemInfo.description}</p>
                    </div>
                  </div>
                  
                  <div className="p-4">
                    {/* Item details section */}
                    {itemInfo.detailLines && itemInfo.detailLines.length > 0 && (
                      <div className="mb-3 text-xs text-[#C8B8DB]/80 bg-[#1A1A2E]/80 rounded p-2 border border-[#432874]/20">
                        {itemInfo.detailLines.map((line, index) => 
                          line ? <div key={index} className="mb-1">{line}</div> : null
                        )}
                      </div>
                    )}
                    
                    <div className="flex justify-between items-center mb-4">
                      <div className="flex items-center">
                        <img 
                          src={getCurrencyIcon(listing.currencyType)} 
                          alt={listing.currencyType} 
                          className="w-6 h-6 rounded-full mr-2"
                        />
                        <span className="text-lg font-semibold text-[#FFD700]">{listing.price}</span>
                      </div>
                      
                      <Button
                        className={`${canAfford(listing) 
                          ? 'bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]' 
                          : 'bg-[#432874]/50 text-[#C8B8DB]/50 cursor-not-allowed'}`}
                        disabled={!canAfford(listing) || isSubmitting || isLocked}
                        onClick={() => setConfirmDialog({ open: true, listing })}
                      >
                        <ShoppingBag className="h-4 w-4 mr-2" />
                        {isLocked ? 'Locked' : canAfford(listing) ? 'Purchase' : 'Can\'t Afford'}
                      </Button>
                    </div>
                    
                    <div className="text-xs text-[#C8B8DB]/60 italic">
                      Limited time offer, refreshes with the daily market.
                    </div>
                  </div>
                </motion.div>
              );
            })
          )}
        </motion.div>
      </div>
      
      {/* Standard Items */}
      <div className="mb-8">
        <div className="flex items-center mb-4">
          <Coins className="h-5 w-5 mr-2 text-[#C8B8DB]" />
          <h3 className="text-xl font-cinzel font-bold text-[#C8B8DB]">Standard Items</h3>
        </div>
        <motion.div
          variants={container}
          initial="hidden"
          animate="show"
          className="grid gap-6 md:grid-cols-2 lg:grid-cols-3"
        >
          {standardListingsWithPlaceholders.length === 0 ? (
            <div className="col-span-full bg-[#1A1A2E] rounded-xl p-8 text-center">
              <ShoppingBag className="h-12 w-12 mx-auto mb-4 text-[#C8B8DB]/50" />
              <p className="text-[#C8B8DB]/80 mb-4">
                No standard items are available at the moment. Check back later!
              </p>
            </div>
          ) : (
            standardListingsWithPlaceholders.map((listing, index) => {
              const itemInfo = getItemInfo(listing);
              const isLocked = index >= blackMarketLevel + 2 || (listing as any).isPlaceholder;
              
              return (
                <motion.div
                  key={listing.id}
                  variants={item}
                  className={`bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden relative ${isLocked ? 'opacity-60' : ''}`}
                >
                  {isLocked && (
                    <div className="absolute inset-0 bg-[#1A1A2E]/60 backdrop-blur-sm z-10 flex flex-col items-center justify-center p-4">
                      <Lock className="h-12 w-12 text-[#432874] mb-4" />
                      <p className="text-center text-[#C8B8DB] font-semibold">
                        Upgrade your Black Market to Level {Math.ceil((index + 1) / 3)} to unlock this slot
                      </p>
                      <Button 
                        variant="outline" 
                        size="sm" 
                        className="mt-4 border-[#FF9D00]/50 text-[#FF9D00] hover:bg-[#FF9D00]/10"
                        onClick={() => setShowUpgradeDialog(true)}
                      >
                        <Shield className="h-4 w-4 mr-2" />
                        Upgrade Market
                      </Button>
                    </div>
                  )}
                  
                  <div className="relative h-40">
                    <img 
                      src={itemInfo.image} 
                      alt={itemInfo.title} 
                      className="w-full h-full object-cover"
                    />
                    <div className="absolute inset-0 bg-gradient-to-t from-[#1A1A2E] to-transparent"></div>
                    <div className="absolute top-2 right-2">
                      <Badge className="bg-[#C8B8DB]/20 text-[#C8B8DB] border-[#C8B8DB]/30">
                        Standard
                      </Badge>
                    </div>
                    <div className="absolute bottom-0 left-0 right-0 p-4">
                      <h3 className="text-xl font-cinzel font-bold text-[#C8B8DB]">{itemInfo.title}</h3>
                      <p className="text-sm text-[#C8B8DB]/80">{itemInfo.description}</p>
                    </div>
                  </div>
                  
                  <div className="p-4">
                    {/* Item details section */}
                    {itemInfo.detailLines && itemInfo.detailLines.length > 0 && (
                      <div className="mb-3 text-xs text-[#C8B8DB]/80 bg-[#1A1A2E]/80 rounded p-2 border border-[#432874]/20">
                        {itemInfo.detailLines.map((line, index) => 
                          line ? <div key={index} className="mb-1">{line}</div> : null
                        )}
                      </div>
                    )}
                    
                    <div className="flex justify-between items-center mb-4">
                      <div className="flex items-center">
                        <img 
                          src={getCurrencyIcon(listing.currencyType)} 
                          alt={listing.currencyType} 
                          className="w-6 h-6 rounded-full mr-2"
                        />
                        <span className="text-lg font-semibold text-[#C8B8DB]">{listing.price}</span>
                      </div>
                      
                      <Button
                        className={`${canAfford(listing) 
                          ? 'bg-[#432874] hover:bg-[#432874]/80' 
                          : 'bg-[#432874]/50 text-[#C8B8DB]/50 cursor-not-allowed'}`}
                        disabled={!canAfford(listing) || isSubmitting || isLocked}
                        onClick={() => setConfirmDialog({ open: true, listing })}
                      >
                        <ShoppingBag className="h-4 w-4 mr-2" />
                        {isLocked ? 'Locked' : canAfford(listing) ? 'Purchase' : 'Can\'t Afford'}
                      </Button>
                    </div>
                    
                    <div className="text-xs text-[#C8B8DB]/60 italic">
                      Available until the daily market refresh.
                    </div>
                  </div>
                </motion.div>
              );
            })
          )}
        </motion.div>
      </div>
      
      {/* Coming Soon: Player Listings */}
      <div className="mt-12 bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-6">
        <div className="flex items-center mb-4">
          <Users className="h-6 w-6 text-[#FF9D00] mr-2" />
          <h2 className="text-xl font-cinzel font-bold">Coming Soon: Player Listings</h2>
        </div>
        <p className="text-[#C8B8DB]/80 mb-4">
          Soon you'll be able to list your own characters, auras, and resources for sale to other players. Upgrade your Black Market level to unlock more listing slots!
        </p>
        
        <div className="bg-[#432874]/20 p-4 rounded-lg">
          <div className="flex items-center mb-2">
            <Shield className="h-5 w-5 text-[#00B9AE] mr-2" />
            <h3 className="font-semibold">Your Black Market Level: {user?.blackMarketLevel || 1}</h3>
          </div>
          <div className="text-sm text-[#C8B8DB]/80">
            Listing Slots: {user?.blackMarketLevel || 1} / 5 (max)
          </div>
        </div>
      </div>
      
      {/* Purchase Confirmation Dialog */}
      <Dialog open={confirmDialog.open} onOpenChange={(open) => setConfirmDialog({ ...confirmDialog, open })}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Confirm Purchase</DialogTitle>
          </DialogHeader>
          
          {confirmDialog.listing && (
            <div className="py-4">
              <div className="flex items-center mb-4">
                <img 
                  src={getItemInfo(confirmDialog.listing).image}
                  alt={getItemInfo(confirmDialog.listing).title} 
                  className="w-16 h-16 rounded-lg object-cover mr-4"
                />
                <div>
                  <h3 className="font-semibold text-lg">{getItemInfo(confirmDialog.listing).title}</h3>
                  <p className="text-sm text-[#C8B8DB]/70">
                    {getItemInfo(confirmDialog.listing).description}
                  </p>
                </div>
              </div>
              
              {/* Display item details in the confirmation dialog */}
              {getItemInfo(confirmDialog.listing).detailLines && getItemInfo(confirmDialog.listing).detailLines.length > 0 && (
                <div className="mb-4 p-3 bg-[#432874]/10 rounded border border-[#432874]/30">
                  <h4 className="text-sm font-semibold mb-1">Item Details:</h4>
                  {getItemInfo(confirmDialog.listing).detailLines.map((line, index) => 
                    line ? <div key={index} className="text-xs text-[#C8B8DB]/80 mb-1">{line}</div> : null
                  )}
                </div>
              )}
              
              <div className="bg-[#432874]/20 p-4 rounded-lg mb-4">
                <div className="flex justify-between items-center">
                  <span>Price:</span>
                  <div className="flex items-center">
                    <img 
                      src={getCurrencyIcon(confirmDialog.listing.currencyType)} 
                      alt={confirmDialog.listing.currencyType} 
                      className="w-5 h-5 rounded-full mr-1"
                    />
                    <span className={confirmDialog.listing.currencyType === 'forgeTokens' ? 'text-[#FFD700]' : ''}>
                      {confirmDialog.listing.price}
                    </span>
                  </div>
                </div>
                
                <div className="flex justify-between items-center mt-2">
                  <span>Your Balance:</span>
                  <div className="flex items-center">
                    <img 
                      src={getCurrencyIcon(confirmDialog.listing.currencyType)} 
                      alt={confirmDialog.listing.currencyType} 
                      className="w-5 h-5 rounded-full mr-1"
                    />
                    <span className={confirmDialog.listing.currencyType === 'forgeTokens' ? 'text-[#FFD700]' : ''}>
                      {confirmDialog.listing.currencyType === 'forgeTokens' 
                        ? user?.forgeTokens || 0 
                        : user?.rogueCredits || 0
                      }
                    </span>
                  </div>
                </div>
                
                <div className="flex justify-between items-center mt-2 border-t border-[#432874]/50 pt-2">
                  <span>After Purchase:</span>
                  <div className="flex items-center">
                    <img 
                      src={getCurrencyIcon(confirmDialog.listing.currencyType)} 
                      alt={confirmDialog.listing.currencyType} 
                      className="w-5 h-5 rounded-full mr-1"
                    />
                    <span className={confirmDialog.listing.currencyType === 'forgeTokens' ? 'text-[#FFD700]' : ''}>
                      {confirmDialog.listing.currencyType === 'forgeTokens' 
                        ? (user?.forgeTokens || 0) - confirmDialog.listing.price
                        : (user?.rogueCredits || 0) - confirmDialog.listing.price
                      }
                    </span>
                  </div>
                </div>
              </div>
              
              <div className="flex items-start mb-4">
                <AlertTriangle className="h-5 w-5 text-[#FF9D00] mr-2 flex-shrink-0 mt-0.5" />
                <p className="text-sm">
                  This purchase cannot be undone. Are you sure you want to proceed?
                </p>
              </div>
            </div>
          )}
          
          <DialogFooter className="flex justify-end space-x-2">
            <Button 
              variant="outline" 
              className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
              onClick={() => setConfirmDialog({ open: false, listing: null })}
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button
              className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
              onClick={() => confirmDialog.listing && handlePurchase(confirmDialog.listing)}
              disabled={isSubmitting}
            >
              {isSubmitting ? 'Processing...' : 'Confirm Purchase'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
};

export default BlackMarketView;

=== client/src/components/buildings/TownhallSkillTree.tsx ===
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter } from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Wheat, Hammer, Plus, Check, Building } from 'lucide-react';

const TownhallSkillTree = ({ 
  building, 
  currentLevel, 
  onUpgrade 
}: { 
  building: any; 
  currentLevel: number; 
  onUpgrade: (skillId: string) => void; 
}) => {
  const { toast } = useToast();
  const [selectedOption, setSelectedOption] = useState<string | null>(null);
  const [resourceChecked, setResourceChecked] = useState(false);
  
  const { data: skillTreeData, isLoading, error } = useQuery({
    queryKey: [`/api/buildings/skills/townhall`],
    enabled: !!building
  });
  
  // Debug logging
  console.log("TownhallSkillTree rendering:", { building, currentLevel });
  console.log("Skill tree data:", skillTreeData);
  console.log("Loading state:", isLoading);
  console.log("Error state:", error);

  useEffect(() => {
    // Check if player has "Building Plans" resource
    const checkForBuildingPlans = async () => {
      try {
        const resources = await apiRequest('GET', '/api/resources');
        if (Array.isArray(resources)) {
          const buildingPlans = resources.find((r: any) => r.name === 'Building Plans');
          setResourceChecked(true);
          if (!buildingPlans || buildingPlans.quantity < 1) {
            toast({
              title: "Building Plans Required",
              description: "You need Building Plans to upgrade your Townhall",
              variant: "destructive"
            });
          }
        }
      } catch (error) {
        console.error("Error checking for Building Plans:", error);
      }
    };
    
    checkForBuildingPlans();
  }, []);

  const availableUpgrades = React.useMemo(() => {
    if (!skillTreeData || !skillTreeData.availableSkillTree || !Array.isArray(skillTreeData.availableSkillTree) || !skillTreeData.unlockedSkills) {
      return { farmPlots: [], forgeSlots: [], specialUpgrades: [] };
    }
    
    const unlockedSkills = Array.isArray(skillTreeData.unlockedSkills) ? skillTreeData.unlockedSkills : [];
    
    return {
      farmPlots: skillTreeData.availableSkillTree.filter((skill: any) => 
        skill.id && typeof skill.id === 'string' && 
        skill.id.startsWith('th_farm_plot_') && 
        !unlockedSkills.includes(skill.id)
      ),
      forgeSlots: skillTreeData.availableSkillTree.filter((skill: any) => 
        skill.id && typeof skill.id === 'string' && 
        skill.id.startsWith('th_forge_slot_') && 
        !unlockedSkills.includes(skill.id)
      ),
      specialUpgrades: skillTreeData.availableSkillTree.filter((skill: any) => 
        skill.id && typeof skill.id === 'string' && 
        (skill.id.startsWith('th_crafting_station_') || skill.id.startsWith('th_farm_expansion_')) &&
        !unlockedSkills.includes(skill.id) &&
        (!skill.requires || (skill.requires.townhall_level && skill.requires.townhall_level <= currentLevel))
      )
    };
  }, [skillTreeData, currentLevel]);

  const specialUpgradesAvailable = currentLevel % 5 === 0 && availableUpgrades.specialUpgrades.length > 0;

  const handleUpgrade = () => {
    if (!selectedOption) {
      toast({
        title: "Selection Required",
        description: "Please select an option to upgrade",
        variant: "destructive"
      });
      return;
    }
    
    onUpgrade(selectedOption);
  };

  if (isLoading) {
    return <div className="p-4 text-center">Loading townhall upgrade options...</div>;
  }

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="flex items-center">
          <Building className="mr-2 h-5 w-5" />
          Townhall Upgrade Options
        </CardTitle>
        <CardDescription>
          Use Building Plans to upgrade your Townhall
        </CardDescription>
      </CardHeader>
      
      <CardContent>
        {specialUpgradesAvailable ? (
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Special Upgrades (Townhall Level {currentLevel})</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {availableUpgrades.specialUpgrades.map((upgrade: any) => (
                <motion.div
                  key={upgrade.id}
                  whileHover={{ scale: 1.02 }}
                  className={`p-4 border rounded-lg cursor-pointer ${
                    selectedOption === upgrade.id ? 'border-2 border-primary' : 'border-border'
                  }`}
                  onClick={() => setSelectedOption(upgrade.id)}
                >
                  <div className="flex items-start justify-between">
                    <div>
                      <h4 className="font-medium">{upgrade.name}</h4>
                      <p className="text-sm text-muted-foreground">{upgrade.description}</p>
                    </div>
                    <div className="flex items-center justify-center w-6 h-6 rounded-full bg-primary/10">
                      {selectedOption === upgrade.id ? (
                        <Check className="h-4 w-4 text-primary" />
                      ) : (
                        <Plus className="h-4 w-4 text-primary" />
                      )}
                    </div>
                  </div>
                </motion.div>
              ))}
            </div>
          </div>
        ) : (
          <Tabs defaultValue="farm" className="w-full">
            <TabsList className="w-full grid grid-cols-2">
              <TabsTrigger value="farm" className="flex items-center">
                <Wheat className="mr-2 h-4 w-4" />
                Farm Plots
              </TabsTrigger>
              <TabsTrigger value="forge" className="flex items-center">
                <Hammer className="mr-2 h-4 w-4" />
                Forge Slots
              </TabsTrigger>
            </TabsList>
            
            <TabsContent value="farm" className="p-1 mt-4">
              <div className="grid grid-cols-1 gap-3">
                {availableUpgrades.farmPlots.length > 0 ? (
                  availableUpgrades.farmPlots.map((plot: any) => (
                    <motion.div
                      key={plot.id}
                      whileHover={{ scale: 1.02 }}
                      className={`p-4 border rounded-lg cursor-pointer ${
                        selectedOption === plot.id ? 'border-2 border-primary' : 'border-border'
                      }`}
                      onClick={() => setSelectedOption(plot.id)}
                    >
                      <div className="flex items-start justify-between">
                        <div>
                          <h4 className="font-medium">{plot.name}</h4>
                          <p className="text-sm text-muted-foreground">{plot.description}</p>
                        </div>
                        <div className="flex items-center justify-center w-6 h-6 rounded-full bg-primary/10">
                          {selectedOption === plot.id ? (
                            <Check className="h-4 w-4 text-primary" />
                          ) : (
                            <Plus className="h-4 w-4 text-primary" />
                          )}
                        </div>
                      </div>
                    </motion.div>
                  ))
                ) : (
                  <div className="text-center py-4 text-muted-foreground">
                    All farm plots have been unlocked
                  </div>
                )}
              </div>
            </TabsContent>
            
            <TabsContent value="forge" className="p-1 mt-4">
              <div className="grid grid-cols-1 gap-3">
                {availableUpgrades.forgeSlots.length > 0 ? (
                  availableUpgrades.forgeSlots.map((slot: any) => (
                    <motion.div
                      key={slot.id}
                      whileHover={{ scale: 1.02 }}
                      className={`p-4 border rounded-lg cursor-pointer ${
                        selectedOption === slot.id ? 'border-2 border-primary' : 'border-border'
                      }`}
                      onClick={() => setSelectedOption(slot.id)}
                    >
                      <div className="flex items-start justify-between">
                        <div>
                          <h4 className="font-medium">{slot.name}</h4>
                          <p className="text-sm text-muted-foreground">{slot.description}</p>
                        </div>
                        <div className="flex items-center justify-center w-6 h-6 rounded-full bg-primary/10">
                          {selectedOption === slot.id ? (
                            <Check className="h-4 w-4 text-primary" />
                          ) : (
                            <Plus className="h-4 w-4 text-primary" />
                          )}
                        </div>
                      </div>
                    </motion.div>
                  ))
                ) : (
                  <div className="text-center py-4 text-muted-foreground">
                    All forge slots have been unlocked
                  </div>
                )}
              </div>
            </TabsContent>
          </Tabs>
        )}
      </CardContent>
      
      <CardFooter>
        <Button 
          className="w-full" 
          disabled={!selectedOption}
          onClick={handleUpgrade}
        >
          Confirm Selection
        </Button>
      </CardFooter>
    </Card>
  );
};

export default TownhallSkillTree;

=== client/src/components/buildings/BuildingsView.tsx ===
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { 
  Building2, 
  Hammer, 
  ShoppingBag, 
  User, 
  Gem, 
  List, 
  Clock, 
  Hourglass, 
  ArrowUp, 
  CheckCircle, 
  Lock, 
  Shield,
  Loader2,
  Plus,
  Wheat
} from 'lucide-react';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger,
  DialogFooter,
  DialogDescription
} from '@/components/ui/dialog';
import CountdownTimer from '../common/CountdownTimer';

import type { BuildingUpgrade } from '@shared/schema';

// Building definitions
const buildings: {
  id: string;
  name: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  benefits: Array<{ level: number; text: string }>;
  maxLevel: number;
  baseUpgradeCost: { rogueCredits: number; forgeTokens: number };
  upgradeTimeInMinutes: number;
}[] = [];

const BuildingsView = () => {
  const { user, fetchUser } = useDiscordAuth();
  const { toast } = useToast();
  const [selectedBuilding, setSelectedBuilding] = useState<any>(null);
  const [upgradeDialog, setUpgradeDialog] = useState<boolean>(false);
  const [skillTreeDialog, setSkillTreeDialog] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [selectedSkill, setSelectedSkill] = useState<string | null>(null);
  
  // Fetch building upgrades
  const { data: buildingUpgrades = [], isLoading, refetch: refetchBuildings } = useQuery<BuildingUpgrade[]>({
    queryKey: ['/api/buildings'],
    refetchInterval: 60000 // Refresh every minute
  });

  // Get building upgrade by type
  const getBuildingByType = (buildingType: string) => {
    console.log("All building upgrades:", buildingUpgrades);
    
    // Map building IDs to the correct buildingType for the server
    const buildingTypeMap: Record<string, string> = {
      'townhall': 'townhall',
      'forge': 'forge',
      'blackmarket': 'blackmarket',
      'bountyboard': 'bountyBoard',
      'tavern': 'tavern',
      'farming': 'farming'
    };
    
    const normalizedType = buildingTypeMap[buildingType] || buildingType;
    console.log("Mapped building type:", buildingType, "->", normalizedType);
    
    // Check if we have a building of this type
    const found = buildingUpgrades.find(upgrade => upgrade.buildingType === normalizedType);
    if (found) {
      console.log("Found building data for:", normalizedType, found);
      return found;
    }
    
    // If no building data found, create a new building instance
    console.log("Creating new building data for:", normalizedType);
    return {
      id: 0,
      userId: 1,
      buildingType: normalizedType,
      currentLevel: 1,
      upgradeStartTime: null,
      upgradeEndTime: null,
      upgradeInProgress: false,
      unlockedSkills: [],
      availableSkillPoints: 1,
      skillDistribution: {}
    } as unknown as BuildingUpgrade;
  };

  // Calculate upgrade cost based on current level
  const calculateUpgradeCost = (building: any, currentLevel: number) => {
    const levelMultiplier = currentLevel;
    return {
      rogueCredits: building.baseUpgradeCost.rogueCredits * levelMultiplier,
      forgeTokens: building.baseUpgradeCost.forgeTokens * levelMultiplier
    };
  };

  // Check if user can afford upgrade
  const canAffordUpgrade = (building: any, currentLevel: number) => {
    if (!user) return false;
    
    const cost = calculateUpgradeCost(building, currentLevel);
    const userCredits = user.rogueCredits || 0;
    const userTokens = user.forgeTokens || 0;
    
    return userCredits >= cost.rogueCredits && userTokens >= cost.forgeTokens;
  };

  // Check if building is at max level based on townhall level
  const isMaxLevel = (building: any, currentLevel: number) => {
    // Get townhall level
    const townhall = getBuildingByType('townhall');
    const townhallLevel = townhall?.currentLevel || 1;
    
    // Fixed max level of 9 for all buildings regardless of Townhall level
    const maxAllowedLevel = 9;
    
    // For all buildings, check against the max allowed level (including townhall)
    return currentLevel >= maxAllowedLevel;
  };

  // Check if building is currently upgrading
  const isUpgrading = (buildingType: string) => {
    const building = getBuildingByType(buildingType);
    return building ? building.upgradeInProgress : false;
  };

  // Calculate upgrade progress
  const calculateUpgradeProgress = (building: BuildingUpgrade) => {
    if (!building.upgradeStartTime || !building.upgradeEndTime) return 0;
    
    const startTime = new Date(building.upgradeStartTime).getTime();
    const endTime = new Date(building.upgradeEndTime).getTime();
    const now = new Date().getTime();
    
    return Math.min(100, Math.max(0, ((now - startTime) / (endTime - startTime)) * 100));
  };

  // Import the TownhallSkillTree component
  const TownhallSkillTree = React.lazy(() => import('./TownhallSkillTree'));
  
  // Start building upgrade
  // Define the SkillTreeData type
  type SkillTreeData = {
    currentLevel: number;
    unlockedSkills: string[];
    availableSkillTree: Array<{
      id: string;
      name: string;
      description: string;
      maxLevel: number;
      path?: string;
      requires?: Record<string, number>;
    }>;
  };

  // Fetch building skill tree data with proper typing
  const { data: skillTreeData = { 
    currentLevel: 1, 
    unlockedSkills: [], 
    availableSkillTree: [] 
  } as SkillTreeData } = useQuery<SkillTreeData>({
    queryKey: selectedBuilding ? [`/api/buildings/skills/${selectedBuilding.buildingType}`] : [],
    enabled: !!selectedBuilding && skillTreeDialog
  });

  // Debug log for skill tree query with console logs
  if (selectedBuilding && skillTreeDialog) {
    console.log("Skill tree query for building:", selectedBuilding);
    console.log("Building type for skill tree:", selectedBuilding.buildingType);
    
    // Log error if undefined
    if (!selectedBuilding.buildingType) {
      console.error("Building type is undefined for:", selectedBuilding);
    }
  }

  // Allocate skill point
  const allocateSkill = async (skillId: string) => {
    if (!selectedBuilding) return;
    
    setIsSubmitting(true);
    
    try {
      const response = await apiRequest('POST', `/api/buildings/skills/${selectedBuilding.buildingType}`, {
        skillId: skillId
      });
      
      const data = await response.json();
      
      toast({
        title: "Skill Allocated",
        description: `You've allocated a skill point for ${selectedBuilding.name}.`,
      });
      
      setSelectedSkill(skillId);
      setSkillTreeDialog(false);
      
      // Continue with upgrade after skill allocation
      startUpgrade(skillId);
    } catch (error: any) {
      console.error('Error allocating skill:', error);
      toast({
        title: "Failed to Allocate Skill",
        description: error.message || "There was an error allocating the skill point.",
        variant: "destructive"
      });
      setIsSubmitting(false);
    }
  };

  // Start building upgrade
  const startUpgrade = async (allocatedSkill?: string) => {
    if (!selectedBuilding) return;
    
    // Make sure we're using the correct building type mapping
    const buildingTypeMap: Record<string, string> = {
      'townhall': 'townhall',
      'forge': 'forge',
      'blackmarket': 'blackmarket',
      'bountyboard': 'bountyBoard',
      'tavern': 'tavern',
      'farming': 'farming'
    };
    const normalizedType = buildingTypeMap[selectedBuilding.id] || selectedBuilding.id;
    
    // Always use the normalized type for consistency
    selectedBuilding.buildingType = normalizedType;
    console.log("Upgrade using buildingType:", selectedBuilding.buildingType);
    
    const buildingData = getBuildingByType(selectedBuilding.id);
    if (!buildingData) return;
    
    const currentLevel = buildingData.currentLevel;
    
    if (isMaxLevel(selectedBuilding, currentLevel)) {
      toast({
        title: "Max Level Reached",
        description: `${selectedBuilding.name} is already at maximum level.`,
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    if (isUpgrading(selectedBuilding.id)) {
      toast({
        title: "Already Upgrading",
        description: `${selectedBuilding.name} is already being upgraded.`,
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    if (!canAffordUpgrade(selectedBuilding, currentLevel)) {
      toast({
        title: "Insufficient Resources",
        description: "You don't have enough resources for this upgrade.",
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    try {
      console.log("Starting upgrade for building:", selectedBuilding.id);
      
      // If user has selected a skill to allocate, include it in the upgrade request
      const requestData: any = {
        buildingType: selectedBuilding.buildingType,
      };
      
      if (allocatedSkill) {
        requestData.allocatedSkill = allocatedSkill;
      }
      
      // Use apiRequest instead of fetch for better error handling
      const response = await apiRequest('POST', '/api/buildings/upgrade', requestData);
      
      // apiRequest already returns the parsed JSON data
      const data = response;
      console.log("Upgrade response:", data);
      
      toast({
        title: "Upgrade Started",
        description: `${selectedBuilding.name} is now being upgraded to level ${currentLevel + 1}.`,
      });
      
      // Reset selections and close dialog
      setSelectedBuilding(null);
      setUpgradeDialog(false);
      setSelectedSkill(null);
      
      // Refresh buildings and user data
      refetchBuildings();
      fetchUser();
    } catch (error: any) {
      console.error('Error starting upgrade:', error);
      toast({
        title: "Upgrade Failed",
        description: error.message || "There was an error starting the upgrade.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Complete building upgrade
  const completeUpgrade = async (buildingType: string) => {
    setIsSubmitting(true);
    
    try {
      // Map building IDs to the correct buildingType for the server
      const buildingTypeMap: Record<string, string> = {
        'townhall': 'townhall',
        'forge': 'forge', 
        'blackmarket': 'blackmarket',
        'bountyboard': 'bountyBoard',
        'tavern': 'tavern',
        'farming': 'farming'
      };
      
      const normalizedType = buildingTypeMap[buildingType] || buildingType;
      console.log(`Completing upgrade for building type: ${buildingType} -> ${normalizedType}`);
      
      // Call API to complete upgrade
      await apiRequest('POST', `/api/buildings/complete/${normalizedType}`, {});
      
      const building = buildings.find(b => b.id === buildingType);
      
      toast({
        title: "Upgrade Complete!",
        description: `${building?.name || buildingType} has been upgraded successfully.`,
      });
      
      // Refresh buildings and user data
      refetchBuildings();
      fetchUser();
    } catch (error) {
      console.error('Error completing upgrade:', error);
      toast({
        title: "Error",
        description: "Failed to complete the upgrade.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Check if a building is locked
  const isBuildingLocked = (buildingType: string) => {
    // No buildings should be locked - they can all be upgraded up to level 9
    return false;
  };

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl animate-pulse">Loading buildings data...</div>
      </div>
    );
  }

  // Check if there are any available skill points for a building
  const hasAvailableSkillPoints = (building: any) => {
    if (!building) {
      console.log("No building provided to hasAvailableSkillPoints");
      return false;
    }
    
    const buildingData = getBuildingByType(building.id);
    if (!buildingData) {
      console.log("No building data found for:", building.id);
      return false;
    }
    
    // Calculate available skill points based on building level and already allocated skills
    const totalSkillPoints = Math.max(0, buildingData.currentLevel - 1);
    const allocatedPoints = (buildingData.unlockedSkills?.length || 0);
    
    console.log("Building:", building.id);
    console.log("Current level:", buildingData.currentLevel);
    console.log("Total skill points:", totalSkillPoints);
    console.log("Allocated points:", allocatedPoints);
    console.log("Has available points:", totalSkillPoints > allocatedPoints);
    
    // Always return true for testing
    return true;
  };

  return (
    <>
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Buildings</h1>
        <p className="text-[#C8B8DB]/80">
          Upgrade your buildings to unlock new features and increase your capabilities.
        </p>
      </div>
      
      {/* Skill Tree Dialog */}
      <Dialog open={skillTreeDialog} onOpenChange={(open) => {
        setSkillTreeDialog(open);
        if (!open) setSelectedSkill(null);
      }}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-2xl overflow-y-auto max-h-[80vh]">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">
              {selectedBuilding?.name} Skill Tree
            </DialogTitle>
            <DialogDescription>
              Allocate skill points to enhance your building's capabilities. You gain skill points each time you level up your building.
            </DialogDescription>
          </DialogHeader>
          
          {skillTreeData ? (
            <div className="py-4">
              <div className="mb-6 bg-[#432874]/20 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="font-semibold">Available Skill Points:</span>
                  <Badge className="bg-[#FF9D00] text-[#1A1A2E]">
                    {skillTreeData.currentLevel - (skillTreeData.unlockedSkills?.length || 0)}
                  </Badge>
                </div>
              </div>
              
              <div className="grid gap-4">
                {skillTreeData.availableSkillTree?.map((skill: any) => {
                  const isUnlocked = skillTreeData.unlockedSkills?.includes(skill.id);
                  
                  return (
                    <div 
                      key={skill.id}
                      className={`border p-4 rounded-lg ${isUnlocked ? 'border-[#00B9AE] bg-[#00B9AE]/10' : 'border-[#432874]/30 bg-[#432874]/5'}`}
                    >
                      <div className="flex justify-between items-start">
                        <div>
                          <h3 className={`font-semibold ${isUnlocked ? 'text-[#00B9AE]' : 'text-[#FF9D00]'}`}>{skill.name}</h3>
                          <p className="text-sm mt-1">{skill.description}</p>
                        </div>
                        {isUnlocked ? (
                          <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] border-[#00B9AE]/50">
                            <CheckCircle className="h-4 w-4 mr-1" /> Unlocked
                          </Badge>
                        ) : (
                          <Button
                            size="sm"
                            className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                            onClick={() => allocateSkill(skill.id)}
                            disabled={!hasAvailableSkillPoints(selectedBuilding) || isSubmitting}
                          >
                            {isSubmitting ? (
                              <><Loader2 className="h-4 w-4 mr-1 animate-spin" /> Allocating...</>
                            ) : (
                              <><Plus className="h-4 w-4 mr-1" /> Allocate Point</>
                            )}
                          </Button>
                        )}
                      </div>
                      {skill.maxLevel > 1 && (
                        <div className="mt-3 flex items-center">
                          <span className="text-xs mr-2">Level: 1/{skill.maxLevel}</span>
                          <Progress 
                            value={(1 / skill.maxLevel) * 100} 
                            className="h-1 flex-1 bg-[#1F1D36]" 
                          />
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="py-8 text-center">
              <Loader2 className="h-8 w-8 mx-auto animate-spin text-[#FF9D00]" />
              <p className="mt-4">Loading skill tree data...</p>
            </div>
          )}
          
          <DialogFooter>
            <Button 
              className="bg-[#432874] hover:bg-[#432874]/80"
              onClick={() => setSkillTreeDialog(false)}
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* Buildings Grid */}
      <motion.div
        variants={container}
        initial="hidden"
        animate="show"
        className="grid gap-6 md:grid-cols-2 lg:grid-cols-3"
      >
        {buildings.map(building => {
          const buildingData = getBuildingByType(building.id);
          const currentLevel = buildingData?.currentLevel || 1;
          const isBeingUpgraded = buildingData?.upgradeInProgress || false;
          const locked = isBuildingLocked(building.id) && building.id !== 'townhall';
          
          return (
            <motion.div
              key={building.id}
              variants={item}
              className={`bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden ${
                locked ? 'opacity-50' : ''
              }`}
            >
              <CardHeader className={`pb-2 ${building.color}`}>
                <div className="flex justify-between items-start">
                  <div className="flex items-center">
                    {building.icon}
                    <CardTitle className="ml-2 font-cinzel">{building.name}</CardTitle>
                  </div>
                  <Badge className="bg-[#432874]/30 text-[#C8B8DB] border-[#432874]/50">
                    Level {currentLevel}/{building.maxLevel}
                  </Badge>
                </div>
                <CardDescription>{building.description}</CardDescription>
              </CardHeader>
              
              <CardContent className="pt-4">
                {/* Current Benefits */}
                <div className="mb-4">
                  <h3 className="text-sm font-semibold mb-2">Current Benefits:</h3>
                  <div className="bg-[#432874]/20 p-3 rounded-lg">
                    <div className="flex items-center">
                      <CheckCircle className="h-4 w-4 text-[#00B9AE] mr-2 flex-shrink-0" />
                      <p className="text-sm text-[#C8B8DB]/90">
                        {building.benefits[currentLevel - 1]?.text || 'Basic functionality'}
                      </p>
                    </div>
                  </div>
                </div>
                
                {/* Next Level Benefits */}
                {!isMaxLevel(building, currentLevel) && (
                  <div className="mb-4">
                    <h3 className="text-sm font-semibold mb-2">Next Level Unlocks:</h3>
                    <div className="bg-[#432874]/10 p-3 rounded-lg">
                      <div className="flex items-center">
                        <ArrowUp className="h-4 w-4 text-[#FF9D00] mr-2 flex-shrink-0" />
                        <p className="text-sm text-[#C8B8DB]/80">
                          {building.benefits[currentLevel]?.text || 'Advanced functionality'}
                        </p>
                      </div>
                    </div>
                  </div>
                )}
                
                {/* Upgrade In Progress */}
                {isBeingUpgraded && buildingData?.upgradeEndTime && (
                  <div className="mt-4">
                    <div className="flex justify-between text-sm mb-1">
                      <span className="text-[#FF9D00] flex items-center">
                        <Hourglass className="h-4 w-4 mr-1" /> Upgrade in Progress
                      </span>
                      <CountdownTimer
                        endTime={buildingData.upgradeEndTime}
                        onComplete={() => completeUpgrade(building.id)}
                      />
                    </div>
                    <Progress 
                      value={calculateUpgradeProgress(buildingData)} 
                      className="h-2 bg-[#1F1D36] border-[#432874]/20" 
                    />
                    
                    {new Date(buildingData.upgradeEndTime) <= new Date() && (
                      <Button
                        className="w-full mt-3 bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                        onClick={() => completeUpgrade(building.id)}
                        disabled={isSubmitting}
                      >
                        <CheckCircle className="h-4 w-4 mr-2" />
                        {isSubmitting ? 'Completing...' : 'Complete Upgrade'}
                      </Button>
                    )}
                  </div>
                )}
              </CardContent>
              
              <CardFooter>
                {locked ? (
                  <div className="w-full flex items-center justify-center bg-[#432874]/20 py-2 rounded-lg text-sm text-[#C8B8DB]/70">
                    <Lock className="h-4 w-4 mr-2" />
                    Requires Townhall Upgrade
                  </div>
                ) : isBeingUpgraded ? (
                  <div className="w-full flex items-center justify-center bg-[#432874]/20 py-2 rounded-lg text-sm text-[#C8B8DB]/70">
                    <Hourglass className="h-4 w-4 mr-2" />
                    Upgrade in Progress
                  </div>
                ) : isMaxLevel(building, currentLevel) ? (
                  <div className="w-full flex items-center justify-center bg-[#00B9AE]/20 py-2 rounded-lg text-sm text-[#00B9AE]">
                    <Shield className="h-4 w-4 mr-2" />
                    Maximum Level Reached
                  </div>
                ) : hasAvailableSkillPoints(building) ? (
                  <Button
                    className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                    onClick={() => {
                      // Ensure buildingType is set correctly with proper mapping
                      const buildingTypeMap: Record<string, string> = {
                        'townhall': 'townhall',
                        'forge': 'forge',
                        'blackmarket': 'blackmarket',
                        'bountyboard': 'bountyBoard',
                        'tavern': 'tavern',
      'farming': 'farming'
                      };
                      const normalizedType = buildingTypeMap[building.id] || building.id;
                      console.log(`Opening skill tree for ${building.name}, type: ${normalizedType}`);
                      
                      setSelectedBuilding({
                        ...building,
                        buildingType: normalizedType  // Map the UI ID to the backend buildingType
                      });
                      setSkillTreeDialog(true);
                    }}
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Choose Skill Upgrade
                  </Button>
                ) : (
                  <Dialog open={upgradeDialog && selectedBuilding?.id === building.id} onOpenChange={(open) => {
                    setUpgradeDialog(open);
                    if (!open) setSelectedBuilding(null);
                  }}>
                    <DialogTrigger asChild>
                      <Button
                        className="w-full bg-[#432874] hover:bg-[#432874]/80"
                        onClick={() => setSelectedBuilding({
                          ...building,
                          buildingType: building.id
                        })}
                      >
                        <ArrowUp className="h-4 w-4 mr-2" />
                        Upgrade to Level {currentLevel + 1}
                      </Button>
                    </DialogTrigger>
                    <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
                      <DialogHeader>
                        <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">
                          Upgrade {building.name}
                        </DialogTitle>
                      </DialogHeader>
                      
                      {building.id === 'townhall' ? (
                        <div className="py-4">
                          <React.Suspense fallback={<div className="py-4 text-center">Loading Townhall upgrades...</div>}>
                            <TownhallSkillTree 
                              building={buildingData} 
                              currentLevel={currentLevel}
                              onUpgrade={(skillId) => {
                                allocateSkill(skillId);
                              }} 
                            />
                          </React.Suspense>
                        </div>
                      ) : (
                        <div className="py-4">
                          <div className="mb-4">
                            <h3 className="font-semibold mb-2">Upgrade to Level {currentLevel + 1}</h3>
                            <div className="bg-[#432874]/20 p-4 rounded-lg">
                              <p className="text-sm mb-3">
                                This upgrade will unlock:
                              </p>
                              <div className="flex items-center text-[#FF9D00] mb-4">
                                <ArrowUp className="h-4 w-4 mr-2 flex-shrink-0" />
                                <p className="text-sm">
                                  {building.benefits[currentLevel]?.text || 'Advanced functionality'}
                                </p>
                              </div>
                            
                              <div className="border-t border-[#432874]/30 pt-3">
                                <h4 className="text-sm font-semibold mb-2">Cost:</h4>
                                <div className="grid grid-cols-2 gap-4">
                                  <div className="flex items-center">
                                    <img 
                                      src="https://images.unsplash.com/photo-1543486958-d783bfbf7f8e?w=250&h=250&fit=crop" 
                                      alt="Rogue Credits" 
                                      className="w-5 h-5 rounded-full mr-2"
                                    />
                                    <div>
                                      <div className="text-sm">
                                        {calculateUpgradeCost(building, currentLevel).rogueCredits} Rogue Credits
                                      </div>
                                      <div className={`text-xs ${user && (user.rogueCredits || 0) >= calculateUpgradeCost(building, currentLevel).rogueCredits ? 'text-green-400' : 'text-red-400'}`}>
                                        You have: {user?.rogueCredits || 0}
                                      </div>
                                    </div>
                                  </div>
                                  
                                  <div className="flex items-center">
                                    <img 
                                      src="https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=250&h=250&fit=crop" 
                                      alt="Forge Tokens" 
                                      className="w-5 h-5 rounded-full mr-2"
                                    />
                                    <div>
                                      <div className="text-sm">
                                        {calculateUpgradeCost(building, currentLevel).forgeTokens} Forge Tokens
                                      </div>
                                      <div className={`text-xs ${user && (user.forgeTokens || 0) >= calculateUpgradeCost(building, currentLevel).forgeTokens ? 'text-green-400' : 'text-red-400'}`}>
                                        You have: {user?.forgeTokens || 0}
                                      </div>
                                    </div>
                                  </div>
                                </div>
                              </div>
                              
                              <div className="border-t border-[#432874]/30 pt-3 mt-3">
                                <div className="flex items-center">
                                  <Clock className="h-4 w-4 mr-2 text-[#C8B8DB]/70" />
                                  <span className="text-sm">
                                    Upgrade Time: {building.upgradeTimeInMinutes} minutes
                                  </span>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      )}
                      
                      <DialogFooter className="flex justify-end space-x-2">
                        <Button 
                          variant="outline" 
                          className="bg-transparent border-[#432874]/50 hover:bg-[#432874]/20"
                          onClick={() => {
                            setSelectedBuilding(null);
                            setUpgradeDialog(false);
                          }}
                          disabled={isSubmitting}
                        >
                          Cancel
                        </Button>
                        <Button
                          className={`${
                            canAffordUpgrade(building, currentLevel)
                              ? 'bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]'
                              : 'bg-[#432874]/50 text-[#C8B8DB]/50 cursor-not-allowed'
                          }`}
                          onClick={() => {
                            // Set the selected building first with the correct mapped buildingType
                            const buildingTypeMap: Record<string, string> = {
                              'townhall': 'townhall',
                              'forge': 'forge',
                              'blackmarket': 'blackmarket',
                              'bountyboard': 'bountyBoard',
                              'tavern': 'tavern',
                              'farming': 'farming'
                            };
                            const normalizedType = buildingTypeMap[building.id] || building.id;
                            console.log(`Setting building for upgrade: ${building.name}, type: ${normalizedType}`);
                            
                            setSelectedBuilding({
                              ...building,
                              buildingType: normalizedType
                            });
                            
                            if (hasAvailableSkillPoints(building)) {
                              console.log("Opening skill tree for:", building.id);
                              // Close the upgrade dialog and open the skill tree dialog
                              setUpgradeDialog(false);
                              setTimeout(() => {
                                setSkillTreeDialog(true);
                              }, 100);
                            } else {
                              console.log("Starting upgrade directly for:", building.id);
                              // If no available skill points, start upgrade directly
                              startUpgrade();
                            }
                          }}
                          disabled={!canAffordUpgrade(building, currentLevel) || isSubmitting}
                        >
                          {isSubmitting 
                            ? 'Starting Upgrade...' 
                            : canAffordUpgrade(building, currentLevel)
                              ? hasAvailableSkillPoints(building)
                                ? 'Choose Skill Upgrade'
                                : 'Start Upgrade'
                              : 'Not Enough Resources'
                          }
                        </Button>
                      </DialogFooter>
                    </DialogContent>
                  </Dialog>
                )}
              </CardFooter>
            </motion.div>
          );
        })}
      </motion.div>
      
      {/* Building Strategy Tips */}
      <div className="mt-12 bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-6">
        <h2 className="text-xl font-cinzel font-bold text-[#FF9D00] mb-4">Building Strategy Tips</h2>
        <div className="space-y-4">
          <div className="flex">
            <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
              <span className="text-[#FF9D00] font-bold">1</span>
            </div>
            <p className="text-[#C8B8DB]/80">
              Prioritize upgrading the <span className="text-[#FF9D00] font-semibold">Townhall</span> first as it serves as the foundation of your base and unlocks other buildings.
            </p>
          </div>
          <div className="flex">
            <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
              <span className="text-[#FF9D00] font-bold">2</span>
            </div>
            <p className="text-[#C8B8DB]/80">
              The <span className="text-[#DC143C] font-semibold">Forge</span> should be your second priority as it controls your character level cap and Aura capabilities.
            </p>
          </div>
          <div className="flex">
            <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
              <span className="text-[#FF9D00] font-bold">3</span>
            </div>
            <p className="text-[#C8B8DB]/80">
              The <span className="text-[#00B9AE] font-semibold">Black Market</span> is essential for trading and acquiring rare items at higher levels.
            </p>
          </div>
          <div className="flex">
            <div className="bg-[#432874]/30 rounded-full w-8 h-8 flex items-center justify-center mr-3 flex-shrink-0">
              <span className="text-[#FF9D00] font-bold">4</span>
            </div>
            <p className="text-[#C8B8DB]/80">
              Balance your upgrades to maintain an optimal progression pace - having multiple low-level buildings is often better than a single high-level one.
            </p>
          </div>
        </div>
      </div>
    </>
  );
};

export default BuildingsView;


=== client/src/components/bounty/BountyBoardSkillTree.tsx ===
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { Card } from '@/components/ui/card';
import { Plus, Minus, Lock } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { BuildingUpgrade } from '@shared/schema';

// Define skill tree data
export const bountySkills = [
  {
    id: 'questRewards',
    name: 'Quest Rewards',
    description: 'Increases gold rewards from bounty quests by 10% per level',
    maxLevel: 5,
    requires: [],
    position: { x: 1, y: 1 },
    color: '#FFD700',
    icon: ''
  },
  {
    id: 'questSlots',
    name: 'Quest Slots',
    description: 'Increases available daily quest slots by 1 per level',
    maxLevel: 3,
    requires: [],
    position: { x: 3, y: 1 },
    color: '#4169E1',
    icon: ''
  },
  {
    id: 'resourceBonus',
    name: 'Resource Hunter',
    description: 'Increases resource rewards from bounty quests by 15% per level',
    maxLevel: 4,
    requires: ['questRewards'],
    position: { x: 1, y: 2 },
    color: '#32CD32',
    icon: ''
  },
  {
    id: 'questDuration',
    name: 'Swift Hunter',
    description: 'Decreases quest completion time by 5% per level',
    maxLevel: 3,
    requires: ['questSlots'],
    position: { x: 3, y: 2 },
    color: '#1E90FF',
    icon: ''
  },
  {
    id: 'rareQuests',
    name: 'Rare Quests',
    description: 'Increases chance to find rare quests by 10% per level',
    maxLevel: 3,
    requires: ['resourceBonus', 'questDuration'],
    position: { x: 2, y: 3 },
    color: '#9932CC',
    icon: ''
  },
  {
    id: 'legendaryQuests',
    name: 'Legendary Pursuit',
    description: 'Unlocks legendary quests with exceptional rewards',
    maxLevel: 1,
    requires: ['rareQuests'],
    position: { x: 2, y: 4 },
    color: '#FF4500',
    icon: ''
  }
];

interface BountyBoardSkillTreeProps {
  building?: BuildingUpgrade;
  onUpgrade?: () => void;
}

export const BountyBoardSkillTree = ({ building, onUpgrade }: BountyBoardSkillTreeProps) => {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [skillDistribution, setSkillDistribution] = useState<Record<string, number>>({});
  const [availablePoints, setAvailablePoints] = useState(0);

  // Fetch bounty board data
  const { data: bountyBoard, isLoading, isError } = useQuery({
    queryKey: ['/api/buildings/bountyBoard'],
    enabled: !!building
  });

  useEffect(() => {
    if (bountyBoard) {
      // Ensure skillDistribution is a valid object
      const distribution = bountyBoard.skillDistribution || {};
      setSkillDistribution(distribution as Record<string, number>);
      
      // Initialize skill levels that aren't set
      bountySkills.forEach(skill => {
        if (!(skill.id in distribution)) {
          setSkillDistribution(prev => ({ ...prev, [skill.id]: 0 }));
        }
      });
      
      // Set available points
      setAvailablePoints(bountyBoard.availableSkillPoints || 0);
    }
  }, [bountyBoard]);

  // Mutation to update skill distribution
  const updateSkillsMutation = useMutation({
    mutationFn: async (data: { skillDistribution: Record<string, number> }) => {
      return apiRequest('POST', '/api/buildings/skills/bountyBoard', data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/buildings/bountyBoard'] });
      toast({
        title: 'Skills Updated',
        description: 'Your skill points have been allocated successfully.',
      });
    },
    onError: (error: any) => {
      toast({
        title: 'Error',
        description: error.message || 'Failed to update skills. Please try again.',
        variant: 'destructive',
      });
    }
  });

  // Check if a skill can be allocated points
  const canAllocateSkill = (skillId: string): boolean => {
    if (availablePoints <= 0) return false;
    
    const skill = bountySkills.find(s => s.id === skillId);
    if (!skill) return false;
    
    // Check level cap
    const currentLevel = skillDistribution[skillId] || 0;
    if (currentLevel >= skill.maxLevel) return false;
    
    // Check prerequisites
    if (skill.requires.length > 0) {
      const hasPrerequisites = skill.requires.every(reqId => {
        const reqSkill = bountySkills.find(s => s.id === reqId);
        return reqSkill && (skillDistribution[reqId] || 0) > 0;
      });
      
      if (!hasPrerequisites) return false;
    }
    
    return true;
  };

  // Check if points can be removed from a skill
  const canDeallocateSkill = (skillId: string): boolean => {
    const currentLevel = skillDistribution[skillId] || 0;
    if (currentLevel <= 0) return false;
    
    // Check if any dependent skills are allocated
    const dependentSkills = bountySkills.filter(skill => 
      skill.requires.includes(skillId) && (skillDistribution[skill.id] || 0) > 0
    );
    
    return dependentSkills.length === 0;
  };

  // Handle allocating/deallocating skill points
  const handleSkillChange = (skillId: string, add: boolean) => {
    if (add && !canAllocateSkill(skillId)) return;
    if (!add && !canDeallocateSkill(skillId)) return;
    
    const newDistribution = { ...skillDistribution };
    newDistribution[skillId] = (newDistribution[skillId] || 0) + (add ? 1 : -1);
    
    // Update in the state
    setSkillDistribution(newDistribution);
    setAvailablePoints(prev => prev + (add ? -1 : 1));
    
    // Send to the server
    updateSkillsMutation.mutate({ skillDistribution: newDistribution });
  };
  
  if (isLoading) {
    return <div className="text-center p-8">Loading skill tree...</div>;
  }
  
  if (isError) {
    return <div className="text-center p-8 text-red-500">Failed to load skill tree. Please try again.</div>;
  }
  
  return (
    <div className="relative w-full">
      <Card className="bg-gradient-to-br from-[#2A1657] to-[#392179] border-[#4F3293] text-white p-6 mb-6">
        <h3 className="text-xl font-bold mb-4">Bounty Board Skill Tree</h3>
        <div className="flex justify-between items-center mb-4">
          <div>
            <span className="text-sm text-[#A390D3]">Building Level:</span>
            <span className="ml-2 font-semibold">{building?.currentLevel || 1}</span>
          </div>
          <div>
            <span className="text-sm text-[#A390D3]">Available Points:</span>
            <span className="ml-2 font-semibold text-amber-300">{availablePoints}</span>
          </div>
        </div>
        
        <div className="grid grid-cols-3 gap-4 relative">
          {bountySkills.map(skill => {
            const currentLevel = skillDistribution[skill.id] || 0;
            const maxLevel = skill.maxLevel;
            const progress = (currentLevel / maxLevel) * 100;
            const isLocked = skill.requires.some(reqId => !(skillDistribution[reqId] || 0));
            
            return (
              <div 
                key={skill.id}
                className={`relative col-start-${skill.position.x} row-start-${skill.position.y}`}
                style={{ gridColumn: skill.position.x, gridRow: skill.position.y }}
              >
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Card 
                        className={`p-3 w-full h-full flex flex-col items-center 
                          ${isLocked 
                            ? 'bg-gray-800/60 border-gray-700' 
                            : `bg-gradient-to-b from-${skill.color}/20 to-${skill.color}/5 border-${skill.color}/30`}`}
                      >
                        {isLocked && (
                          <div className="absolute inset-0 bg-black/50 flex items-center justify-center rounded-md z-10">
                            <Lock className="text-gray-500 w-6 h-6" />
                          </div>
                        )}
                        
                        <div className="text-2xl mb-2">{skill.icon}</div>
                        <div className="font-semibold text-center mb-1">{skill.name}</div>
                        <div className="text-xs text-center text-gray-300 mb-2">Level: {currentLevel}/{maxLevel}</div>
                        
                        <Progress value={progress} className="h-2 w-full mb-3" />
                        
                        <div className="flex justify-between w-full mt-auto">
                          <Button
                            variant="outline"
                            size="icon"
                            disabled={!canDeallocateSkill(skill.id)}
                            onClick={() => handleSkillChange(skill.id, false)}
                            className="h-7 w-7 rounded-full"
                          >
                            <Minus className="h-4 w-4" />
                          </Button>
                          
                          <Button
                            variant="outline"
                            size="icon"
                            disabled={!canAllocateSkill(skill.id)}
                            onClick={() => handleSkillChange(skill.id, true)}
                            className="h-7 w-7 rounded-full"
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                        </div>
                      </Card>
                    </TooltipTrigger>
                    <TooltipContent className="max-w-xs">
                      <div className="font-bold">{skill.name}</div>
                      <div className="text-sm">{skill.description}</div>
                      <div className="text-xs mt-1">
                        {skill.requires.length > 0 && (
                          <div className="mt-1">
                            <span className="font-semibold">Requires:</span> {skill.requires.join(', ')}
                          </div>
                        )}
                      </div>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
            );
          })}
          
          {/* Draw lines between connected skills */}
          <svg className="absolute inset-0 w-full h-full -z-10 text-white/20">
            {bountySkills.map(skill => 
              skill.requires.map(reqId => {
                const parentSkill = bountySkills.find(s => s.id === reqId);
                if (!parentSkill) return null;
                
                // Calculate line positions
                const startX = (parentSkill.position.x - 0.5) * 33.33 + '%';
                const startY = (parentSkill.position.y - 0.5) * 33.33 + '%';
                const endX = (skill.position.x - 0.5) * 33.33 + '%';
                const endY = (skill.position.y - 0.5) * 33.33 + '%';
                
                return (
                  <line 
                    key={`${skill.id}-${reqId}`}
                    x1={startX} 
                    y1={startY} 
                    x2={endX} 
                    y2={endY} 
                    stroke="currentColor" 
                    strokeWidth="2"
                    strokeDasharray={!(skillDistribution[reqId] || 0) ? "4" : "0"}
                  />
                );
              })
            )}
          </svg>
        </div>
      </Card>
    </div>
  );
};

// We use named export for consistency
// export default BountyBoardSkillTree is removed intentionally

=== client/src/components/bounty/BountyBoardView.tsx ===
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  List,
  CheckCircle2,
  Clock,
  Gem,
  Flame,
  Skull,
  Shield,
  Scroll,
  Package,
  ChevronDown,
  ChevronRight,
  Settings,
  Calendar,
  CalendarDays,
  Gift as GiftIcon,
  Coins,
  Calculator as Coin,
  Diamond,
  Zap,
  BookOpen,
  Loader2
} from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

import type { BountyQuest, BuildingUpgrade } from '@shared/schema';

// Sample quest templates for demonstrations
const questTemplates = [
  {
    type: 'farming',
    name: 'Resource Collector',
    description: 'Gather various resources from farming missions.',
    icon: <Gem className="h-5 w-5" />,
    color: 'bg-green-700/30 text-green-400 border-green-600/30',
    requirementTypes: ['Farm any resource', 'Complete farming missions']
  },
  {
    type: 'dungeon',
    name: 'Dungeon Delver',
    description: 'Clear dungeons and defeat enemies.',
    icon: <Skull className="h-5 w-5" />,
    color: 'bg-red-700/30 text-red-400 border-red-600/30',
    requirementTypes: ['Complete dungeon runs', 'Defeat specific enemies']
  },
  {
    type: 'crafting',
    name: 'Master Craftsman',
    description: 'Craft and fuse Auras at The Forge.',
    icon: <Flame className="h-5 w-5" />,
    color: 'bg-yellow-700/30 text-yellow-400 border-yellow-600/30',
    requirementTypes: ['Craft Auras', 'Perform Aura fusion']
  },
  {
    type: 'building',
    name: 'Town Developer',
    description: 'Upgrade buildings to improve your settlement.',
    icon: <Shield className="h-5 w-5" />,
    color: 'bg-blue-700/30 text-blue-400 border-blue-600/30',
    requirementTypes: ['Upgrade buildings', 'Reach specific building levels']
  }
];

// Helper function to format time remaining
const formatTimeRemaining = (expiresAt: string | Date) => {
  const expires = typeof expiresAt === 'string' ? new Date(expiresAt) : expiresAt;
  const now = new Date();
  const diffMs = expires.getTime() - now.getTime();
  
  if (diffMs <= 0) return 'Expired';
  
  const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
  const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
  
  return `${diffHrs}h ${diffMins}m remaining`;
};

const BountyBoardView = () => {
  const { user } = useDiscordAuth();
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [showUpgradeDialog, setShowUpgradeDialog] = useState<boolean>(false);
  
  // Fetch bounty quests
  const { data: originalQuests = [], isLoading: questsLoading, refetch: refetchQuests } = useQuery<BountyQuest[]>({
    queryKey: ['/api/bounty/quests'],
    refetchInterval: 60000 // Refresh every minute
  });
  
  // Add different rarities to quests for demonstration
  const bountyQuests = React.useMemo(() => {
    return originalQuests.map((quest, index) => {
      const enhancedQuest = {...quest};
      
      // Assign different rarities based on index
      if (index % 4 === 1) {
        (enhancedQuest as any).rarity = 'Rare';
      } else if (index % 4 === 2) {
        (enhancedQuest as any).rarity = 'Epic';
      } else if (index % 4 === 3) {
        (enhancedQuest as any).rarity = 'Legendary';
      } else {
        (enhancedQuest as any).rarity = 'Common';
      }
      
      return enhancedQuest;
    });
  }, [originalQuests]);
  
  // Fetch bounty board building data
  const { data: bountyBoard, isLoading: buildingLoading } = useQuery<BuildingUpgrade>({
    queryKey: ['/api/buildings/bountyBoard']
  });

  // Get frequency badge style
  const getFrequencyStyle = (frequency?: string) => {
    if (!frequency) return 'bg-[#432874]/30 text-[#C8B8DB]'; // Default to daily style
    
    switch (frequency.toLowerCase()) {
      case 'daily':
        return 'bg-[#432874]/30 text-[#C8B8DB]';
      case 'weekly':
        return 'bg-[#00B9AE]/20 text-[#00B9AE]';
      case 'monthly':
        return 'bg-[#FF9D00]/20 text-[#FF9D00]';
      default:
        return 'bg-[#432874]/30 text-[#C8B8DB]';
    }
  };
  
  // Get rarity color
  const getRarityColor = (rarity: string) => {
    switch (rarity?.toLowerCase()) {
      case 'common':
        return { text: 'text-[#4CAF50]', bg: 'bg-[#4CAF50]' };
      case 'rare':
        return { text: 'text-[#2196F3]', bg: 'bg-[#2196F3]' };
      case 'epic':
        return { text: 'text-[#9C27B0]', bg: 'bg-[#9C27B0]' };
      case 'legendary':
        return { text: 'text-[#FF9D00]', bg: 'bg-[#FF9D00]' };
      default:
        return { text: 'text-[#4CAF50]', bg: 'bg-[#4CAF50]' };
    }
  };

  // Rarity Badge Component
  const RarityBadge = ({ rarity }: { rarity: string }) => {
    const rarityClass = {
      common: 'bg-[#4CAF50]/20 text-[#4CAF50] border-[#4CAF50]/30',
      rare: 'bg-[#2196F3]/20 text-[#2196F3] border-[#2196F3]/30',
      epic: 'bg-[#9C27B0]/20 text-[#9C27B0] border-[#9C27B0]/30',
      legendary: 'bg-[#FF9D00]/20 text-[#FF9D00] border-[#FF9D00]/30',
    }[rarity.toLowerCase()] || 'bg-[#4CAF50]/20 text-[#4CAF50] border-[#4CAF50]/30';
    
    return (
      <Badge className={`${rarityClass} text-xs py-0 px-1.5 border`}>
        {rarity}
      </Badge>
    );
  };

  // Get icon for quest based on name or type
  const getQuestIcon = (questName: string) => {
    const questLower = questName.toLowerCase();
    
    if (questLower.includes('farm') || questLower.includes('resource') || questLower.includes('gather')) {
      return <Gem className="h-4 w-4 text-green-400" />;
    } else if (questLower.includes('dungeon') || questLower.includes('enemy') || questLower.includes('slay')) {
      return <Skull className="h-4 w-4 text-red-400" />;
    } else if (questLower.includes('craft') || questLower.includes('forge') || questLower.includes('aura')) {
      return <Flame className="h-4 w-4 text-yellow-400" />;
    } else if (questLower.includes('build') || questLower.includes('upgrade')) {
      return <Shield className="h-4 w-4 text-blue-400" />;
    } else if (questLower.includes('collect') || questLower.includes('gather')) {
      return <Package className="h-4 w-4 text-purple-400" />;
    } else if (questLower.includes('learn') || questLower.includes('skill')) {
      return <BookOpen className="h-4 w-4 text-teal-400" />;
    } else {
      return <Scroll className="h-4 w-4 text-[#C8B8DB]" />;
    }
  };

  // Calculate overall progress for a quest
  const calculateProgress = (quest: BountyQuest) => {
    if (quest.completed) return 100;
    
    if (!quest.requirements || typeof quest.requirements !== 'object') {
      return 0;
    }
    
    const requirements = quest.requirements as Record<string, any>;
    let totalProgress = 0;
    let requirementCount = 0;
    
    Object.values(requirements).forEach((requirement) => {
      if (typeof requirement === 'object' && 'current' in requirement && 'target' in requirement) {
        const progress = Math.min(100, (requirement.current / requirement.target) * 100);
        totalProgress += progress;
        requirementCount++;
      }
    });
    
    return requirementCount > 0 ? Math.round(totalProgress / requirementCount) : 0;
  };

  // Check if quest is completed but not claimed
  const isCompletedNotClaimed = (quest: BountyQuest) => {
    if (quest.completed) return false;
    
    const progress = calculateProgress(quest);
    return progress >= 100;
  };

  // Handle start quest
  const handleStartQuest = async (questId: number) => {
    setIsSubmitting(true);
    
    try {
      // Call API to start quest
      const response = await apiRequest('POST', `/api/bounty/quests/${questId}/start`, {});
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to start quest');
      }
      
      toast({
        title: "Quest Started",
        description: "The quest has been started. Complete the objectives to earn rewards!",
      });
      
      // Refresh quests
      refetchQuests();
    } catch (error: any) {
      console.error('Error starting quest:', error);
      toast({
        title: "Failed to Start Quest",
        description: error.message || "There was an error starting the quest.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Claim quest rewards
  const claimQuestRewards = async (questId: number) => {
    setIsSubmitting(true);
    
    try {
      // Call the API to claim the quest
      const response = await apiRequest('POST', `/api/bounty/quests/${questId}/claim`, {});
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to claim quest rewards');
      }
      
      const data = await response.json();
      
      // Generate reward description from API response
      const claimedQuest = bountyQuests.find(q => q.id === questId);
      let rewardDescription = '';
      
      if (claimedQuest?.rewards && typeof claimedQuest.rewards === 'object') {
        const rewards = claimedQuest.rewards as Record<string, any>;
        if ('rogueCredits' in rewards && rewards.rogueCredits) {
          rewardDescription += `${rewards.rogueCredits} Rogue Credits, `;
        }
        if ('forgeTokens' in rewards && rewards.forgeTokens) {
          rewardDescription += `${rewards.forgeTokens} Forge Tokens, `;
        }
        if ('soulShards' in rewards && rewards.soulShards) {
          rewardDescription += `${rewards.soulShards} Soul Shards, `;
        }
        if ('experience' in rewards && rewards.experience) {
          rewardDescription += `${rewards.experience} XP, `;
        }
      }
      
      // Remove trailing comma and space
      rewardDescription = rewardDescription.replace(/,\s*$/, '');
      
      toast({
        title: "Quest Completed!",
        description: `You've received ${rewardDescription || 'rewards'}!`,
      });
      
      // Refresh quests
      refetchQuests();
    } catch (error: any) {
      console.error('Error claiming rewards:', error);
      toast({
        title: "Failed to Claim Rewards",
        description: error.message || "There was an error claiming the rewards.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle complete bounty
  const handleCompleteBounty = (questId: number) => {
    claimQuestRewards(questId);
  };

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  const isLoading = questsLoading || buildingLoading;
  
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl animate-pulse">Loading bounty board data...</div>
      </div>
    );
  }

  // Filter quests by frequency
  const dailyQuests = bountyQuests.filter(quest => !quest.frequency || (quest.frequency as any)?.toLowerCase() === 'daily');
  const weeklyQuests = bountyQuests.filter(quest => (quest.frequency as any)?.toLowerCase() === 'weekly');

  // Render quest card with tech-style NFT appearance
  const renderQuestCard = (quest: BountyQuest) => {
    const progress = calculateProgress(quest);
    const canClaim = isCompletedNotClaimed(quest);
    const rarityColor = getRarityColor((quest as any).rarity || 'Common');
    
    return (
      <motion.div
        key={quest.id}
        variants={item}
        className={`relative overflow-hidden rounded-lg ${
          quest.completed 
            ? 'border border-green-700/40 shadow-[0_0_10px_rgba(34,197,94,0.15)]' 
            : 'border border-[#432874]/30'
        }`}
        style={{
          background: quest.completed 
            ? 'linear-gradient(135deg, rgba(20, 20, 35, 0.9) 0%, rgba(34, 90, 50, 0.4) 100%)' 
            : 'linear-gradient(135deg, rgba(20, 20, 35, 0.9) 0%, rgba(67, 40, 116, 0.3) 100%)',
          maxWidth: '280px'
        }}
      >
        {/* Tech pattern background */}
        <div className="absolute inset-0 opacity-10 pointer-events-none" 
          style={{
            backgroundImage: 'radial-gradient(circle at 10px 10px, rgba(255,255,255,0.1) 2px, transparent 0)',
            backgroundSize: '20px 20px'
          }}>
        </div>
        
        {/* Top Rarity Bar */}
        <div className={`h-1.5 w-full ${rarityColor.bg}`}></div>
        
        <div className="p-3">
          {/* Header with title and badges */}
          <div className="flex justify-between items-start mb-2">
            <div className="flex items-center">
              {quest.completed ? 
                <div className="bg-green-500/20 p-1 rounded-full mr-2">
                  <CheckCircle2 className="h-4 w-4 text-green-400" />
                </div> : 
                <div className="mr-2">
                  {getQuestIcon(quest.name)}
                </div>
              }
              <h3 className={`font-cinzel font-semibold text-sm ${quest.completed ? 'text-green-400/80' : rarityColor.text}`}>
                {quest.name}
              </h3>
            </div>
            <div className="flex flex-col gap-1 items-end">
              <RarityBadge rarity={(quest as any).rarity || 'Common'} />
              <Badge className={`${getFrequencyStyle((quest as any).frequency)} text-[0.65rem] py-0 px-1.5`}>
                {(quest as any).frequency || 'Daily'}
              </Badge>
            </div>
          </div>
          
          {/* Description */}
          <p className={`text-xs text-[#C8B8DB]/80 mb-3 ${quest.completed ? 'opacity-70' : ''}`}>
            {String(quest.description)}
          </p>
          
          {/* Progress bar */}
          {!quest.completed && (
            <div className="mb-3">
              <div className="flex justify-between mb-1 text-xs">
                <span className="text-[#C8B8DB]/70">Progress</span>
                <span className="text-[#00B9AE]">{progress}%</span>
              </div>
              <div className="h-1.5 bg-[#1A1A2E] rounded-full overflow-hidden">
                <div 
                  className={`h-full ${canClaim ? 'bg-[#00B9AE]' : 'bg-[#432874]'}`}
                  style={{ width: `${progress}%` }}
                ></div>
              </div>
            </div>
          )}
          
          {/* Compact Requirements */}
          {quest.requirements && typeof quest.requirements === 'object' && Object.entries(quest.requirements as Record<string, any>).length > 0 && (
            <div className="mb-3 px-2 py-1.5 bg-[#1A1A2E]/60 rounded border border-[#432874]/20">
              {Object.entries(quest.requirements as Record<string, any>).map(([key, requirement]) => {
                if (typeof requirement === 'object' && 'current' in requirement && 'target' in requirement) {
                  const subProgress = Math.min(100, (requirement.current / requirement.target) * 100);
                  
                  return (
                    <div key={key} className="text-[0.65rem] mb-1 last:mb-0">
                      <div className="flex justify-between">
                        <span className="text-[#C8B8DB]/90">{key}</span>
                        <span className={requirement.current >= requirement.target ? 'text-green-400' : 'text-[#C8B8DB]/70'}>
                          {requirement.current}/{requirement.target}
                        </span>
                      </div>
                    </div>
                  );
                }
                return null;
              }) as React.ReactNode}
            </div>
          )}
          
          {/* Rewards section */}
          <div className="flex justify-between items-center mb-2">
            <div className="flex items-center">
              <GiftIcon className="h-3 w-3 text-[#FFD700] mr-1" />
              <span className="text-xs font-semibold text-[#FFD700]">Rewards</span>
            </div>
            
            {quest.completed && (
              <span className="text-[0.65rem] text-green-400">
                Completed {new Date((quest as any).completedAt || Date.now()).toLocaleDateString()}
              </span>
            )}
          </div>
          
          <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[0.65rem] mb-3">
            {quest.rewards && typeof quest.rewards === 'object' && Object.entries(quest.rewards as Record<string, any>).map(([key, value]) => (
              <div key={key} className="flex items-center">
                <div className="w-2 h-2 rounded-full bg-[#432874]/70 mr-1"></div>
                <span className="text-[#C8B8DB]/90">{key}: </span>
                <span className="ml-1 text-[#FFD700]">{typeof value === 'object' ? JSON.stringify(value) : value}</span>
              </div>
            )) as React.ReactNode}
          </div>
          
          {/* Claim button */}
          {!quest.completed && canClaim && (
            <Button 
              size="sm"
              className="w-full bg-[#00B9AE] hover:bg-[#00B9AE]/80 text-black text-xs py-1 h-7"
              onClick={() => handleCompleteBounty(quest.id)}
              disabled={isSubmitting}
            >
              {isSubmitting ? 
                <Loader2 className="h-3 w-3 animate-spin mr-1" /> : 
                <CheckCircle2 className="h-3 w-3 mr-1" />
              }
              Claim Rewards
            </Button>
          )}
        </div>
      </motion.div>
    )
  };

  return (
    <>
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Bounty Board</h1>
        <p className="text-[#C8B8DB]/80">
          Complete bounties to earn valuable rewards including Forge Tokens, Rogue Credits, and Soul Shards.
        </p>
      </div>
      
      {/* Stats and Building Info */}
      <div className="bg-gradient-to-r from-[#432874]/60 to-[#1A1A2E] rounded-xl p-6 mb-6 relative overflow-hidden">
        <div className="absolute top-0 right-0 w-64 h-64 bg-[#FF9D00]/10 rounded-full -mr-32 -mt-32 blur-md"></div>
        <div className="absolute -bottom-16 -left-16 w-64 h-64 bg-[#00B9AE]/10 rounded-full blur-md"></div>
        
        <div className="relative flex flex-col md:flex-row md:items-center md:justify-between gap-4 z-10">
          <div>
            <h2 className="text-xl font-cinzel font-bold text-[#FF9D00] mb-1">Bounty Board Level {bountyBoard?.currentLevel || 1}</h2>
            
            <div className="text-sm text-[#C8B8DB]/80 mb-2">
              Complete bounties to earn valuable rewards and increase your character's renown.
            </div>
            
            <div className="flex items-center text-[#C8B8DB]/70 mt-2">
              <CalendarDays className="h-4 w-4 mr-1" />
              <span className="text-sm">Daily reset in {formatTimeRemaining(new Date(new Date().setHours(24, 0, 0, 0)))}</span>
            </div>
          </div>
          
          <div className="flex gap-3">
            <div className="bg-[#1A1A2E]/50 px-3 py-2 rounded-lg flex items-center">
              <div className="mr-2 bg-[#432874]/30 p-1.5 rounded-full">
                <List className="h-4 w-4 text-[#00B9AE]" />
              </div>
              <div>
                <div className="text-xs text-[#C8B8DB]/70">Active Quests</div>
                <div className="font-semibold text-[#C8B8DB]">{bountyQuests.filter(q => !q.completed).length}</div>
              </div>
            </div>
            
            <div className="bg-[#1A1A2E]/50 px-3 py-2 rounded-lg flex items-center">
              <div className="mr-2 bg-[#432874]/30 p-1.5 rounded-full">
                <CheckCircle2 className="h-4 w-4 text-green-400" />
              </div>
              <div>
                <div className="text-xs text-[#C8B8DB]/70">Completed</div>
                <div className="font-semibold text-[#C8B8DB]">{bountyQuests.filter(q => q.completed).length}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Quest Tabs */}
      <Tabs defaultValue="daily" className="w-full">
        <TabsList className="bg-[#432874]/20 mb-6">
          <TabsTrigger value="daily" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Calendar className="h-4 w-4 mr-2" />
            Daily Quests
          </TabsTrigger>
          <TabsTrigger value="weekly" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <CalendarDays className="h-4 w-4 mr-2" />
            Weekly Quests
          </TabsTrigger>
          <TabsTrigger value="all" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <List className="h-4 w-4 mr-2" />
            All Quests
          </TabsTrigger>
        </TabsList>
        
        {/* Daily Quests Tab */}
        <TabsContent value="daily">
          <h2 className="text-lg font-cinzel font-bold text-[#FF9D00] mb-4">Daily Quests</h2>
          
          {dailyQuests.length === 0 ? (
            <div className="bg-[#1F1D36]/50 rounded-lg p-8 text-center">
              <List className="h-12 w-12 mx-auto mb-4 text-[#C8B8DB]/50" />
              <p className="text-[#C8B8DB]/80 mb-4">
                No daily quests are available at the moment. Upgrade your Bounty Board to unlock more quests!
              </p>
            </div>
          ) : (
            <motion.div
              variants={container}
              initial="hidden"
              animate="show"
              className="grid gap-6 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4"
            >
              {dailyQuests.map((quest) => renderQuestCard(quest))}
            </motion.div>
          )}
        </TabsContent>
        
        {/* Weekly Quests Tab */}
        <TabsContent value="weekly">
          <h2 className="text-lg font-cinzel font-bold text-[#FF9D00] mb-4">Weekly Quests</h2>
          
          {weeklyQuests.length === 0 ? (
            <div className="bg-[#1F1D36]/50 rounded-lg p-8 text-center">
              <CalendarDays className="h-12 w-12 mx-auto mb-4 text-[#C8B8DB]/50" />
              <p className="text-[#C8B8DB]/80 mb-4">
                No weekly quests are available at the moment. Weekly quests become available at Bounty Board Level 2.
              </p>
            </div>
          ) : (
            <motion.div
              variants={container}
              initial="hidden"
              animate="show"
              className="grid gap-6 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4"
            >
              {weeklyQuests.map((quest) => renderQuestCard(quest))}
            </motion.div>
          )}
        </TabsContent>
        
        {/* All Quests Tab */}
        <TabsContent value="all">
          <h2 className="text-lg font-cinzel font-bold text-[#FF9D00] mb-4">All Quests</h2>
          
          {bountyQuests.length === 0 ? (
            <div className="bg-[#1F1D36]/50 rounded-lg p-8 text-center">
              <List className="h-12 w-12 mx-auto mb-4 text-[#C8B8DB]/50" />
              <p className="text-[#C8B8DB]/80 mb-4">
                No quests are available at the moment. Upgrade your Bounty Board to unlock more quests!
              </p>
            </div>
          ) : (
            <motion.div
              variants={container}
              initial="hidden"
              animate="show"
              className="grid gap-6 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4"
            >
              {bountyQuests.map((quest) => renderQuestCard(quest))}
            </motion.div>
          )}
        </TabsContent>
      </Tabs>
    </>
  );
};

export default BountyBoardView;

=== client/src/components/collections/CollectionsView.tsx ===
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { useToast } from '@/hooks/use-toast';
import { queryClient } from '@/lib/queryClient';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Progress } from '@/components/ui/progress';
import { 
  Star, 
  Sparkles, 
  Swords, 
  Zap, 
  Shield, 
  Flame,
  Wind,
  Droplets,
  Mountain,
  Activity,
  BrainCircuit,
  Lightbulb,
  Lock
} from 'lucide-react';

const CollectionsView = () => {
  const [selectedTab, setSelectedTab] = useState('active-collections');
  const [collectionsSubTab, setCollectionsSubTab] = useState('active-collections');
  const [equippedTitle, setEquippedTitle] = useState<number | null>(1); // Default to first title
  
  const gameStore = useGameStore();
  const { user } = useDiscordAuth();
  const { toast } = useToast();
  
  // Get active characters and auras to calculate account power
  // Destructure explicitly to ensure the component rerenders when these values change
  const { 
    characters, 
    auraInventory, 
    buildings 
  } = useGameStore();
  
  // Force refresh character and aura data when the collections component mounts
  useEffect(() => {
    // Refresh character and aura data to ensure we have the latest stats
    console.log('Collections component mounted - refreshing character and aura data');
    queryClient.invalidateQueries({ queryKey: ['/api/characters'] });
    queryClient.invalidateQueries({ queryKey: ['/api/auras'] });
    queryClient.refetchQueries({ queryKey: ['/api/characters'] });
    queryClient.refetchQueries({ queryKey: ['/api/auras'] });
  }, []);
  
  // Mock perks data (for skill tree)
  const [perks, setPerks] = useState([
    {
      id: 1,
      name: "Essence Harvester",
      description: "Increases Essence gain by 10%",
      level: 2,
      maxLevel: 5,
      icon: <Zap className="h-8 w-8 text-[#4CAF50]" />,
      effect: "+10% Essence per level",
      cost: 1,
      position: { x: 1, y: 1 }
    },
    {
      id: 2,
      name: "Combat Specialist",
      description: "Increases all character stats by 5%",
      level: 1,
      maxLevel: 5,
      icon: <Swords className="h-8 w-8 text-[#DC143C]" />,
      effect: "+5% Character Stats per level",
      cost: 1, 
      position: { x: 2, y: 1 }
    },
    {
      id: 3,
      name: "Forge Master",
      description: "Reduces Aura forging time by 10%",
      level: 0,
      maxLevel: 3,
      icon: <Flame className="h-8 w-8 text-[#FF9D00]" />,
      effect: "-10% Forging Time per level",
      cost: 1,
      position: { x: 3, y: 1 }
    },
    {
      id: 4,
      name: "Resilient Mind",
      description: "Increases Focus stat by 15%",
      level: 0,
      maxLevel: 3,
      icon: <BrainCircuit className="h-8 w-8 text-[#9C27B0]" />,
      effect: "+15% Focus per level",
      cost: 1,
      position: { x: 2, y: 2 }
    },
    {
      id: 5,
      name: "Vital Energies",
      description: "Increases Vitality stat by 15%",
      level: 0,
      maxLevel: 3,
      icon: <Activity className="h-8 w-8 text-[#F44336]" />,
      effect: "+15% Vitality per level",
      cost: 1,
      position: { x: 1, y: 2 }
    },
    {
      id: 6,
      name: "Strategic Mind",
      description: "Increases Defense stat by 15%",
      level: 0,
      maxLevel: 3,
      icon: <Shield className="h-8 w-8 text-[#2196F3]" />,
      effect: "+15% Defense per level",
      cost: 1,
      position: { x: 3, y: 2 }
    },
    {
      id: 7,
      name: "Enlightened Spirit",
      description: "Increases all resource gathering by 20%",
      level: 0,
      maxLevel: 2,
      icon: <Lightbulb className="h-8 w-8 text-[#FFD700]" />,
      effect: "+20% Resource Gathering per level",
      cost: 2,
      position: { x: 2, y: 3 }
    }
  ]);
  
  // Calculate account power based on characters, auras, and buildings
  const calculateAccountPower = () => {
    let totalPower = 0;
    
    // Add power from active characters with their aura bonuses
    characters.forEach(character => {
      // Base stats directly from character
      const attack = character.attack || 0;
      const vitality = character.vitality || 0;
      const speed = character.speed || 0;
      const focus = character.focus || 0;
      const accuracy = character.accuracy || 0;
      const defense = character.defense || 0;
      const resilience = character.resilience || 0;
      
      // Get character's equipped aura, if any
      const equippedAuraId = character.equippedAuraId;
      let auraBonus = { attack: 0, vitality: 0, speed: 0, focus: 0, accuracy: 0, defense: 0, resilience: 0 };
      
      if (equippedAuraId) {
        // Find the aura in inventory
        const equippedAura = auraInventory.find((aura: any) => aura.id === equippedAuraId);
        if (equippedAura) {
          // Get the actual aura stats directly
          auraBonus = {
            attack: equippedAura.attack || 0,
            vitality: equippedAura.vitality || 0,
            speed: equippedAura.speed || 0,
            focus: equippedAura.focus || 0,
            accuracy: equippedAura.accuracy || 0,
            defense: equippedAura.defense || 0,
            resilience: equippedAura.resilience || 0
          };
        }
      }
      
      // Sum up all character stats including aura bonuses
      const totalAttack = attack + auraBonus.attack;
      const totalVitality = vitality + auraBonus.vitality;
      const totalSpeed = speed + auraBonus.speed;
      const totalFocus = focus + auraBonus.focus;
      const totalAccuracy = accuracy + auraBonus.accuracy;
      const totalDefense = defense + auraBonus.defense;
      const totalResilience = resilience + auraBonus.resilience;
      
      // Add all character stats to total power
      totalPower += totalAttack + totalVitality + totalSpeed + totalFocus + 
                   totalAccuracy + totalDefense + totalResilience;
                   
      // Add level bonus
      totalPower += (character.level || 1) * 100;
    });
    
    // Add building levels (100 points per building level)
    const buildingLevels = buildings.reduce((total: number, building: any) => total + (building.level || 0), 0);
    totalPower += buildingLevels * 100;
    
    console.log('Account power calculated:', totalPower);
    console.log('Characters count:', characters.length);
    console.log('Auras count:', auraInventory.length);
    
    return totalPower;
  };
  
  // Recalculate account power whenever any of the dependencies change
  const accountPower = calculateAccountPower();
  const skillPoints = Math.floor(accountPower / 1000) - perks.reduce((total, perk) => total + perk.level, 0);
  
  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  // Collection Sets with Themes
  const [collectionSets, setCollectionSets] = useState([
    {
      id: 1,
      name: "Elemental Acolyte",
      description: "Master the four basic elements to gain elemental mastery",
      completed: false,
      claimed: false,
      auras: [
        {
          id: 1,
          name: "Inferno's Embrace",
          type: "Fire",
          discovered: true,
          imageUrl: "https://images.unsplash.com/photo-1519930439097-f5ed5657cb4f?w=150&h=150&fit=crop",
          icon: <Flame className="h-12 w-12 text-[#FF4500]" />,
          description: "Fiery auras enhance attack power and focus.",
          unlockMethod: "Automatically unlocked",
          element: "Fire"
        },
        {
          id: 2,
          name: "Ocean's Mercy",
          type: "Water",
          discovered: true,
          imageUrl: "https://images.unsplash.com/photo-1551525212-a1f3d3b8e242?w=150&h=150&fit=crop",
          icon: <Droplets className="h-12 w-12 text-[#1E90FF]" />,
          description: "Water auras enhance defense and resilience.",
          unlockMethod: "Automatically unlocked",
          element: "Water"
        },
        {
          id: 3,
          name: "Stoneguard's Pact",
          type: "Earth",
          discovered: false,
          imageUrl: "https://images.unsplash.com/photo-1523567353982-bd9af0d8383c?w=150&h=150&fit=crop",
          icon: <Mountain className="h-12 w-12 text-[#8B4513]" />,
          description: "Earth auras enhance vitality and defense.",
          unlockMethod: "Complete Earth Cavern Dungeon",
          element: "Earth"
        },
        {
          id: 4,
          name: "Zephyr's Whisper",
          type: "Wind",
          discovered: false,
          imageUrl: "https://images.unsplash.com/photo-1533551037358-c8f7182cdb79?w=150&h=150&fit=crop",
          icon: <Wind className="h-12 w-12 text-[#32CD32]" />,
          description: "Wind auras enhance speed and accuracy.",
          unlockMethod: "Complete Wind Temple Dungeon",
          element: "Wind"
        }
      ],
      reward: {
        name: "Elemental Harmony",
        description: "Increases all elemental damage by 15%",
        type: "Passive Skill"
      }
    },
    {
      id: 2,
      name: "Experimental Fusion",
      description: "Combine rare experimental auras to unlock advanced fusion techniques",
      completed: false,
      claimed: false,
      auras: [
        {
          id: 5,
          name: "Aura of Growth",
          type: "Plant",
          discovered: false,
          imageUrl: "https://images.unsplash.com/photo-1518531933037-91b2f5f229cc?w=150&h=150&fit=crop",
          icon: <Sparkles className="h-12 w-12 text-[#9C27B0]" />,
          description: "A mysterious aura that enhances growth and resource collection. 'From earth and sky, abundance flows, when patient hands plant what they know.'",
          unlockMethod: "Complete 20 farming tasks with Level 5+ Characters",
          element: "Nature"
        },
        {
          id: 6,
          name: "Typhoon Aura",
          type: "Storm",
          discovered: false,
          imageUrl: "https://images.unsplash.com/photo-1610741083757-1ae88e1a17f7?w=150&h=150&fit=crop",
          icon: <Activity className="h-12 w-12 text-[#8BC34A]" />,
          description: "A powerful storm-based aura with devastating effects. 'When mountains tremble and waters part, nature's fury finds its mark.'",
          unlockMethod: "Clear 10 Elite Dungeons with Wind Aura-equipped Characters",
          element: "Wind"
        },
        {
          id: 7,
          name: "Sentinel Aura",
          type: "Guardian",
          discovered: false,
          imageUrl: "https://images.unsplash.com/photo-1542273917363-3b1817f69a2d?w=150&h=150&fit=crop",
          icon: <BrainCircuit className="h-12 w-12 text-[#7B68EE]" />,
          description: "A mysterious aura that enhances protective prowess. 'In silent vigilance, guardians stand as the last line of defense.'",
          unlockMethod: "Successfully defend your base from 5 raid attacks",
          element: "Earth"
        }
      ],
      reward: {
        name: "Experimental Mastery",
        description: "Reduces aura fusion costs by 25%",
        type: "Passive Skill"
      }
    }
  ]);
  
  // Completed collections for the Claimed tab
  const [claimedCollections, setClaimedCollections] = useState([
    {
      id: 3,
      name: "Arcane Artificer",
      description: "Collect all arcane-based auras to unlock magical potential",
      completed: true,
      claimed: true,
      auras: [
        {
          id: 8,
          name: "Mana Weaver",
          discovered: true,
          imageUrl: "https://images.unsplash.com/photo-1589254065878-42c9da997008?w=150&h=150&fit=crop",
        },
        {
          id: 9,
          name: "Spellbinder",
          discovered: true,
          imageUrl: "https://images.unsplash.com/photo-1518542331925-4e91e9aa0074?w=150&h=150&fit=crop",
        },
        {
          id: 10,
          name: "Arcane Sight",
          discovered: true,
          imageUrl: "https://images.unsplash.com/photo-1629976801555-c12db8b3a330?w=150&h=150&fit=crop",
        }
      ],
      reward: {
        name: "Arcane Efficiency",
        description: "Reduces all ability cooldowns by 15%",
        type: "Passive Skill"
      },
      dateCompleted: "2025-03-12"
    }
  ]);

  // Mock titles data
  const titles = [
    {
      id: 1,
      name: "The Collector",
      description: "Collect 50 unique items",
      progress: 70,
      icon: <Star className="h-8 w-8 text-[#FFD700]" />,
      requirements: "50/50 unique items collected",
      status: "Unlocked"
    },
    {
      id: 2,
      name: "Dungeon Conqueror",
      description: "Complete all legendary dungeons",
      progress: 25,
      icon: <Swords className="h-8 w-8 text-[#DC143C]" />,
      requirements: "2/8 legendary dungeons completed",
      status: "Locked"
    },
    {
      id: 3,
      name: "Forge Grandmaster",
      description: "Create 10 legendary Auras",
      progress: 40,
      icon: <Flame className="h-8 w-8 text-[#FF9D00]" />,
      requirements: "4/10 legendary Auras created",
      status: "Locked"
    }
  ];

  const handleUpgradePerk = (perkId: number) => {
    // API call to upgrade a perk would go here
    setPerks(perks.map(perk => {
      if (perk.id === perkId && perk.level < perk.maxLevel) {
        return { ...perk, level: perk.level + 1 };
      }
      return perk;
    }));
    
    toast({
      title: "Skill Allocated",
      description: "Your account-wide bonus has been increased.",
    });
  };
  
  const handleClaimReward = (collectionId: number) => {
    // In a real implementation, this would make an API call to claim the collection reward
    // Update the collection to mark it as claimed
    setCollectionSets(prev => 
      prev.map(collection => 
        collection.id === collectionId 
          ? { ...collection, claimed: true } 
          : collection
      )
    );
    
    // Find the collection to get its reward info
    const collection = collectionSets.find(c => c.id === collectionId);
    
    // Move the claimed collection to the claimed collections list
    if (collection) {
      setClaimedCollections(prev => [
        ...prev, 
        { 
          ...collection, 
          claimed: true, 
          completed: true,
          dateCompleted: new Date().toISOString().split('T')[0]
        }
      ]);
      
      toast({
        title: `${collection.name} Reward Claimed!`,
        description: `You received the ${collection.reward.name} passive skill: ${collection.reward.description}`,
      });
    }
  };
  
  const handleEquipTitle = (titleId: number) => {
    // API call to equip a title would go here
    setEquippedTitle(titleId);
    const title = titles.find(t => t.id === titleId);
    
    toast({
      title: "Title Equipped",
      description: `You are now known as ${title?.name}.`,
    });
  };

  return (
    <>
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Collections</h1>
        <p className="text-[#C8B8DB]/80">
          Discover elemental auras, unlock account-wide bonuses, and earn exclusive titles.
        </p>
      </div>
      
      {/* Account Power Display */}
      <div className="mb-8 bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-cinzel font-bold text-[#FF9D00]">Account Power</h2>
          <div className="bg-[#432874]/30 px-4 py-2 rounded-lg">
            <span className="text-2xl font-bold text-[#FF9D00]">{accountPower}</span>
          </div>
        </div>
        
        <div className="flex justify-between items-center mb-2">
          <span className="text-[#C8B8DB]/80">Available Skill Points</span>
          <span className="text-[#00B9AE] font-semibold">{skillPoints}</span>
        </div>
        
        <div className="h-2 bg-[#1F1D36] rounded-full overflow-hidden mb-4">
          <div 
            className="h-full bg-[#FF9D00]" 
            style={{ width: `${((accountPower % 1000) / 1000) * 100}%` }}
          ></div>
        </div>
        
        <p className="text-[#C8B8DB]/80 text-sm">
          Account Power combines the total stats of all Characters with their Aura Stat Multipliers plus 100 points for each building Level. Earn 1 Skill Point for every 1,000 Account Power.
        </p>
      </div>
      
      {/* Collection Tabs */}
      <Tabs defaultValue="collections" value={selectedTab} onValueChange={setSelectedTab} className="w-full">
        <TabsList className="bg-[#432874]/20 mb-6">
          <TabsTrigger value="collections" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Star className="h-4 w-4 mr-2" />
            Collections
          </TabsTrigger>
          <TabsTrigger value="perks" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Sparkles className="h-4 w-4 mr-2" />
            Account Perks
          </TabsTrigger>
          <TabsTrigger value="titles" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Shield className="h-4 w-4 mr-2" />
            Titles
          </TabsTrigger>
        </TabsList>
        
        {/* Collections Tab */}
        <TabsContent value="collections">
          <div className="mb-6">
            <h3 className="text-xl font-cinzel font-bold text-[#FF9D00] mb-4">Aura Collections</h3>
            <p className="text-[#C8B8DB]/80 mb-4">
              Discover and collect elemental auras to enhance your power and unlock special abilities.
            </p>
            
            {/* Collections Sub-Tabs */}
            <Tabs value={collectionsSubTab} onValueChange={setCollectionsSubTab} className="mt-2">
              <TabsList className="bg-[#432874]/20 mb-6">
                <TabsTrigger 
                  value="active-collections" 
                  className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]"
                >
                  <Star className="h-4 w-4 mr-2" />
                  Active Collections
                </TabsTrigger>
                <TabsTrigger 
                  value="claimed-collections" 
                  className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]"
                >
                  <Sparkles className="h-4 w-4 mr-2" />
                  Claimed Collections
                </TabsTrigger>
              </TabsList>
              
              {/* Active Collections Tab */}
              <TabsContent value="active-collections">
                {collectionSets.map((collection) => (
                  <motion.div
                    key={collection.id}
                    variants={container}
                    initial="hidden"
                    animate="show"
                    className="mb-10 bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-6"
                  >
                    <div className="flex justify-between items-start mb-6">
                      <div>
                        <h4 className="text-xl font-cinzel font-bold text-[#FF9D00] mb-1">{collection.name}</h4>
                        <p className="text-[#C8B8DB]/80 text-sm">{collection.description}</p>
                      </div>
                      
                      {/* Check if all auras are discovered */}
                      {collection.auras.every(aura => aura.discovered) && !collection.claimed ? (
                        <Button 
                          className="bg-[#FFD700]/20 hover:bg-[#FFD700]/30 text-[#FFD700] border border-[#FFD700]/30"
                          size="sm"
                          onClick={() => handleClaimReward(collection.id)}
                        >
                          <Star className="h-4 w-4 mr-2" />
                          Claim Reward
                        </Button>
                      ) : collection.claimed ? (
                        <Badge className="bg-[#00B9AE]/20 text-[#00B9AE]">
                          <Sparkles className="h-4 w-4 mr-2" />
                          Reward Claimed
                        </Badge>
                      ) : (
                        <Badge className="bg-[#432874]/30 text-[#C8B8DB]/80 border border-[#432874]/50">
                          <Star className="h-4 w-4 mr-2" />
                          {collection.auras.filter(aura => aura.discovered).length}/{collection.auras.length} Collected
                        </Badge>
                      )}
                    </div>
                    
                    {/* Aura Circles */}
                    <div className="flex flex-wrap justify-center gap-6 md:gap-8 mb-6">
                      {collection.auras.map((aura) => (
                        <motion.div
                          key={aura.id}
                          variants={item}
                          className="flex flex-col items-center"
                        >
                          <div className={`relative rounded-full overflow-hidden w-24 h-24 mb-3 ${!aura.discovered ? 'filter grayscale opacity-50' : ''}`}>
                            <img 
                              src={aura.imageUrl} 
                              alt={aura.discovered ? aura.name : "Mystery Aura"} 
                              className="w-full h-full object-cover"
                            />
                            <div className="absolute inset-0 bg-gradient-to-t from-[#1A1A2E]/80 to-transparent"></div>
                            
                            {/* Show icon on the circle */}
                            <div className="absolute inset-0 flex items-center justify-center">
                              {aura.discovered ? (
                                <div className="bg-[#432874]/40 p-2 rounded-full">
                                  {aura.icon}
                                </div>
                              ) : (
                                <div className="bg-[#1A1A2E]/60 p-2 rounded-full">
                                  <Lock className="h-8 w-8 text-[#C8B8DB]/60" />
                                </div>
                              )}
                            </div>
                          </div>
                          
                          <h5 className="text-center font-cinzel font-bold text-sm mb-1">
                            {aura.discovered ? aura.name : "???"}
                          </h5>
                          
                          <Badge className={`${aura.discovered ? 'bg-[#432874]/30 text-[#C8B8DB]' : 'bg-[#FF9D00]/30 text-[#FF9D00]'} border-[#432874]/50`}>
                            {aura.discovered ? 'Discovered' : 'Locked'}
                          </Badge>
                        </motion.div>
                      ))}
                    </div>
                    
                    {/* Reward Info */}
                    <div className="bg-[#432874]/20 p-4 rounded-lg">
                      <div className="flex items-center mb-3">
                        <Sparkles className="h-5 w-5 text-[#FFD700] mr-2 flex-shrink-0" />
                        <h5 className="font-cinzel font-bold text-[#FFD700]">Collection Reward</h5>
                      </div>
                      <div className="ml-7">
                        <p className="text-sm text-[#C8B8DB] font-semibold mb-1">{collection.reward.name}</p>
                        <p className="text-xs text-[#C8B8DB]/80">{collection.reward.description}</p>
                        <p className="text-xs text-[#C8B8DB]/80 mt-1">Type: {collection.reward.type}</p>
                      </div>
                    </div>
                  </motion.div>
                ))}
              </TabsContent>
              
              {/* Claimed Collections Tab */}
              <TabsContent value="claimed-collections">
                {claimedCollections.length === 0 ? (
                  <div className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-8 text-center">
                    <Sparkles className="h-12 w-12 mx-auto mb-4 text-[#C8B8DB]/50" />
                    <p className="text-[#C8B8DB]/80 mb-4">
                      You haven't claimed any collection rewards yet. Complete collection sets to earn powerful rewards!
                    </p>
                  </div>
                ) : (
                  claimedCollections.map((collection) => (
                    <motion.div
                      key={collection.id}
                      variants={container}
                      initial="hidden"
                      animate="show"
                      className="mb-10 bg-[#1A1A2E] border border-[#00B9AE]/30 rounded-xl p-6"
                    >
                      <div className="flex justify-between items-start mb-6">
                        <div>
                          <h4 className="text-xl font-cinzel font-bold text-[#00B9AE] mb-1">{collection.name}</h4>
                          <p className="text-[#C8B8DB]/80 text-sm">{collection.description}</p>
                        </div>
                        
                        <div className="flex items-center">
                          <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] mr-3">
                            <Sparkles className="h-4 w-4 mr-2" />
                            Reward Claimed
                          </Badge>
                          
                          <div className="text-xs text-[#C8B8DB]/70">
                            Completed: {collection.dateCompleted}
                          </div>
                        </div>
                      </div>
                      
                      {/* Aura Circles */}
                      <div className="flex flex-wrap justify-center gap-6 md:gap-8 mb-6">
                        {collection.auras.map((aura) => (
                          <motion.div
                            key={aura.id}
                            variants={item}
                            className="flex flex-col items-center"
                          >
                            <div className="relative rounded-full overflow-hidden w-24 h-24 mb-3">
                              <img 
                                src={aura.imageUrl} 
                                alt={aura.name || "Aura"} 
                                className="w-full h-full object-cover"
                              />
                              <div className="absolute inset-0 bg-gradient-to-t from-[#1A1A2E]/80 to-transparent"></div>
                            </div>
                            
                            <h5 className="text-center font-cinzel font-bold text-sm mb-1">
                              {aura.name}
                            </h5>
                            
                            <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] border-[#00B9AE]/30">
                              Collected
                            </Badge>
                          </motion.div>
                        ))}
                      </div>
                      
                      {/* Reward Info */}
                      <div className="bg-[#00B9AE]/10 p-4 rounded-lg">
                        <div className="flex items-center mb-3">
                          <Sparkles className="h-5 w-5 text-[#00B9AE] mr-2 flex-shrink-0" />
                          <h5 className="font-cinzel font-bold text-[#00B9AE]">Claimed Reward</h5>
                        </div>
                        <div className="ml-7">
                          <p className="text-sm text-[#C8B8DB] font-semibold mb-1">{collection.reward.name}</p>
                          <p className="text-xs text-[#C8B8DB]/80">{collection.reward.description}</p>
                          <p className="text-xs text-[#C8B8DB]/80 mt-1">Type: {collection.reward.type}</p>
                        </div>
                      </div>
                    </motion.div>
                  ))
                )}
              </TabsContent>
            </Tabs>
          </div>
        </TabsContent>
        
        {/* Account Perks Tab - Skill Tree */}
        <TabsContent value="perks">
          <div className="mb-6">
            <h3 className="text-xl font-cinzel font-bold text-[#FF9D00] mb-2">Account Perks</h3>
            <p className="text-[#C8B8DB]/80 mb-2">
              Allocate your Skill Points to enhance your account-wide abilities.
            </p>
            <div className="flex justify-between items-center bg-[#1F1D36] p-3 rounded-lg">
              <span className="text-[#C8B8DB]">Available Skill Points:</span>
              <span className="text-[#00B9AE] font-bold">{skillPoints}</span>
            </div>
          </div>
          
          {/* Skill Tree Grid */}
          <div className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl p-6 mb-6">
            <div className="relative" style={{ minHeight: '500px' }}>
              {/* Skill connections (lines) */}
              <svg className="absolute inset-0 w-full h-full" style={{ zIndex: 0 }}>
                {/* Tier 1 to Tier 2 connections */}
                <line x1="25%" y1="25%" x2="25%" y2="50%" stroke="#432874" strokeWidth="2" />
                <line x1="50%" y1="25%" x2="25%" y2="50%" stroke="#432874" strokeWidth="2" />
                <line x1="50%" y1="25%" x2="50%" y2="50%" stroke="#432874" strokeWidth="2" />
                <line x1="50%" y1="25%" x2="75%" y2="50%" stroke="#432874" strokeWidth="2" />
                <line x1="75%" y1="25%" x2="75%" y2="50%" stroke="#432874" strokeWidth="2" />
                
                {/* Tier 2 to Tier 3 connections */}
                <line x1="25%" y1="50%" x2="50%" y2="75%" stroke="#432874" strokeWidth="2" />
                <line x1="50%" y1="50%" x2="50%" y2="75%" stroke="#432874" strokeWidth="2" />
                <line x1="75%" y1="50%" x2="50%" y2="75%" stroke="#432874" strokeWidth="2" />
              </svg>
              
              {/* Skill Nodes */}
              <div className="grid grid-rows-3 gap-8" style={{ position: 'relative', zIndex: 1 }}>
                {/* Row 1 */}
                <div className="flex justify-around">
                  {perks.filter(p => p.position.y === 1).map(perk => (
                    <motion.div
                      key={perk.id}
                      whileHover={{ scale: 1.05 }}
                      className="bg-[#1F1D36] border border-[#432874]/50 rounded-xl p-4 shadow-lg w-64"
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center">
                          <div className="bg-[#432874]/30 p-2 rounded-full">
                            {perk.icon}
                          </div>
                          <div className="ml-3">
                            <h4 className="text-md font-cinzel font-semibold text-[#FF9D00]">{perk.name}</h4>
                            <p className="text-xs text-[#C8B8DB]/70">{perk.description}</p>
                          </div>
                        </div>
                      </div>
                      
                      <div className="mt-2">
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-[#C8B8DB]/80">Level</span>
                          <span className="text-[#FF9D00]">{perk.level}/{perk.maxLevel}</span>
                        </div>
                        <div className="h-1.5 bg-[#1A1A2E] rounded-full overflow-hidden">
                          <div 
                            className="h-full bg-[#FF9D00]" 
                            style={{ width: `${(perk.level / perk.maxLevel) * 100}%` }}
                          ></div>
                        </div>
                      </div>
                      
                      <div className="mt-3">
                        {perk.level < perk.maxLevel ? (
                          <Button
                            size="sm"
                            className="w-full bg-[#432874] hover:bg-[#432874]/80 text-xs"
                            onClick={() => handleUpgradePerk(perk.id)}
                            disabled={skillPoints < perk.cost}
                          >
                            <Star className="h-3 w-3 mr-1" />
                            Upgrade ({perk.cost})
                          </Button>
                        ) : (
                          <div className="w-full flex items-center justify-center bg-[#00B9AE]/20 py-1.5 rounded-lg text-xs text-[#00B9AE]">
                            <Sparkles className="h-3 w-3 mr-1" />
                            Maximum Level
                          </div>
                        )}
                      </div>
                    </motion.div>
                  ))}
                </div>
                
                {/* Row 2 */}
                <div className="flex justify-around">
                  {perks.filter(p => p.position.y === 2).map(perk => (
                    <motion.div
                      key={perk.id}
                      whileHover={{ scale: 1.05 }}
                      className="bg-[#1F1D36] border border-[#432874]/50 rounded-xl p-4 shadow-lg w-64"
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center">
                          <div className="bg-[#432874]/30 p-2 rounded-full">
                            {perk.icon}
                          </div>
                          <div className="ml-3">
                            <h4 className="text-md font-cinzel font-semibold text-[#FF9D00]">{perk.name}</h4>
                            <p className="text-xs text-[#C8B8DB]/70">{perk.description}</p>
                          </div>
                        </div>
                      </div>
                      
                      <div className="mt-2">
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-[#C8B8DB]/80">Level</span>
                          <span className="text-[#FF9D00]">{perk.level}/{perk.maxLevel}</span>
                        </div>
                        <div className="h-1.5 bg-[#1A1A2E] rounded-full overflow-hidden">
                          <div 
                            className="h-full bg-[#FF9D00]" 
                            style={{ width: `${(perk.level / perk.maxLevel) * 100}%` }}
                          ></div>
                        </div>
                      </div>
                      
                      <div className="mt-3">
                        {perk.level < perk.maxLevel ? (
                          <Button
                            size="sm"
                            className="w-full bg-[#432874] hover:bg-[#432874]/80 text-xs"
                            onClick={() => handleUpgradePerk(perk.id)}
                            disabled={skillPoints < perk.cost}
                          >
                            <Star className="h-3 w-3 mr-1" />
                            Upgrade ({perk.cost})
                          </Button>
                        ) : (
                          <div className="w-full flex items-center justify-center bg-[#00B9AE]/20 py-1.5 rounded-lg text-xs text-[#00B9AE]">
                            <Sparkles className="h-3 w-3 mr-1" />
                            Maximum Level
                          </div>
                        )}
                      </div>
                    </motion.div>
                  ))}
                </div>
                
                {/* Row 3 */}
                <div className="flex justify-center">
                  {perks.filter(p => p.position.y === 3).map(perk => (
                    <motion.div
                      key={perk.id}
                      whileHover={{ scale: 1.05 }}
                      className="bg-[#1F1D36] border border-[#432874]/50 rounded-xl p-4 shadow-lg w-64"
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center">
                          <div className="bg-[#432874]/30 p-2 rounded-full">
                            {perk.icon}
                          </div>
                          <div className="ml-3">
                            <h4 className="text-md font-cinzel font-semibold text-[#FF9D00]">{perk.name}</h4>
                            <p className="text-xs text-[#C8B8DB]/70">{perk.description}</p>
                          </div>
                        </div>
                      </div>
                      
                      <div className="mt-2">
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-[#C8B8DB]/80">Level</span>
                          <span className="text-[#FF9D00]">{perk.level}/{perk.maxLevel}</span>
                        </div>
                        <div className="h-1.5 bg-[#1A1A2E] rounded-full overflow-hidden">
                          <div 
                            className="h-full bg-[#FF9D00]" 
                            style={{ width: `${(perk.level / perk.maxLevel) * 100}%` }}
                          ></div>
                        </div>
                      </div>
                      
                      <div className="mt-3">
                        {perk.level < perk.maxLevel ? (
                          <Button
                            size="sm"
                            className="w-full bg-[#432874] hover:bg-[#432874]/80 text-xs"
                            onClick={() => handleUpgradePerk(perk.id)}
                            disabled={skillPoints < perk.cost}
                          >
                            <Star className="h-3 w-3 mr-1" />
                            Upgrade ({perk.cost})
                          </Button>
                        ) : (
                          <div className="w-full flex items-center justify-center bg-[#00B9AE]/20 py-1.5 rounded-lg text-xs text-[#00B9AE]">
                            <Sparkles className="h-3 w-3 mr-1" />
                            Maximum Level
                          </div>
                        )}
                      </div>
                    </motion.div>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
        </TabsContent>
        
        {/* Titles Tab */}
        <TabsContent value="titles">
          <motion.div
            variants={container}
            initial="hidden"
            animate="show"
            className="grid gap-6 md:grid-cols-2 lg:grid-cols-1"
          >
            {titles.map(title => (
              <motion.div
                key={title.id}
                variants={item}
                className={`bg-[#1A1A2E] border ${
                  title.status === 'Unlocked' 
                    ? equippedTitle === title.id 
                      ? 'border-[#00B9AE]/50' 
                      : 'border-[#FFD700]/50' 
                    : 'border-[#432874]/30'
                } rounded-xl overflow-hidden`}
              >
                <div className="flex flex-col md:flex-row">
                  <div className="p-6 flex items-center justify-center md:w-1/4 bg-[#1F1D36]">
                    <div className={`${
                      equippedTitle === title.id 
                        ? 'bg-[#00B9AE]/30' 
                        : 'bg-[#432874]/30'
                    } p-4 rounded-full`}>
                      {title.icon}
                    </div>
                  </div>
                  
                  <div className="flex-1 p-6">
                    <div className="flex justify-between items-start mb-2">
                      <h3 className="text-xl font-cinzel font-bold text-[#FF9D00]">{title.name}</h3>
                      {equippedTitle === title.id ? (
                        <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] border-[#00B9AE]/30">
                          Equipped
                        </Badge>
                      ) : (
                        <Badge className={`${title.status === 'Unlocked' ? 'bg-[#FFD700]/20 text-[#FFD700] border-[#FFD700]/30' : 'bg-[#432874]/30 text-[#C8B8DB] border-[#432874]/50'}`}>
                          {title.status}
                        </Badge>
                      )}
                    </div>
                    
                    <p className="text-[#C8B8DB]/80 mb-4">{title.description}</p>
                    
                    <div className="mb-4">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="text-[#C8B8DB]/80">Progress</span>
                        <span className="text-[#FF9D00]">{title.progress}%</span>
                      </div>
                      <Progress 
                        value={title.progress} 
                        className="h-2 bg-[#1F1D36] border-[#432874]/20" 
                      />
                    </div>
                    
                    <div className="bg-[#432874]/20 p-3 rounded-lg">
                      <div className="flex items-center">
                        <Star className="h-4 w-4 text-[#FFD700] mr-2 flex-shrink-0" />
                        <p className="text-sm text-[#C8B8DB]/90">
                          {title.requirements}
                        </p>
                      </div>
                    </div>
                  </div>
                  
                  <div className="p-6 flex items-center justify-center md:w-1/5">
                    {title.status === 'Unlocked' ? (
                      <Button
                        className={`w-full ${
                          equippedTitle === title.id
                            ? 'bg-[#00B9AE]/20 hover:bg-[#00B9AE]/30 text-[#00B9AE] border border-[#00B9AE]/30'
                            : 'bg-[#FFD700]/20 hover:bg-[#FFD700]/30 text-[#FFD700] border border-[#FFD700]/30'
                        }`}
                        disabled={equippedTitle === title.id}
                        onClick={() => handleEquipTitle(title.id)}
                      >
                        <Sparkles className="h-4 w-4 mr-2" />
                        {equippedTitle === title.id ? 'Equipped' : 'Equip Title'}
                      </Button>
                    ) : (
                      <div className="w-full text-center text-[#C8B8DB]/60">
                        <p className="text-sm">Complete requirements to unlock</p>
                      </div>
                    )}
                  </div>
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
      </Tabs>
    </>
  );
};

export default CollectionsView;

=== client/src/components/inventory/InventoryView_backup.tsx ===
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { 
  Search, Filter, ShoppingBag, User, Sparkles, Gem, Box, Plus,
  Info, Users, Zap, ArrowUpToLine, Activity, Sword, Droplets, Shield, 
  Heart, Footprints, Eye, CircleOff, Target
} from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Badge } from '@/components/ui/badge';
import { CharacterCard } from '../characters/CharacterCard';
import type { Character, Aura, Resource } from '@shared/schema';

const InventoryView = () => {
  const { toast } = useToast();
  const [selectedTab, setSelectedTab] = useState('characters');
  const [searchTerm, setSearchTerm] = useState('');
  const [filter, setFilter] = useState('all');
  const [showRecruitDialog, setShowRecruitDialog] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  
  const { 
    characters = [], 
    auras = [], 
    resources = [],
    fetchCharacters,
    fetchAuras,
    fetchResources
  } = useGameStore();
  
  // Load inventory data
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      await Promise.all([
        fetchCharacters(),
        fetchAuras(),
        fetchResources()
      ]);
      setIsLoading(false);
    };
    
    loadData();
  }, [fetchCharacters, fetchAuras, fetchResources]);

  // Define character shards - now specific to each character and persistent
  const [characterShards, setCharacterShards] = useState<Array<{
    id: number,
    name: string,
    quantity: number,
    required: number,
    characterClass: string,
    characterName: string,
    rarity: "common" | "uncommon" | "rare" | "epic" | "legendary",
    avatarUrl?: string
  }>>([
    // Explicitly add all 5 Kleos shard rarities
    {
      id: 50001,
      name: "Kleos Common Shard", 
      quantity: 25,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "common",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50002,
      name: "Kleos Uncommon Shard",
      quantity: 30,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "uncommon",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50003,
      name: "Kleos Rare Shard",
      quantity: 45,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "rare",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50004,
      name: "Kleos Epic Shard",
      quantity: 102,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "epic",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50005,
      name: "Kleos Legendary Shard",
      quantity: 5,
      required: 100,
      characterClass: "Warrior", 
      characterName: "Kleos",
      rarity: "legendary",
      avatarUrl: "/images/kleos.jpg"
    }
  ]);
  
  // Generate persistent shards based on characters with localStorage persistence
  useEffect(() => {
    // We've added Kleos shards in the initial state already
    // No need to force reset localStorage
    
    // Try to load saved shards from localStorage
    const savedShards = localStorage.getItem('characterShards');
    
    if (savedShards) {
      // Use saved shards if available
      setCharacterShards(JSON.parse(savedShards));
    } else if (characters.length > 0 && characterShards.length === 0) {
      // Generate new shards if none are saved
      const rarities: Array<"common" | "uncommon" | "rare" | "epic" | "legendary"> = [
        "common", "uncommon", "rare", "epic", "legendary"
      ];
      
      const shards = characters.flatMap(character => {
        // Create one shard of each rarity for each character
        return rarities.map(rarity => ({
          id: character.id + rarities.indexOf(rarity) * 10000, // Ensure unique IDs across rarities
          name: `${character.name} ${rarity.charAt(0).toUpperCase() + rarity.slice(1)} Shard`,
          quantity: Math.floor(Math.random() * 80) + 10, // Random quantity, but will be saved
          required: 100,
          characterClass: character.class,
          characterName: character.name,
          rarity: rarity,
          avatarUrl: character.avatarUrl
        }));
      });
      
      // Add Kleos shards for each rarity level
      const kleosShards = rarities.map((rarity, index) => ({
        id: 50000 + index, // Unique ID range for Kleos
        name: `Kleos ${rarity.charAt(0).toUpperCase() + rarity.slice(1)} Shard`,
        quantity: Math.floor(Math.random() * 25), // Random initial amount
        required: 20 + index * 20, // Increasing requirements by rarity
        characterClass: 'Legendary Hero',
        characterName: 'Kleos',
        rarity: rarity,
        avatarUrl: '/images/kleos.jpg'
      }));
      
      // Combine regular character shards with Kleos shards
      const allShards = [...shards, ...kleosShards];
      
      setCharacterShards(allShards);
      
      // Save to localStorage
      localStorage.setItem('characterShards', JSON.stringify(allShards));
    }
  }, [characters, characterShards.length]);

  // State for selected aura detail
  const [selectedAura, setSelectedAura] = useState<Aura | null>(null);
  
  // Filter functions for each tab
  const filteredCharacters = characters.filter(character => {
    const matchesSearch = character.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'active' && character.isActive) ||
      (filter === 'idle' && !character.isActive) ||
      (filter === filter && character.class.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  const filteredAuras = auras.filter(aura => {
    const matchesSearch = aura.element.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'equipped' && aura.equippedByCharacterId) ||
      (filter === 'available' && !aura.equippedByCharacterId) ||
      (filter === filter && aura.element.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  const filteredResources = resources.filter(resource => {
    const matchesSearch = resource.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'materials' && resource.type === 'material') ||
      (filter === 'essences' && resource.type === 'essence') ||
      (filter === 'currencies' && resource.type === 'currency');
    
    return matchesSearch && matchesFilter;
  });

  const filteredShards = characterShards.filter(shard => {
    const matchesSearch = shard.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'common' && shard.rarity === 'common') ||
      (filter === 'uncommon' && shard.rarity === 'uncommon') ||
      (filter === 'rare' && shard.rarity === 'rare') ||
      (filter === 'epic' && shard.rarity === 'epic') ||
      (filter === 'legendary' && shard.rarity === 'legendary') ||
      (filter === filter && shard.characterClass.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  // Handle shard actions (collect more or summon character)
  // Handle leveling up a character
  const handleLevelUpCharacter = async (characterId: number) => {
    try {
      // Find the character
      const character = characters.find(c => c.id === characterId);
      
      if (!character) {
        throw new Error('Character not found');
      }
      
      // API call to level up character
      const response = await apiRequest('POST', `/api/characters/${characterId}/level-up`, {
        levelIncrease: 1
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to level up character');
      }
      
      // Success message
      toast({
        title: "Character Leveled Up!",
        description: `${character.name} has reached level ${character.level + 1}!`
      });
      
      // Refresh character data
      fetchCharacters();
    } catch (error: any) {
      console.error('Error leveling up character:', error);
      toast({
        title: "Level Up Failed",
        description: error.message || "Unable to level up character at this time.",
        variant: "destructive"
      });
    }
  };

  const handleShardAction = (shard: {
    id: number,
    name: string,
    quantity: number,
    required: number,
    characterClass: string,
    characterName: string,
    rarity: "common" | "uncommon" | "rare" | "epic" | "legendary",
    avatarUrl?: string
  }) => {
    if (shard.quantity >= shard.required) {
      // Find the character
      const character = characters.find(c => c.id === (shard.id % 10000)); // Remove rarity offset
      
      if (!character) {
        toast({
          title: "Error",
          description: "Character not found for these shards.",
          variant: "destructive"
        });
        return;
      }
      
      // Level up character
      toast({
        title: "Character Level Up!",
        description: `Leveling up ${character.name} using ${shard.rarity} shards!`
      });
      
      // Update shard quantity (reset to 0)
      const updatedShards = characterShards.map(s => {
        if (s.id === shard.id) {
          return { ...s, quantity: 0 };
        }
        return s;
      });
      
      // Update state and save to localStorage
      setCharacterShards(updatedShards);
      localStorage.setItem('characterShards', JSON.stringify(updatedShards));
      
      // Level up the character
      handleLevelUpCharacter(character.id);
    } else {
      // Collect more shards
      const randomAmount = Math.floor(Math.random() * 5) + 1;
      
      // Update shard quantity
      const updatedShards = characterShards.map(s => {
        if (s.id === shard.id) {
          return { ...s, quantity: s.quantity + randomAmount };
        }
        return s;
      });
      
      // Update state and save to localStorage
      setCharacterShards(updatedShards);
      localStorage.setItem('characterShards', JSON.stringify(updatedShards));
      
      toast({
        title: "Shards Collected!",
        description: `You collected ${randomAmount} ${shard.rarity} ${shard.characterName} shards!`
      });
    }
  };

  // Handle recruiting a new character
  const handleRecruitCharacter = async (characterClass?: string, type?: string) => {
    try {
      // Generate a random character for demonstration
      const randomNames = ["Eldrin", "Lyra", "Thorne", "Seraphina", "Gideon", "Isolde"];
      const randomClasses = ["Warrior", "Mage", "Rogue", "Cleric"];
      const randomAvatars = [
        "https://images.unsplash.com/photo-1577095972620-2f389ca3abcd?w=150&h=150&fit=crop",
        "https://images.unsplash.com/photo-1613477564751-fc2a7c5bbb7a?w=150&h=150&fit=crop",
        "https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=150&h=150&fit=crop"
      ];
      
      const newCharacter = {
        name: randomNames[Math.floor(Math.random() * randomNames.length)],
        class: characterClass || randomClasses[Math.floor(Math.random() * randomClasses.length)],
        level: 1,
        avatarUrl: randomAvatars[Math.floor(Math.random() * randomAvatars.length)],
        attack: 10 + Math.floor(Math.random() * 5),
        defense: 10 + Math.floor(Math.random() * 5),
        health: 100 + Math.floor(Math.random() * 20),
        speed: 10 + Math.floor(Math.random() * 5),
        vitality: 10 + Math.floor(Math.random() * 5),
        accuracy: 10 + Math.floor(Math.random() * 5),
        focus: 10 + Math.floor(Math.random() * 5),
        resilience: 10 + Math.floor(Math.random() * 5)
      };
      
      const response = await apiRequest('POST', '/api/characters', newCharacter);
      const data = await response.json();
      
      toast({
        title: "Character Recruited!",
        description: `${data.name} has joined your roster.`
      });
      
      fetchCharacters();
      setShowRecruitDialog(false);
    } catch (error) {
      console.error('Error recruiting character:', error);
      toast({
        title: "Recruitment Failed",
        description: "Unable to recruit a new character at this time.",
        variant: "destructive"
      });
    }
  };

  // Render loading state
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl animate-pulse">Loading inventory data...</div>
      </div>
    );
  }

  return (
    <>
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Inventory</h1>
        <p className="text-[#C8B8DB]/80">
          Manage your characters, auras, materials, resources, and character shards.
        </p>
      </div>
      
      {/* Inventory Tabs */}
      <Tabs defaultValue="characters" value={selectedTab} onValueChange={setSelectedTab} className="w-full mb-6">
        <TabsList className="bg-[#432874]/20 mb-6">
          <TabsTrigger value="characters" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <User className="h-4 w-4 mr-2" />
            Characters
          </TabsTrigger>
          <TabsTrigger value="auras" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Sparkles className="h-4 w-4 mr-2" />
            Auras
          </TabsTrigger>
          <TabsTrigger value="materials" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Box className="h-4 w-4 mr-2" />
            Materials
          </TabsTrigger>
          <TabsTrigger value="resources" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Gem className="h-4 w-4 mr-2" />
            Resources
          </TabsTrigger>
          <TabsTrigger value="shards" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <ShoppingBag className="h-4 w-4 mr-2" />
            Character Shards
          </TabsTrigger>
        </TabsList>
        
        {/* Search & Filter Controls */}
        <div className="flex flex-wrap gap-4 mb-6">
          <div className="relative flex-grow max-w-md">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-[#C8B8DB]/50 h-4 w-4" />
            <input
              type="text"
              placeholder={`Search ${selectedTab}...`}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10 w-full bg-[#1F1D36]/80 border border-[#432874]/30 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-[#FF9D00]"
            />
          </div>
          
          <div className="flex items-center gap-2">
            <Filter className="text-[#C8B8DB]/70 h-4 w-4" />
            <Select value={filter} onValueChange={setFilter}>
              <SelectTrigger className="bg-[#1F1D36]/80 border-[#432874]/30 focus:border-[#FF9D00] focus:ring-0 w-32">
                <SelectValue placeholder="Filter" />
              </SelectTrigger>
              <SelectContent className="bg-[#1A1A2E] border-[#432874]/30">
                <SelectItem value="all">All</SelectItem>
                {selectedTab === 'characters' && (
                  <>
                    <SelectItem value="active">Active</SelectItem>
                    <SelectItem value="idle">Idle</SelectItem>
                    <SelectItem value="warrior">Warrior</SelectItem>
                    <SelectItem value="mage">Mage</SelectItem>
                    <SelectItem value="rogue">Rogue</SelectItem>
                    <SelectItem value="cleric">Cleric</SelectItem>
                  </>
                )}
                {selectedTab === 'auras' && (
                  <>
                    <SelectItem value="equipped">Equipped</SelectItem>
                    <SelectItem value="available">Available</SelectItem>
                    <SelectItem value="fire">Fire</SelectItem>
                    <SelectItem value="water">Water</SelectItem>
                    <SelectItem value="earth">Earth</SelectItem>
                    <SelectItem value="wind">Wind</SelectItem>
                  </>
                )}
                {selectedTab === 'materials' && (
                  <>
                    <SelectItem value="common">Common</SelectItem>
                    <SelectItem value="rare">Rare</SelectItem>
                    <SelectItem value="epic">Epic</SelectItem>
                  </>
                )}
                {selectedTab === 'resources' && (
                  <>
                    <SelectItem value="materials">Materials</SelectItem>
                    <SelectItem value="essences">Essences</SelectItem>
                    <SelectItem value="currencies">Currencies</SelectItem>
                  </>
                )}
                {selectedTab === 'shards' && (
                  <>
                    <SelectItem value="common">Basic</SelectItem>
                    <SelectItem value="uncommon">Rare</SelectItem>
                    <SelectItem value="rare">Epic</SelectItem>
                    <SelectItem value="epic">Mythic</SelectItem>
                    <SelectItem value="legendary">Legendary</SelectItem>
                    <SelectItem value="warrior">Warrior</SelectItem>
                    <SelectItem value="mage">Mage</SelectItem>
                    <SelectItem value="rogue">Rogue</SelectItem>
                    <SelectItem value="cleric">Cleric</SelectItem>
                  </>
                )}
              </SelectContent>
            </Select>
          </div>
          
          {selectedTab === 'characters' && (
            <Dialog open={showRecruitDialog} onOpenChange={setShowRecruitDialog}>
              <DialogTrigger asChild>
                <Button className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]">
                  <Plus className="h-4 w-4 mr-2" /> Recruit
                </Button>
              </DialogTrigger>
              <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
                <DialogHeader>
                  <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Recruit a New Character</DialogTitle>
                </DialogHeader>
                
                <div className="py-4">
                  <div className="bg-[#432874]/20 rounded-lg p-4 text-center mb-4">
                    <img
                      src="https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=250&h=250&fit=crop"
                      alt="New Character"
                      className="w-20 h-20 rounded-full border-2 border-[#FF9D00] mx-auto mb-2"
                    />
                    <p className="text-[#C8B8DB]">
                      Recruiting a new character costs <span className="text-[#FFD700] font-bold">500</span> Rogue Credits.
                    </p>
                  </div>
                  
                  <Button 
                    className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                    onClick={() => handleRecruitCharacter()}
                  >
                    Recruit Random Character
                  </Button>
                </div>
              </DialogContent>
            </Dialog>
          )}
        </div>
        
        {/* Characters Tab */}
        <TabsContent value="characters">
          {filteredCharacters.length === 0 ? (
            <div className="bg-[#1A1A2E] rounded-xl p-8 text-center">
              <p className="text-[#C8B8DB]/80 mb-4">
                {searchTerm 
                  ? `No characters found matching "${searchTerm}"` 
                  : "You don't have any characters yet."}
              </p>
              <Button 
                className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                onClick={() => setShowRecruitDialog(true)}
              >
                <Plus className="h-4 w-4 mr-2" /> Recruit Your First Character
              </Button>
            </div>
          ) : (
            <motion.div 
              className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
              variants={container}
              initial="hidden"
              animate="show"
            >
              {filteredCharacters.map((character) => (
                <CharacterCard 
                  key={character.id} 
                  character={character} 
                  availableAuras={auras || []}
                  allAuras={auras || []}
                  refetchAura={() => fetchAuras()}
                  refetchAllAuras={() => fetchAuras()}
                  equippedAura={auras.find(aura => aura.id === character.equippedAuraId)}
                />
              ))}
            </motion.div>
          )}
        </TabsContent>
        
        {/* Auras Tab */}
        <TabsContent value="auras">
          {filteredAuras.length === 0 ? (
            <div className="bg-[#1A1A2E] rounded-xl p-8 text-center">
              <p className="text-[#C8B8DB]/80 mb-4">
                {searchTerm 
                  ? `No auras found matching "${searchTerm}"` 
                  : "You don't have any auras yet."}
              </p>
              <Button 
                className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                onClick={() => window.location.href = "/forge"}
              >
                <Sparkles className="h-4 w-4 mr-2" /> Craft Your First Aura
              </Button>
            </div>
          ) : (
            <motion.div 
              className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
              variants={container}
              initial="hidden"
              animate="show"
            >
              {/* Aura Detail Dialog */}
              <Dialog open={!!selectedAura} onOpenChange={(open) => !open && setSelectedAura(null)}>
                <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-2xl">
                  {selectedAura && (
                    <>
                      <DialogHeader>
                        <DialogTitle className="text-[#FF9D00] font-cinzel text-xl flex items-center">
                          <div className={`w-8 h-8 rounded-full flex items-center justify-center mr-3
                            ${selectedAura.element === 'Fire' ? 'bg-red-500/20' : 
                              selectedAura.element === 'Water' ? 'bg-blue-500/20' : 
                              selectedAura.element === 'Earth' ? 'bg-amber-800/20' : 
                              'bg-green-500/20'}`
                          }>
                            {selectedAura.element === 'Fire' ? (
                              <div className="text-red-500"></div>
                            ) : selectedAura.element === 'Water' ? (
                              <div className="text-blue-500"></div>
                            ) : selectedAura.element === 'Earth' ? (
                              <div className="text-amber-800"></div>
                            ) : (
                              <div className="text-green-500"></div>
                            )}
                          </div>
                          {selectedAura.name || `${selectedAura.element || 'Mysterious'} Aura`}
                        </DialogTitle>
                      </DialogHeader>
                      
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 py-4">
                        {/* Left Column - Stats */}
                        <div>
                          <h3 className="font-semibold text-[#FF9D00] mb-3">Stats</h3>
                          <div className="bg-[#1F1D36]/80 p-4 rounded-lg">
                            <div className="grid grid-cols-2 gap-x-4 gap-y-2">
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Sword className="h-3 w-3 mr-1 text-red-400" />
                                  <span>Attack</span>
                                </div>
                                <span className={`${selectedAura.attack && selectedAura.attack > 0 ? 'text-green-400' : selectedAura.attack && selectedAura.attack < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.attack === 'number' ? `${selectedAura.attack}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Target className="h-3 w-3 mr-1 text-blue-400" />
                                  <span>Accuracy</span>
                                </div>
                                <span className={`${selectedAura.accuracy && selectedAura.accuracy > 0 ? 'text-green-400' : selectedAura.accuracy && selectedAura.accuracy < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.accuracy === 'number' ? `${selectedAura.accuracy}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Shield className="h-3 w-3 mr-1 text-amber-400" />
                                  <span>Defense</span>
                                </div>
                                <span className={`${selectedAura.defense && selectedAura.defense > 0 ? 'text-green-400' : selectedAura.defense && selectedAura.defense < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.defense === 'number' ? `${selectedAura.defense}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Heart className="h-3 w-3 mr-1 text-green-400" />
                                  <span>Vitality</span>
                                </div>
                                <span className={`${selectedAura.vitality && selectedAura.vitality > 0 ? 'text-green-400' : selectedAura.vitality && selectedAura.vitality < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.vitality === 'number' ? `${selectedAura.vitality}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Footprints className="h-3 w-3 mr-1 text-cyan-400" />
                                  <span>Speed</span>
                                </div>
                                <span className={`${selectedAura.speed && selectedAura.speed > 0 ? 'text-green-400' : selectedAura.speed && selectedAura.speed < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.speed === 'number' ? `${selectedAura.speed}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Eye className="h-3 w-3 mr-1 text-yellow-400" />
                                  <span>Focus</span>
                                </div>
                                <span className={`${selectedAura.focus && selectedAura.focus > 0 ? 'text-green-400' : selectedAura.focus && selectedAura.focus < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.focus === 'number' ? `${selectedAura.focus}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                                  <span>Resilience</span>
                                </div>
                                <span className={`${selectedAura.resilience && selectedAura.resilience > 0 ? 'text-green-400' : selectedAura.resilience && selectedAura.resilience < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.resilience === 'number' ? `${selectedAura.resilience}%` : '0%'}
                                </span>
                              </div>
                            </div>
                            
                            {/* Display Skills if any */}
                            {selectedAura.skills && Array.isArray(selectedAura.skills) && selectedAura.skills.length > 0 && (
                              <>
                                <div className="text-[#00B9AE] text-xs mt-4 mb-1">Skills:</div>
                                <div className="mt-1 space-y-2">
                                  {selectedAura.skills.map((skill: any, index: number) => (
                                    <div key={index} className="bg-[#432874]/20 p-2 rounded-lg">
                                      <div className="flex items-center justify-between">
                                        <div className="flex items-center">
                                          <Sparkles className="h-3 w-3 mr-1 text-yellow-400 flex-shrink-0" />
                                          <span className="font-semibold text-xs">{skill.name}</span>
                                        </div>
                                        {skill.type && (
                                          <Badge className={`
                                            ${skill.type === 'Ultimate' ? 'bg-[#FF9D00]/20 text-[#FF9D00]' : 
                                              skill.type === 'Advanced' ? 'bg-[#00B9AE]/20 text-[#00B9AE]' : 
                                              'bg-[#C8B8DB]/20 text-[#C8B8DB]'}
                                          `}>
                                            {skill.type}
                                          </Badge>
                                        )}
                                      </div>
                                      
                                      {skill.description && (
                                        <div className="ml-4 mt-1 text-xs text-[#C8B8DB]/80">
                                          {skill.description}
                                        </div>
                                      )}
                                      
                                      <div className="grid grid-cols-2 gap-2 ml-4 mt-2">
                                        {/* Damage Multiplier */}
                                        {skill.damage !== undefined && (
                                          <div className="flex items-center">
                                            <Sword className="h-3 w-3 mr-1 text-red-400 flex-shrink-0" />
                                            <span className="text-xs">Damage: x{skill.damage}</span>
                                          </div>
                                        )}
                                        
                                        {/* Targets */}
                                        {skill.targets !== undefined && (
                                          <div className="flex items-center">
                                            <Target className="h-3 w-3 mr-1 text-blue-400 flex-shrink-0" />
                                            <span className="text-xs">Targets: {skill.targets}</span>
                                          </div>
                                        )}
                                      </div>
                                      
                                      {/* Special Effect */}
                                      {skill.effect && (
                                        <div className="flex items-start ml-4 mt-2">
                                          <Activity className="h-3 w-3 mr-1 text-purple-400 flex-shrink-0 mt-0.5" />
                                          <span className="text-xs text-[#00B9AE]">Effect: {skill.effect}</span>
                                        </div>
                                      )}
                                      
                                      {/* Cooldown if applicable */}
                                      {skill.cooldown && (
                                        <div className="flex items-center ml-4 mt-1">
                                          <Zap className="h-3 w-3 mr-1 text-yellow-400 flex-shrink-0" />
                                          <span className="text-xs">Cooldown: {skill.cooldown} turn{skill.cooldown !== 1 ? 's' : ''}</span>
                                        </div>
                                      )}
                                      
                                      {/* Level/Tier Info */}
                                      {skill.level && (
                                        <div className="flex items-center ml-4 mt-1">
                                          <ArrowUpToLine className="h-3 w-3 mr-1 text-green-400 flex-shrink-0" />
                                          <span className="text-xs">Required Level: {skill.level}</span>
                                        </div>
                                      )}
                                    </div>
                                  ))}
                                </div>
                              </>
                            )}
                          </div>
                        </div>
                        
                        {/* Right Column - Forge Information */}
                        <div>
                          <h3 className="font-semibold text-[#FF9D00] mb-3">Forge Information</h3>
                          <div className="bg-[#1F1D36]/80 p-4 rounded-lg">
                            <div className="mb-3">
                              <div className="text-sm font-semibold mb-1">Element</div>
                              <Badge className={`
                                ${selectedAura.element === 'Fire' ? 'bg-red-500/20 text-red-400' : 
                                  selectedAura.element === 'Water' ? 'bg-blue-500/20 text-blue-400' : 
                                  selectedAura.element === 'Earth' ? 'bg-amber-800/20 text-amber-600' : 
                                  'bg-green-500/20 text-green-400'}
                              `}>
                                {selectedAura.element || 'Unknown'}
                              </Badge>
                            </div>
                            
                            <div className="mb-3">
                              <div className="text-sm font-semibold mb-1">Level</div>
                              <div className="text-[#FF9D00]">{selectedAura.level || 1}</div>
                            </div>
                            
                            {selectedAura.equippedByCharacterId && (
                              <div className="mb-3">
                                <div className="text-sm font-semibold mb-1">Equipped By</div>
                                <div className="text-[#00B9AE]">
                                  {characters.find(c => c.id === selectedAura.equippedByCharacterId)?.name || 'Unknown Character'}
                                </div>
                              </div>
                            )}
                            
                            {/* All source information removed as requested */}
                                  <div className="bg-[#432874]/20 p-2 rounded-lg">
                                    Origin unknown
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </>
                  )}
                </DialogContent>
              </Dialog>
              
              {filteredAuras.map((aura) => (
                <motion.div
                  key={aura.id}
                  variants={item}
                  onClick={() => setSelectedAura(aura)}
                  className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden cursor-pointer hover:border-[#FF9D00]/50 hover:shadow-lg transition-all"
                >
                  <div className="p-4">
                    <div className="flex items-center mb-3">
                      <div className={`w-12 h-12 rounded-full flex items-center justify-center mr-3
                        ${aura.element?.toLowerCase() === 'fire' ? 'bg-red-500/20' : 
                          aura.element?.toLowerCase() === 'water' ? 'bg-blue-500/20' : 
                          aura.element?.toLowerCase() === 'earth' ? 'bg-amber-800/20' : 
                          aura.element?.toLowerCase() === 'wind' ? 'bg-cyan-500/20' :
                          'bg-green-500/20'}`
                      }>
                        {aura.element?.toLowerCase() === 'fire' ? (
                          <div className="text-red-500"></div>
                        ) : aura.element?.toLowerCase() === 'water' ? (
                          <div className="text-blue-500"></div>
                        ) : aura.element?.toLowerCase() === 'earth' ? (
                          <div className="text-amber-800"></div>
                        ) : aura.element?.toLowerCase() === 'wind' ? (
                          <div className="text-cyan-500"></div>
                        ) : (
                          <div className="text-purple-500"></div>
                        )}
                      </div>
                      <div>
                        <h3 className="font-cinzel font-semibold text-[#FF9D00]">
                          {aura.name || `${aura.element || 'Mysterious'} Aura`}
                        </h3>
                        <div className="text-sm text-[#C8B8DB]/80">
                          Level {aura.level || 1}
                        </div>
                      </div>
                    </div>
                    
                    <div className="mt-2 bg-[#1F1D36]/80 p-3 rounded-lg text-sm">
                      <h4 className="font-semibold mb-1">Stat Multipliers:</h4>
                      <div className="grid grid-cols-2 gap-x-2 gap-y-1">
                        {/* Show all stats - show 0 if not present */}
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Sword className="h-3 w-3 mr-1 text-red-400" />
                            <span>Attack</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.attack === 'number' ? `${aura.attack}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Target className="h-3 w-3 mr-1 text-blue-400" />
                            <span>Accuracy</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.accuracy === 'number' ? `${aura.accuracy}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Shield className="h-3 w-3 mr-1 text-amber-400" />
                            <span>Defense</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.defense === 'number' ? `${aura.defense}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Heart className="h-3 w-3 mr-1 text-green-400" />
                            <span>Vitality</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.vitality === 'number' ? `${aura.vitality}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Footprints className="h-3 w-3 mr-1 text-cyan-400" />
                            <span>Speed</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.speed === 'number' ? `${aura.speed}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Eye className="h-3 w-3 mr-1 text-yellow-400" />
                            <span>Focus</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.focus === 'number' ? `${aura.focus}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                            <span>Resilience</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.resilience === 'number' ? `${aura.resilience}%` : '0%'}
                          </span>
                        </div>
                      </div>
                      
                      {/* Note: Stat bonuses are now displayed directly in the attributes above */}
                      
                      {/* Forge information - showing which character classes were used */}
                      {(() => {
                        // Use safer type checking for sourceCharacterIds
                        const sourceIds = aura.sourceCharacterIds as number[] | undefined;
                        
                        if (!sourceIds || !Array.isArray(sourceIds) || sourceIds.length === 0) {
                          return null; // Removed Power Source section as requested
                        }
                        
                        // Find the source characters
                        const sourceChars = characters.filter(c => sourceIds.includes(c.id));
                        
                        return (
                          <div className="mt-3 pt-3 border-t border-[#432874]/30">
                            <h4 className="text-xs font-semibold mb-1 text-[#00B9AE]">Forged Using:</h4>
                            <div className="text-xs text-[#C8B8DB]/80">
                              {sourceChars.length === 0 
                                ? 'Unknown characters' 
                                : sourceChars.map(char => `${char.name} (${char.class})`).join(', ')
                              }
                            </div>
                          </div>
                        );
                      })()}
                      
                      {/* Skills list */}
                      {aura.skills && (typeof aura.skills === 'object' || typeof aura.skills === 'string') && (
                        <div className="mt-3 pt-3 border-t border-[#432874]/30">
                          <h4 className="text-xs font-semibold mb-1 text-[#00B9AE]">Active Skills:</h4>
                          <div className="text-xs">
                            {(() => {
                              let skills = [];
                              try {
                                skills = typeof aura.skills === 'string' 
                                  ? JSON.parse(aura.skills) 
                                  : aura.skills;
                              } catch (e) {
                                return 'No active skills';
                              }
                              
                              if (!Array.isArray(skills) || skills.length === 0) {
                                return 'No active skills';
                              }
                              
                              return (
                                <ul className="list-disc list-inside">
                                  {skills.map((skill, idx) => (
                                    <li key={idx}>
                                      <span className="font-semibold">{skill.name}</span>: {skill.description}
                                    </li>
                                  ))}
                                </ul>
                              );
                            })()}
                          </div>
                        </div>
                      )}
                    </div>
                    
                    <div className="mt-3 text-center">
                      {aura.equippedByCharacterId ? (
                        <div className="bg-[#00B9AE]/20 text-[#00B9AE] py-1 px-2 rounded text-sm">
                          Equipped by {(() => {
                            const char = characters.find(c => c.id === aura.equippedByCharacterId);
                            return char ? char.name : 'a character';
                          })()}
                        </div>
                      ) : (
                        <Button 
                          size="sm" 
                          className="w-full bg-[#432874] hover:bg-[#432874]/80 text-xs"
                        >
                          Equip to Character
                        </Button>
                      )}
                    </div>
                  </div>
                </motion.div>
              ))}
            </motion.div>
          )}
        </TabsContent>
        
        {/* Materials Tab */}
        <TabsContent value="materials">
          <motion.div 
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            variants={container}
            initial="hidden"
            animate="show"
          >
            {resources.filter(r => r.type === 'material').map((material) => (
              <motion.div
                key={material.id}
                variants={item}
                className="bg-[#1A1A2E] border border-[#432874]/30 rounded-lg p-4"
              >
                <div className="flex items-center">
                  <div className="w-10 h-10 rounded-full bg-[#432874]/30 flex items-center justify-center mr-3">
                    <Box className="h-5 w-5 text-[#C8B8DB]" />
                  </div>
                  <div>
                    <h3 className="font-semibold text-[#FF9D00]">{material.name}</h3>
                    <div className="text-sm text-[#C8B8DB]/80">Material</div>
                  </div>
                  <div className="ml-auto bg-[#432874]/30 px-3 py-1 rounded-full">
                    <span className="text-[#C8B8DB]">{material.quantity}</span>
                  </div>
                </div>
                <div className="mt-3 text-sm text-[#C8B8DB]/70">
                  {material.description || "Used for crafting and upgrading items."}
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
        
        {/* Resources Tab */}
        <TabsContent value="resources">
          <motion.div 
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            variants={container}
            initial="hidden"
            animate="show"
          >
            {filteredResources.map((resource) => (
              <motion.div
                key={resource.id}
                variants={item}
                className="bg-[#1A1A2E] border border-[#432874]/30 rounded-lg p-4"
              >
                <div className="flex items-center">
                  <div className="w-10 h-10 rounded-full bg-[#432874]/30 flex items-center justify-center mr-3">
                    {resource.type === 'essence' ? (
                      <Sparkles className="h-5 w-5 text-[#FF9D00]" />
                    ) : resource.type === 'currency' ? (
                      <Gem className="h-5 w-5 text-[#FFD700]" />
                    ) : (
                      <Box className="h-5 w-5 text-[#C8B8DB]" />
                    )}
                  </div>
                  <div>
                    <h3 className="font-semibold text-[#FF9D00]">{resource.name}</h3>
                    <div className="text-sm text-[#C8B8DB]/80 capitalize">{resource.type}</div>
                  </div>
                  <div className="ml-auto bg-[#432874]/30 px-3 py-1 rounded-full">
                    <span className="text-[#C8B8DB]">{resource.quantity}</span>
                  </div>
                </div>
                <div className="mt-3 text-sm text-[#C8B8DB]/70">
                  {resource.description || `Used for ${resource.type === 'essence' ? 'crafting auras' : 
                    resource.type === 'currency' ? 'purchasing items and upgrades' : 
                    'crafting and upgrading'}.`}
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
        
        {/* Character Shards Tab */}
        <TabsContent value="shards">
          <motion.div 
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            variants={container}
            initial="hidden"
            animate="show"
          >
            {filteredShards.map((shard) => (
              <motion.div
                key={shard.id}
                variants={item}
                className="bg-[#1A1A2E] border border-[#432874]/30 rounded-lg p-4"
              >
                <div className="flex items-center">
                  <div className={`w-12 h-12 rounded-full overflow-hidden border-2 flex-shrink-0 mr-3
                    ${shard.rarity === 'common' ? 'border-gray-600' : 
                      shard.rarity === 'uncommon' ? 'border-blue-600' : 
                      shard.rarity === 'rare' ? 'border-purple-600' : 
                      shard.rarity === 'epic' ? 'border-red-600' : 
                      'border-yellow-600'}`
                  }>
                    <img 
                      src={shard.avatarUrl || "/assets/default-avatar.png"}
                      alt={shard.characterName}
                      className="w-full h-full object-cover"
                    />
                  </div>
                  <div>
                    <h3 className="font-semibold text-[#FF9D00]">{shard.name}</h3>
                    <div className={`text-sm capitalize
                      ${shard.rarity === 'common' ? 'text-gray-300' : 
                        shard.rarity === 'uncommon' ? 'text-blue-300' : 
                        shard.rarity === 'rare' ? 'text-purple-300' : 
                        shard.rarity === 'epic' ? 'text-red-300' : 
                        'text-yellow-300'}`
                    }>
                      {shard.rarity === 'common' ? 'Basic' : 
                        shard.rarity === 'uncommon' ? 'Rare' : 
                        shard.rarity === 'rare' ? 'Epic' : 
                        shard.rarity === 'epic' ? 'Mythic' : 
                        'Legendary'}  {shard.characterClass}
                    </div>
                    <div className="flex mt-1 text-xs text-[#C8B8DB]">
                      <span className="font-medium">{shard.quantity}</span>
                      <span className="text-[#C8B8DB]/60 mx-1">/</span>
                      <span className="font-medium">{shard.required}</span>
                    </div>
                  </div>
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
      </Tabs>
    </>
  );
};

export default InventoryView;

=== client/src/components/inventory/InventoryView.tsx ===
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { 
  Search, Filter, ShoppingBag, User, Sparkles, Gem, Box, Plus,
  Info, Users, Zap, ArrowUpToLine, Activity, Sword, Droplets, Shield, 
  Heart, Footprints, Eye, CircleOff, Target
} from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Badge } from '@/components/ui/badge';
import { CharacterCard } from '../characters/CharacterCard';
import type { Character, Aura, Resource } from '@shared/schema';

const InventoryView = () => {
  const { toast } = useToast();
  const [selectedTab, setSelectedTab] = useState('characters');
  const [searchTerm, setSearchTerm] = useState('');
  const [filter, setFilter] = useState('all');
  const [showRecruitDialog, setShowRecruitDialog] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  
  const { 
    characters = [], 
    auras = [], 
    resources = [],
    fetchCharacters,
    fetchAuras,
    fetchResources
  } = useGameStore();
  
  // Load inventory data
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      await Promise.all([
        fetchCharacters(),
        fetchAuras(),
        fetchResources()
      ]);
      setIsLoading(false);
    };
    
    loadData();
  }, [fetchCharacters, fetchAuras, fetchResources]);

  // Define character shards - now specific to each character and persistent
  const [characterShards, setCharacterShards] = useState<Array<{
    id: number,
    name: string,
    quantity: number,
    required: number,
    characterClass: string,
    characterName: string,
    rarity: "common" | "uncommon" | "rare" | "epic" | "legendary",
    avatarUrl?: string
  }>>([
    // Explicitly add all 5 Kleos shard rarities
    {
      id: 50001,
      name: "Kleos Common Shard", 
      quantity: 25,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "common",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50002,
      name: "Kleos Uncommon Shard",
      quantity: 30,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "uncommon",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50003,
      name: "Kleos Rare Shard",
      quantity: 45,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "rare",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50004,
      name: "Kleos Epic Shard",
      quantity: 102,
      required: 100,
      characterClass: "Warrior",
      characterName: "Kleos",
      rarity: "epic",
      avatarUrl: "/images/kleos.jpg"
    },
    {
      id: 50005,
      name: "Kleos Legendary Shard",
      quantity: 5,
      required: 100,
      characterClass: "Warrior", 
      characterName: "Kleos",
      rarity: "legendary",
      avatarUrl: "/images/kleos.jpg"
    }
  ]);
  
  // Generate persistent shards based on characters with localStorage persistence
  useEffect(() => {
    // We've added Kleos shards in the initial state already
    // No need to force reset localStorage
    
    // Try to load saved shards from localStorage
    const savedShards = localStorage.getItem('characterShards');
    
    if (savedShards) {
      // Use saved shards if available
      setCharacterShards(JSON.parse(savedShards));
    } else if (characters.length > 0 && characterShards.length === 0) {
      // Generate new shards if none are saved
      const rarities: Array<"common" | "uncommon" | "rare" | "epic" | "legendary"> = [
        "common", "uncommon", "rare", "epic", "legendary"
      ];
      
      const shards = characters.flatMap(character => {
        // Create one shard of each rarity for each character
        return rarities.map(rarity => ({
          id: character.id + rarities.indexOf(rarity) * 10000, // Ensure unique IDs across rarities
          name: `${character.name} ${rarity.charAt(0).toUpperCase() + rarity.slice(1)} Shard`,
          quantity: Math.floor(Math.random() * 80) + 10, // Random quantity, but will be saved
          required: 100,
          characterClass: character.class,
          characterName: character.name,
          rarity: rarity,
          avatarUrl: character.avatarUrl
        }));
      });
      
      // Add Kleos shards for each rarity level
      const kleosShards = rarities.map((rarity, index) => ({
        id: 50000 + index, // Unique ID range for Kleos
        name: `Kleos ${rarity.charAt(0).toUpperCase() + rarity.slice(1)} Shard`,
        quantity: Math.floor(Math.random() * 25), // Random initial amount
        required: 20 + index * 20, // Increasing requirements by rarity
        characterClass: 'Legendary Hero',
        characterName: 'Kleos',
        rarity: rarity,
        avatarUrl: '/images/kleos.jpg'
      }));
      
      // Combine regular character shards with Kleos shards
      const allShards = [...shards, ...kleosShards];
      
      setCharacterShards(allShards);
      
      // Save to localStorage
      localStorage.setItem('characterShards', JSON.stringify(allShards));
    }
  }, [characters, characterShards.length]);

  // State for selected aura detail
  const [selectedAura, setSelectedAura] = useState<Aura | null>(null);
  
  // Calculate total stat bonus for an aura
  const calculateTotalStats = (aura: Aura): number => {
    let total = 0;
    if (typeof aura.attack === 'number') total += aura.attack;
    if (typeof aura.defense === 'number') total += aura.defense;
    if (typeof aura.vitality === 'number') total += aura.vitality;
    if (typeof aura.speed === 'number') total += aura.speed;
    if (typeof aura.accuracy === 'number') total += aura.accuracy;
    if (typeof aura.focus === 'number') total += aura.focus;
    if (typeof aura.resilience === 'number') total += aura.resilience;
    return total;
  };
  
  // Filter functions for each tab
  const filteredCharacters = characters.filter(character => {
    const matchesSearch = character.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'active' && character.isActive) ||
      (filter === 'idle' && !character.isActive) ||
      (filter === filter && character.class.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  const filteredAuras = auras.filter(aura => {
    const matchesSearch = aura.element.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'equipped' && aura.equippedByCharacterId) ||
      (filter === 'available' && !aura.equippedByCharacterId) ||
      (filter === filter && aura.element.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  const filteredResources = resources.filter(resource => {
    const matchesSearch = resource.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'materials' && resource.type === 'material') ||
      (filter === 'essences' && resource.type === 'essence') ||
      (filter === 'currencies' && resource.type === 'currency');
    
    return matchesSearch && matchesFilter;
  });

  const filteredShards = characterShards.filter(shard => {
    const matchesSearch = shard.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = 
      filter === 'all' ||
      (filter === 'common' && shard.rarity === 'common') ||
      (filter === 'uncommon' && shard.rarity === 'uncommon') ||
      (filter === 'rare' && shard.rarity === 'rare') ||
      (filter === 'epic' && shard.rarity === 'epic') ||
      (filter === 'legendary' && shard.rarity === 'legendary') ||
      (filter === filter && shard.characterClass.toLowerCase() === filter);
    
    return matchesSearch && matchesFilter;
  });

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  // Handle shard actions (collect more or summon character)
  // Handle leveling up a character
  const handleLevelUpCharacter = async (characterId: number) => {
    try {
      // Find the character
      const character = characters.find(c => c.id === characterId);
      
      if (!character) {
        throw new Error('Character not found');
      }
      
      // API call to level up character
      const response = await apiRequest('POST', `/api/characters/${characterId}/level-up`, {
        levelIncrease: 1
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to level up character');
      }
      
      // Success message
      toast({
        title: "Character Leveled Up!",
        description: `${character.name} has reached level ${character.level + 1}!`
      });
      
      // Refresh character data
      fetchCharacters();
    } catch (error: any) {
      console.error('Error leveling up character:', error);
      toast({
        title: "Level Up Failed",
        description: error.message || "Unable to level up character at this time.",
        variant: "destructive"
      });
    }
  };

  const handleShardAction = (shard: {
    id: number,
    name: string,
    quantity: number,
    required: number,
    characterClass: string,
    characterName: string,
    rarity: "common" | "uncommon" | "rare" | "epic" | "legendary",
    avatarUrl?: string
  }) => {
    if (shard.quantity >= shard.required) {
      // Find the character
      const character = characters.find(c => c.id === (shard.id % 10000)); // Remove rarity offset
      
      if (!character) {
        toast({
          title: "Error",
          description: "Character not found for these shards.",
          variant: "destructive"
        });
        return;
      }
      
      // Level up character
      toast({
        title: "Character Level Up!",
        description: `Leveling up ${character.name} using ${shard.rarity} shards!`
      });
      
      // Update shard quantity (reset to 0)
      const updatedShards = characterShards.map(s => {
        if (s.id === shard.id) {
          return { ...s, quantity: 0 };
        }
        return s;
      });
      
      // Update state and save to localStorage
      setCharacterShards(updatedShards);
      localStorage.setItem('characterShards', JSON.stringify(updatedShards));
      
      // Level up the character
      handleLevelUpCharacter(character.id);
    } else {
      // Collect more shards
      const randomAmount = Math.floor(Math.random() * 5) + 1;
      
      // Update shard quantity
      const updatedShards = characterShards.map(s => {
        if (s.id === shard.id) {
          return { ...s, quantity: s.quantity + randomAmount };
        }
        return s;
      });
      
      // Update state and save to localStorage
      setCharacterShards(updatedShards);
      localStorage.setItem('characterShards', JSON.stringify(updatedShards));
      
      toast({
        title: "Shards Collected!",
        description: `You collected ${randomAmount} ${shard.rarity} ${shard.characterName} shards!`
      });
    }
  };

  // Handle recruiting a new character
  const handleRecruitCharacter = async (characterClass?: string, type?: string) => {
    try {
      // Generate a random character for demonstration
      const randomNames = ["Eldrin", "Lyra", "Thorne", "Seraphina", "Gideon", "Isolde"];
      const randomClasses = ["Warrior", "Mage", "Rogue", "Cleric"];
      const randomAvatars = [
        "https://images.unsplash.com/photo-1577095972620-2f389ca3abcd?w=150&h=150&fit=crop",
        "https://images.unsplash.com/photo-1613477564751-fc2a7c5bbb7a?w=150&h=150&fit=crop",
        "https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=150&h=150&fit=crop"
      ];
      
      const newCharacter = {
        name: randomNames[Math.floor(Math.random() * randomNames.length)],
        class: characterClass || randomClasses[Math.floor(Math.random() * randomClasses.length)],
        level: 1,
        avatarUrl: randomAvatars[Math.floor(Math.random() * randomAvatars.length)],
        attack: 10 + Math.floor(Math.random() * 5),
        defense: 10 + Math.floor(Math.random() * 5),
        health: 100 + Math.floor(Math.random() * 20),
        speed: 10 + Math.floor(Math.random() * 5),
        vitality: 10 + Math.floor(Math.random() * 5),
        accuracy: 10 + Math.floor(Math.random() * 5),
        focus: 10 + Math.floor(Math.random() * 5),
        resilience: 10 + Math.floor(Math.random() * 5)
      };
      
      const response = await apiRequest('POST', '/api/characters', newCharacter);
      const data = await response.json();
      
      toast({
        title: "Character Recruited!",
        description: `${data.name} has joined your roster.`
      });
      
      fetchCharacters();
      setShowRecruitDialog(false);
    } catch (error) {
      console.error('Error recruiting character:', error);
      toast({
        title: "Recruitment Failed",
        description: "Unable to recruit a new character at this time.",
        variant: "destructive"
      });
    }
  };

  // Render loading state
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl animate-pulse">Loading inventory data...</div>
      </div>
    );
  }

  return (
    <>
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Inventory</h1>
        <p className="text-[#C8B8DB]/80">
          Manage your characters, auras, materials, resources, and character shards.
        </p>
      </div>
      
      {/* Inventory Tabs */}
      <Tabs defaultValue="characters" value={selectedTab} onValueChange={setSelectedTab} className="w-full mb-6">
        <TabsList className="bg-[#432874]/20 mb-6">
          <TabsTrigger value="characters" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <User className="h-4 w-4 mr-2" />
            Characters
          </TabsTrigger>
          <TabsTrigger value="auras" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Sparkles className="h-4 w-4 mr-2" />
            Auras
          </TabsTrigger>
          <TabsTrigger value="materials" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Box className="h-4 w-4 mr-2" />
            Materials
          </TabsTrigger>
          <TabsTrigger value="resources" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <Gem className="h-4 w-4 mr-2" />
            Resources
          </TabsTrigger>
          <TabsTrigger value="shards" className="data-[state=active]:bg-[#FF9D00] data-[state=active]:text-[#1A1A2E]">
            <ShoppingBag className="h-4 w-4 mr-2" />
            Character Shards
          </TabsTrigger>
        </TabsList>
        
        {/* Search & Filter Controls */}
        <div className="flex flex-wrap gap-4 mb-6">
          <div className="relative flex-grow max-w-md">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-[#C8B8DB]/50 h-4 w-4" />
            <input
              type="text"
              placeholder={`Search ${selectedTab}...`}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10 w-full bg-[#1F1D36]/80 border border-[#432874]/30 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-[#FF9D00]"
            />
          </div>
          
          <div className="flex items-center gap-2">
            <Filter className="text-[#C8B8DB]/70 h-4 w-4" />
            <Select value={filter} onValueChange={setFilter}>
              <SelectTrigger className="bg-[#1F1D36]/80 border-[#432874]/30 focus:border-[#FF9D00] focus:ring-0 w-32">
                <SelectValue placeholder="Filter" />
              </SelectTrigger>
              <SelectContent className="bg-[#1A1A2E] border-[#432874]/30">
                <SelectItem value="all">All</SelectItem>
                {selectedTab === 'characters' && (
                  <>
                    <SelectItem value="active">Active</SelectItem>
                    <SelectItem value="idle">Idle</SelectItem>
                    <SelectItem value="warrior">Warrior</SelectItem>
                    <SelectItem value="mage">Mage</SelectItem>
                    <SelectItem value="rogue">Rogue</SelectItem>
                    <SelectItem value="cleric">Cleric</SelectItem>
                  </>
                )}
                {selectedTab === 'auras' && (
                  <>
                    <SelectItem value="equipped">Equipped</SelectItem>
                    <SelectItem value="available">Available</SelectItem>
                    <SelectItem value="fire">Fire</SelectItem>
                    <SelectItem value="water">Water</SelectItem>
                    <SelectItem value="earth">Earth</SelectItem>
                    <SelectItem value="wind">Wind</SelectItem>
                  </>
                )}
                {selectedTab === 'materials' && (
                  <>
                    <SelectItem value="common">Common</SelectItem>
                    <SelectItem value="rare">Rare</SelectItem>
                    <SelectItem value="epic">Epic</SelectItem>
                  </>
                )}
                {selectedTab === 'resources' && (
                  <>
                    <SelectItem value="materials">Materials</SelectItem>
                    <SelectItem value="essences">Essences</SelectItem>
                    <SelectItem value="currencies">Currencies</SelectItem>
                  </>
                )}
                {selectedTab === 'shards' && (
                  <>
                    <SelectItem value="common">Basic</SelectItem>
                    <SelectItem value="uncommon">Rare</SelectItem>
                    <SelectItem value="rare">Epic</SelectItem>
                    <SelectItem value="epic">Mythic</SelectItem>
                    <SelectItem value="legendary">Legendary</SelectItem>
                    <SelectItem value="warrior">Warrior</SelectItem>
                    <SelectItem value="mage">Mage</SelectItem>
                    <SelectItem value="rogue">Rogue</SelectItem>
                    <SelectItem value="cleric">Cleric</SelectItem>
                  </>
                )}
              </SelectContent>
            </Select>
          </div>
          
          {selectedTab === 'characters' && (
            <Dialog open={showRecruitDialog} onOpenChange={setShowRecruitDialog}>
              <DialogTrigger asChild>
                <Button className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]">
                  <Plus className="h-4 w-4 mr-2" /> Recruit
                </Button>
              </DialogTrigger>
              <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
                <DialogHeader>
                  <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Recruit a New Character</DialogTitle>
                </DialogHeader>
                
                <div className="py-4">
                  <div className="bg-[#432874]/20 rounded-lg p-4 text-center mb-4">
                    <img
                      src="https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=250&h=250&fit=crop"
                      alt="New Character"
                      className="w-20 h-20 rounded-full border-2 border-[#FF9D00] mx-auto mb-2"
                    />
                    <p className="text-[#C8B8DB]">
                      Recruiting a new character costs <span className="text-[#FFD700] font-bold">500</span> Rogue Credits.
                    </p>
                  </div>
                  
                  <Button 
                    className="w-full bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                    onClick={() => handleRecruitCharacter()}
                  >
                    Recruit Random Character
                  </Button>
                </div>
              </DialogContent>
            </Dialog>
          )}
        </div>
        
        {/* Characters Tab */}
        <TabsContent value="characters">
          {filteredCharacters.length === 0 ? (
            <div className="bg-[#1A1A2E] rounded-xl p-8 text-center">
              <p className="text-[#C8B8DB]/80 mb-4">
                {searchTerm 
                  ? `No characters found matching "${searchTerm}"` 
                  : "You don't have any characters yet."}
              </p>
              <Button 
                className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                onClick={() => setShowRecruitDialog(true)}
              >
                <Plus className="h-4 w-4 mr-2" /> Recruit Your First Character
              </Button>
            </div>
          ) : (
            <motion.div 
              className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
              variants={container}
              initial="hidden"
              animate="show"
            >
              {filteredCharacters.map((character) => (
                <CharacterCard 
                  key={character.id} 
                  character={character} 
                  availableAuras={auras || []}
                  allAuras={auras || []}
                  refetchAura={() => fetchAuras()}
                  refetchAllAuras={() => fetchAuras()}
                  equippedAura={auras.find(aura => aura.id === character.equippedAuraId)}
                />
              ))}
            </motion.div>
          )}
        </TabsContent>
        
        {/* Auras Tab */}
        <TabsContent value="auras">
          {filteredAuras.length === 0 ? (
            <div className="bg-[#1A1A2E] rounded-xl p-8 text-center">
              <p className="text-[#C8B8DB]/80 mb-4">
                {searchTerm 
                  ? `No auras found matching "${searchTerm}"` 
                  : "You don't have any auras yet."}
              </p>
              <Button 
                className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                onClick={() => window.location.href = "/forge"}
              >
                <Sparkles className="h-4 w-4 mr-2" /> Craft Your First Aura
              </Button>
            </div>
          ) : (
            <motion.div 
              className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
              variants={container}
              initial="hidden"
              animate="show"
            >
              {/* Aura Detail Dialog */}
              <Dialog open={!!selectedAura} onOpenChange={(open) => !open && setSelectedAura(null)}>
                <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-2xl">
                  {selectedAura && (
                    <>
                      <DialogHeader>
                        <DialogTitle className="text-[#FF9D00] font-cinzel text-xl flex items-center">
                          <div className={`w-8 h-8 rounded-full flex items-center justify-center mr-3
                            ${selectedAura.element === 'Fire' ? 'bg-red-500/20' : 
                              selectedAura.element === 'Water' ? 'bg-blue-500/20' : 
                              selectedAura.element === 'Earth' ? 'bg-amber-800/20' : 
                              'bg-green-500/20'}`
                          }>
                            {selectedAura.element === 'Fire' ? (
                              <div className="text-red-500"></div>
                            ) : selectedAura.element === 'Water' ? (
                              <div className="text-blue-500"></div>
                            ) : selectedAura.element === 'Earth' ? (
                              <div className="text-amber-800"></div>
                            ) : (
                              <div className="text-green-500"></div>
                            )}
                          </div>
                          {selectedAura.name || `${selectedAura.element || 'Mysterious'} Aura`}
                        </DialogTitle>
                      </DialogHeader>
                      
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 py-4">
                        {/* Left Column - Stats */}
                        <div>
                          <div className="flex justify-between items-center mb-3">
                            <h3 className="font-semibold text-[#FF9D00]">Stats</h3>
                            <div className="px-3 py-1 rounded-md bg-[#00B9AE]/20 text-[#00B9AE] text-sm font-semibold">
                              Total Bonus: +{calculateTotalStats(selectedAura)}%
                            </div>
                          </div>
                          <div className="bg-[#1F1D36]/80 p-4 rounded-lg">
                            <div className="grid grid-cols-2 gap-x-4 gap-y-2">
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Sword className="h-3 w-3 mr-1 text-red-400" />
                                  <span>Attack</span>
                                </div>
                                <span className={`${selectedAura.attack && selectedAura.attack > 0 ? 'text-green-400' : selectedAura.attack && selectedAura.attack < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.attack === 'number' ? `${selectedAura.attack}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Target className="h-3 w-3 mr-1 text-blue-400" />
                                  <span>Accuracy</span>
                                </div>
                                <span className={`${selectedAura.accuracy && selectedAura.accuracy > 0 ? 'text-green-400' : selectedAura.accuracy && selectedAura.accuracy < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.accuracy === 'number' ? `${selectedAura.accuracy}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Shield className="h-3 w-3 mr-1 text-amber-400" />
                                  <span>Defense</span>
                                </div>
                                <span className={`${selectedAura.defense && selectedAura.defense > 0 ? 'text-green-400' : selectedAura.defense && selectedAura.defense < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.defense === 'number' ? `${selectedAura.defense}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Heart className="h-3 w-3 mr-1 text-green-400" />
                                  <span>Vitality</span>
                                </div>
                                <span className={`${selectedAura.vitality && selectedAura.vitality > 0 ? 'text-green-400' : selectedAura.vitality && selectedAura.vitality < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.vitality === 'number' ? `${selectedAura.vitality}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Footprints className="h-3 w-3 mr-1 text-cyan-400" />
                                  <span>Speed</span>
                                </div>
                                <span className={`${selectedAura.speed && selectedAura.speed > 0 ? 'text-green-400' : selectedAura.speed && selectedAura.speed < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.speed === 'number' ? `${selectedAura.speed}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <Eye className="h-3 w-3 mr-1 text-yellow-400" />
                                  <span>Focus</span>
                                </div>
                                <span className={`${selectedAura.focus && selectedAura.focus > 0 ? 'text-green-400' : selectedAura.focus && selectedAura.focus < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.focus === 'number' ? `${selectedAura.focus}%` : '0%'}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <div className="flex items-center">
                                  <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                                  <span>Resilience</span>
                                </div>
                                <span className={`${selectedAura.resilience && selectedAura.resilience > 0 ? 'text-green-400' : selectedAura.resilience && selectedAura.resilience < 0 ? 'text-red-400' : 'text-[#00B9AE]'}`}>
                                  {typeof selectedAura.resilience === 'number' ? `${selectedAura.resilience}%` : '0%'}
                                </span>
                              </div>
                            </div>
                            
                            {/* Display Skills if any */}
                            {selectedAura.skills && Array.isArray(selectedAura.skills) && selectedAura.skills.length > 0 && (
                              <>
                                <div className="text-[#00B9AE] text-xs mt-4 mb-1">Skills:</div>
                                <div className="mt-1 space-y-2">
                                  {selectedAura.skills.map((skill: any, index: number) => (
                                    <div key={index} className="bg-[#432874]/20 p-2 rounded-lg">
                                      <div className="flex items-center justify-between">
                                        <div className="flex items-center">
                                          <Sparkles className="h-3 w-3 mr-1 text-yellow-400 flex-shrink-0" />
                                          <span className="font-semibold text-xs">{skill.name}</span>
                                        </div>
                                        {skill.type && (
                                          <Badge className={`
                                            ${skill.type === 'Ultimate' ? 'bg-[#FF9D00]/20 text-[#FF9D00]' : 
                                              skill.type === 'Advanced' ? 'bg-[#00B9AE]/20 text-[#00B9AE]' : 
                                              'bg-[#C8B8DB]/20 text-[#C8B8DB]'}
                                          `}>
                                            {skill.type}
                                          </Badge>
                                        )}
                                      </div>
                                      
                                      {skill.description && (
                                        <div className="ml-4 mt-1 text-xs text-[#C8B8DB]/80">
                                          {skill.description}
                                        </div>
                                      )}
                                      
                                      <div className="grid grid-cols-2 gap-2 ml-4 mt-2">
                                        {/* Damage Multiplier */}
                                        {skill.damage !== undefined && (
                                          <div className="flex items-center">
                                            <Sword className="h-3 w-3 mr-1 text-red-400 flex-shrink-0" />
                                            <span className="text-xs">Damage: x{skill.damage}</span>
                                          </div>
                                        )}
                                        
                                        {/* Targets */}
                                        {skill.targets !== undefined && (
                                          <div className="flex items-center">
                                            <Target className="h-3 w-3 mr-1 text-blue-400 flex-shrink-0" />
                                            <span className="text-xs">Targets: {skill.targets}</span>
                                          </div>
                                        )}
                                      </div>
                                      
                                      {/* Special Effect */}
                                      {skill.effect && (
                                        <div className="flex items-start ml-4 mt-2">
                                          <Activity className="h-3 w-3 mr-1 text-purple-400 flex-shrink-0 mt-0.5" />
                                          <span className="text-xs text-[#00B9AE]">Effect: {skill.effect}</span>
                                        </div>
                                      )}
                                      
                                      {/* Cooldown if applicable */}
                                      {skill.cooldown && (
                                        <div className="flex items-center ml-4 mt-1">
                                          <Zap className="h-3 w-3 mr-1 text-yellow-400 flex-shrink-0" />
                                          <span className="text-xs">Cooldown: {skill.cooldown} turn{skill.cooldown !== 1 ? 's' : ''}</span>
                                        </div>
                                      )}
                                      
                                      {/* Level/Tier Info */}
                                      {skill.level && (
                                        <div className="flex items-center ml-4 mt-1">
                                          <ArrowUpToLine className="h-3 w-3 mr-1 text-green-400 flex-shrink-0" />
                                          <span className="text-xs">Required Level: {skill.level}</span>
                                        </div>
                                      )}
                                    </div>
                                  ))}
                                </div>
                              </>
                            )}
                          </div>
                        </div>
                        
                        {/* Right Column - Forge Information */}
                        <div>
                          <h3 className="font-semibold text-[#FF9D00] mb-3">Forge Information</h3>
                          <div className="bg-[#1F1D36]/80 p-4 rounded-lg">
                            <div className="mb-3">
                              <div className="text-sm font-semibold mb-1">Element</div>
                              <Badge className={`
                                ${selectedAura.element === 'Fire' ? 'bg-red-500/20 text-red-400' : 
                                  selectedAura.element === 'Water' ? 'bg-blue-500/20 text-blue-400' : 
                                  selectedAura.element === 'Earth' ? 'bg-amber-800/20 text-amber-600' : 
                                  'bg-green-500/20 text-green-400'}
                              `}>
                                {selectedAura.element || 'Unknown'}
                              </Badge>
                            </div>
                            
                            <div className="mb-3">
                              <div className="text-sm font-semibold mb-1">Level</div>
                              <div className="text-[#FF9D00]">{selectedAura.level || 1}</div>
                            </div>
                            
                            {selectedAura.equippedByCharacterId && (
                              <div className="mb-3">
                                <div className="text-sm font-semibold mb-1">Equipped By</div>
                                <div className="text-[#00B9AE]">
                                  {characters.find(c => c.id === selectedAura.equippedByCharacterId)?.name || 'Unknown Character'}
                                </div>
                              </div>
                            )}
                            
                            {/* All source information removed as requested */}
                          </div>
                        </div>
                      </div>
                    </>
                  )}
                </DialogContent>
              </Dialog>
              
              {/* Sort auras by total stat bonus */}
              {filteredAuras
                .slice()
                .sort((a, b) => calculateTotalStats(b) - calculateTotalStats(a))
                .map((aura) => (
                <motion.div
                  key={aura.id}
                  variants={item}
                  onClick={() => setSelectedAura(aura)}
                  className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden cursor-pointer hover:border-[#FF9D00]/50 hover:shadow-lg transition-all"
                >
                  <div className="p-4">
                    <div className="flex items-center mb-3">
                      <div className={`w-12 h-12 rounded-full flex items-center justify-center mr-3
                        ${aura.element?.toLowerCase() === 'fire' ? 'bg-red-500/20' : 
                          aura.element?.toLowerCase() === 'water' ? 'bg-blue-500/20' : 
                          aura.element?.toLowerCase() === 'earth' ? 'bg-amber-800/20' : 
                          aura.element?.toLowerCase() === 'wind' ? 'bg-cyan-500/20' :
                          'bg-green-500/20'}`
                      }>
                        {aura.element?.toLowerCase() === 'fire' ? (
                          <div className="text-red-500"></div>
                        ) : aura.element?.toLowerCase() === 'water' ? (
                          <div className="text-blue-500"></div>
                        ) : aura.element?.toLowerCase() === 'earth' ? (
                          <div className="text-amber-800"></div>
                        ) : aura.element?.toLowerCase() === 'wind' ? (
                          <div className="text-cyan-500"></div>
                        ) : (
                          <div className="text-purple-500"></div>
                        )}
                      </div>
                      <div>
                        <h3 className="font-cinzel font-semibold text-[#FF9D00]">
                          {aura.name || `${aura.element || 'Mysterious'} Aura`}
                        </h3>
                        <div className="flex items-center gap-2">
                          <div className="text-sm text-[#C8B8DB]/80">
                            Level {aura.level || 1}
                          </div>
                          <div className="px-2 py-0.5 rounded bg-[#00B9AE]/20 text-[#00B9AE] text-xs font-semibold">
                            Total: +{calculateTotalStats(aura)}%
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <div className="mt-2 bg-[#1F1D36]/80 p-3 rounded-lg text-sm">
                      <h4 className="font-semibold mb-1">Stat Multipliers:</h4>
                      <div className="grid grid-cols-2 gap-x-2 gap-y-1">
                        {/* Show all stats - show 0 if not present */}
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Sword className="h-3 w-3 mr-1 text-red-400" />
                            <span>Attack</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.attack === 'number' ? `${aura.attack}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Target className="h-3 w-3 mr-1 text-blue-400" />
                            <span>Accuracy</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.accuracy === 'number' ? `${aura.accuracy}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Shield className="h-3 w-3 mr-1 text-amber-400" />
                            <span>Defense</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.defense === 'number' ? `${aura.defense}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Heart className="h-3 w-3 mr-1 text-green-400" />
                            <span>Vitality</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.vitality === 'number' ? `${aura.vitality}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Footprints className="h-3 w-3 mr-1 text-cyan-400" />
                            <span>Speed</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.speed === 'number' ? `${aura.speed}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <Eye className="h-3 w-3 mr-1 text-yellow-400" />
                            <span>Focus</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.focus === 'number' ? `${aura.focus}%` : '0%'}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <div className="flex items-center">
                            <CircleOff className="h-3 w-3 mr-1 text-purple-400" />
                            <span>Resilience</span>
                          </div>
                          <span className="text-[#00B9AE]">
                            {typeof aura.resilience === 'number' ? `${aura.resilience}%` : '0%'}
                          </span>
                        </div>
                      </div>
                      
                      {/* Note: Stat bonuses are now displayed directly in the attributes above */}
                      
                      {/* Forge information removed as requested */}
                      
                      {/* Skills list */}
                      {aura.skills && (typeof aura.skills === 'object' || typeof aura.skills === 'string') && (
                        <div className="mt-3 pt-3 border-t border-[#432874]/30">
                          <h4 className="text-xs font-semibold mb-1 text-[#00B9AE]">Active Skills:</h4>
                          <div className="text-xs">
                            {(() => {
                              let skills = [];
                              try {
                                skills = typeof aura.skills === 'string' 
                                  ? JSON.parse(aura.skills) 
                                  : aura.skills;
                              } catch (e) {
                                return 'No active skills';
                              }
                              
                              if (!Array.isArray(skills) || skills.length === 0) {
                                return 'No active skills';
                              }
                              
                              return (
                                <ul className="list-disc list-inside">
                                  {skills.map((skill, idx) => (
                                    <li key={idx}>
                                      <span className="font-semibold">{skill.name}</span>: {skill.description}
                                    </li>
                                  ))}
                                </ul>
                              );
                            })()}
                          </div>
                        </div>
                      )}
                    </div>
                    
                    <div className="mt-3 text-center">
                      {aura.equippedByCharacterId ? (
                        <div className="bg-[#00B9AE]/20 text-[#00B9AE] py-1 px-2 rounded text-sm">
                          Equipped by {(() => {
                            const char = characters.find(c => c.id === aura.equippedByCharacterId);
                            return char ? char.name : 'a character';
                          })()}
                        </div>
                      ) : (
                        <Button 
                          size="sm" 
                          className="w-full bg-[#432874] hover:bg-[#432874]/80 text-xs"
                        >
                          Equip to Character
                        </Button>
                      )}
                    </div>
                  </div>
                </motion.div>
              ))}
            </motion.div>
          )}
        </TabsContent>
        
        {/* Materials Tab */}
        <TabsContent value="materials">
          <motion.div 
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            variants={container}
            initial="hidden"
            animate="show"
          >
            {resources.filter(r => r.type === 'material').map((material) => (
              <motion.div
                key={material.id}
                variants={item}
                className="bg-[#1A1A2E] border border-[#432874]/30 rounded-lg p-4"
              >
                <div className="flex items-center">
                  <div className="w-10 h-10 rounded-full bg-[#432874]/30 flex items-center justify-center mr-3">
                    <Box className="h-5 w-5 text-[#C8B8DB]" />
                  </div>
                  <div>
                    <h3 className="font-semibold text-[#FF9D00]">{material.name}</h3>
                    <div className="text-sm text-[#C8B8DB]/80">Material</div>
                  </div>
                  <div className="ml-auto bg-[#432874]/30 px-3 py-1 rounded-full">
                    <span className="text-[#C8B8DB]">{material.quantity}</span>
                  </div>
                </div>
                <div className="mt-3 text-sm text-[#C8B8DB]/70">
                  {material.description || "Used for crafting and upgrading items."}
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
        
        {/* Resources Tab */}
        <TabsContent value="resources">
          <motion.div 
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            variants={container}
            initial="hidden"
            animate="show"
          >
            {filteredResources.map((resource) => (
              <motion.div
                key={resource.id}
                variants={item}
                className="bg-[#1A1A2E] border border-[#432874]/30 rounded-lg p-4"
              >
                <div className="flex items-center">
                  <div className="w-10 h-10 rounded-full bg-[#432874]/30 flex items-center justify-center mr-3">
                    {resource.type === 'essence' ? (
                      <Sparkles className="h-5 w-5 text-[#FF9D00]" />
                    ) : resource.type === 'currency' ? (
                      <Gem className="h-5 w-5 text-[#FFD700]" />
                    ) : (
                      <Box className="h-5 w-5 text-[#C8B8DB]" />
                    )}
                  </div>
                  <div>
                    <h3 className="font-semibold text-[#FF9D00]">{resource.name}</h3>
                    <div className="text-sm text-[#C8B8DB]/80 capitalize">{resource.type}</div>
                  </div>
                  <div className="ml-auto bg-[#432874]/30 px-3 py-1 rounded-full">
                    <span className="text-[#C8B8DB]">{resource.quantity}</span>
                  </div>
                </div>
                <div className="mt-3 text-sm text-[#C8B8DB]/70">
                  {resource.description || `Used for ${resource.type === 'essence' ? 'crafting auras' : 
                    resource.type === 'currency' ? 'purchasing items and upgrades' : 
                    'crafting and upgrading'}.`}
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
        
        {/* Character Shards Tab */}
        <TabsContent value="shards">
          <motion.div 
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
            variants={container}
            initial="hidden"
            animate="show"
          >
            {filteredShards.map((shard) => (
              <motion.div
                key={shard.id}
                variants={item}
                className="bg-[#1A1A2E] border border-[#432874]/30 rounded-lg p-4"
              >
                <div className="flex items-center">
                  <div className={`w-12 h-12 rounded-full overflow-hidden border-2 flex-shrink-0 mr-3
                    ${shard.rarity === 'common' ? 'border-gray-600' : 
                      shard.rarity === 'uncommon' ? 'border-blue-600' : 
                      shard.rarity === 'rare' ? 'border-purple-600' : 
                      shard.rarity === 'epic' ? 'border-red-600' : 
                      'border-yellow-600'}`
                  }>
                    <img 
                      src={shard.avatarUrl || "/assets/default-avatar.png"}
                      alt={shard.characterName}
                      className="w-full h-full object-cover"
                    />
                  </div>
                  <div>
                    <h3 className="font-semibold text-[#FF9D00]">{shard.name}</h3>
                    <div className={`text-sm capitalize
                      ${shard.rarity === 'common' ? 'text-gray-300' : 
                        shard.rarity === 'uncommon' ? 'text-blue-300' : 
                        shard.rarity === 'rare' ? 'text-purple-300' : 
                        shard.rarity === 'epic' ? 'text-red-300' : 
                        'text-yellow-300'}`
                    }>
                      {shard.rarity === 'common' ? 'Basic' : 
                        shard.rarity === 'uncommon' ? 'Rare' : 
                        shard.rarity === 'rare' ? 'Epic' : 
                        shard.rarity === 'epic' ? 'Mythic' : 
                        'Legendary'}  {shard.characterClass}
                    </div>
                    <div className="flex mt-1 text-xs text-[#C8B8DB]">
                      <span className="font-medium">{shard.quantity}</span>
                      <span className="text-[#C8B8DB]/60 mx-1">/</span>
                      <span className="font-medium">{shard.required}</span>
                    </div>
                  </div>
                </div>
              </motion.div>
            ))}
          </motion.div>
        </TabsContent>
      </Tabs>
    </>
  );
};

export default InventoryView;

=== client/src/components/battles/BattleLog.tsx ===
import { useState, useEffect, useRef } from 'react';
import { 
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription,
  DialogFooter, DialogClose
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { Pause, Play, SkipForward, Swords, Zap, Heart, Shield, Info } from 'lucide-react';
import { ScrollArea } from '@/components/ui/scroll-area';

/**
 * Types for battle system
 */
interface StatusEffect {
  name: string;
  duration: number;
  effect: string; 
  value: number;  
  source?: string; 
}

interface BattleUnit {
  id: string | number;
  name: string;
  hp: number;
  maxHp: number;
  attackMeter: number;
  isAlly?: boolean;
  totalDamageDealt: number;
  totalDamageReceived: number;
  totalHealingDone: number;
  totalHealingReceived: number;
  stats: {
    attack: number;
    vitality: number;
    speed: number;
  };
  auraBonus?: {
    attack: number;
    vitality: number;
    speed: number;
    focus?: number;
    accuracy?: number;
    defense?: number;
    resilience?: number;
    element?: string;
  };
  skills: {
    basic: { name: string; damage: number }; 
    advanced?: { name: string; damage: number; cooldown: number };
    ultimate?: { name: string; damage: number; cooldown: number };
  };
  statusEffects?: StatusEffect[];
}

interface BattleAction {
  actor: string;
  target: string;
  skill: string;
  damage: number;
  isCritical: boolean;
  healing?: boolean;
  message?: string;
  type?: string;
}

interface BattleEvent {
  type: string;
  data?: any;
  allies?: BattleUnit[];
  enemies?: BattleUnit[];
  timestamp?: number;
  // Round-specific properties
  number?: number;            // Round number (when type === 'round')
  actions?: BattleAction[];   // Array of actions in this round
  remainingAllies?: number;   // Number of allies still alive after round
  remainingEnemies?: number;  // Number of enemies still alive after round
  // Stage progression properties
  currentStage?: number;
  totalStages?: number;       // Total number of stages in the dungeon
  message?: string;
  aliveAllies?: BattleUnit[];
  newEnemies?: BattleUnit[];
  // System message
  system_message?: string;
  // Battle completion
  summary?: string;           // Summary of the battle outcome
  victory?: boolean;          // Whether the battle was won
  survivingAllies?: string[]; // Names of surviving allies
}

interface BattleLogProps {
  isOpen: boolean;
  onClose: () => void;
  battleLog: BattleEvent[];
  runId: number | null;
  onCompleteDungeon?: (runId: number) => void;
}

/**
 * BattleLog Component
 * Displays a visual representation of a dungeon battle
 */
const BattleLog = ({ isOpen, onClose, battleLog, runId, onCompleteDungeon }: BattleLogProps) => {
  // State for battle display
  const [units, setUnits] = useState<BattleUnit[]>([]);
  const [actionLog, setActionLog] = useState<string[]>([]);
  const [detailedActionLog, setDetailedActionLog] = useState<string[]>([]);
  const [currentStage, setCurrentStage] = useState<number>(0);
  const [currentAction, setCurrentAction] = useState<number>(0);
  const [isComplete, setIsComplete] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(true);
  const [playbackSpeed, setPlaybackSpeed] = useState<number>(1);
  const [activeTab, setActiveTab] = useState<string>('battle');
  
  // References for animation control
  const battleAnimationRef = useRef<NodeJS.Timeout | null>(null);
  const battleStepRef = useRef<number>(0);
  
  // Effect to process battle log when opened
  useEffect(() => {
    if (isOpen) {
      if (battleLog && battleLog.length > 0) {
        // Initialize battle state
        setActionLog(['Battle initialized. Press Play to begin...']);
        setDetailedActionLog(['Welcome to the new dungeon battle system.']);
        
        // Extract initial units from battle_start event
        const initEvent = battleLog.find(event => 
          event.type === 'battle_start' || 
          event.type === 'init'
        );
        
        if (initEvent) {
          // Extract allies and enemies and ensure they have proper health values
          const allies = (initEvent.allies || []).map(unit => ({
            ...unit,
            isAlly: true,
            hp: unit.hp || unit.maxHp, // Ensure HP is set (fallback to maxHp if hp is 0)
            attackMeter: unit.attackMeter || 0 // Ensure attack meter is set
          }));
          
          const enemies = (initEvent.enemies || []).map(unit => ({
            ...unit,
            isAlly: false,
            hp: unit.hp || unit.maxHp, // Ensure HP is set (fallback to maxHp if hp is 0)
            attackMeter: unit.attackMeter || 0 // Ensure attack meter is set
          }));
          
          console.log("Initial units:", [...allies, ...enemies]);
          
          // Set units state
          setUnits([...allies, ...enemies]);
        }
      } else {
        // No battle log data
        setActionLog([
          'No battle data available.',
          'You can still complete this dungeon to free your characters.',
          'Click the "Complete Dungeon & Claim Rewards" button below.'
        ]);
        setDetailedActionLog([
          'This dungeon has no battle log, but you can still complete it.',
          'Completing the dungeon will free your characters for other tasks.'
        ]);
      }
    }
  }, [isOpen, battleLog]);
  
  // Effect to update attack meters during battle
  useEffect(() => {
    if (!isOpen || isPaused || units.length === 0) {
      return; // Don't update meters if battle is paused or closed
    }
    
    // Create an interval to increment attack meters
    const meterInterval = setInterval(() => {
      setUnits(prevUnits => {
        // Create a new array to ensure React detects the change
        let updatedUnits = [...prevUnits];
        let anyUnitReachedFull = false;
        
        // First pass: update meters for all units
        updatedUnits = updatedUnits.map(unit => {
          // Skip defeated units
          if (unit.hp <= 0) {
            return unit;
          }
          
          // Calculate speed-based meter gain
          const speedMultiplier = unit.stats.speed / 50;
          const meterGain = 5 * Math.max(0.5, Math.min(2, speedMultiplier));
          const newMeterValue = Math.min(100, (unit.attackMeter || 0) + meterGain);
          
          // Check if any unit has reached 100%
          if (newMeterValue >= 100 && (unit.attackMeter || 0) < 100) {
            anyUnitReachedFull = true;
          }
          
          // Return updated unit with new attack meter value
          return {
            ...unit,
            attackMeter: newMeterValue
          };
        });
        
        // Second pass: if any unit reached 100%, process an attack
        if (anyUnitReachedFull) {
          // Find the first unit with a full meter
          const attackingUnitIndex = updatedUnits.findIndex(unit => unit.hp > 0 && unit.attackMeter >= 100);
          
          if (attackingUnitIndex >= 0) {
            const attacker = updatedUnits[attackingUnitIndex];
            
            // Determine target (enemies target allies, allies target enemies)
            const possibleTargets = updatedUnits.filter(unit => 
              unit.hp > 0 && unit.isAlly !== attacker.isAlly
            );
            
            if (possibleTargets.length > 0) {
              // Choose a random target
              const targetIndex = Math.floor(Math.random() * possibleTargets.length);
              const target = possibleTargets[targetIndex];
              const targetUnitIndex = updatedUnits.findIndex(u => u.id === target.id);
              
              // Calculate damage (basic attack)
              const damage = Math.floor(attacker.stats.attack * 0.8 + Math.random() * attacker.stats.attack * 0.4);
              const isCritical = Math.random() < 0.1; // 10% critical chance
              const finalDamage = isCritical ? Math.floor(damage * 1.5) : damage;
              
              // Update target's health
              const newHp = Math.max(0, target.hp - finalDamage);
              updatedUnits[targetUnitIndex] = {
                ...updatedUnits[targetUnitIndex],
                hp: newHp
              };
              
              // Reset attacker's meter
              updatedUnits[attackingUnitIndex] = {
                ...updatedUnits[attackingUnitIndex],
                attackMeter: 0
              };
              
              // Add attack log
              const attackMessage = `${attacker.name} used ${attacker.skills.basic.name} on ${target.name} for ${finalDamage} damage${isCritical ? ' (CRITICAL!)' : ''}`;
              setActionLog(prev => [...prev, attackMessage]);
              
              // If target defeated, add log
              if (newHp <= 0) {
                setActionLog(prev => [...prev, `${target.name} was defeated!`]);
              }
            }
          }
        }
        
        return updatedUnits;
      });
    }, 300); // Update every 300ms
    
    return () => clearInterval(meterInterval);
  }, [isOpen, isPaused, units.length]);
  
  // Function to handle playback controls
  const togglePlayback = () => {
    console.log("Toggle playback called, current isPaused:", isPaused);
    
    const newIsPaused = !isPaused;
    setIsPaused(newIsPaused);
    
    if (!newIsPaused) {
      // Starting playback
      if (!battleAnimationRef.current) {
        console.log("Starting battle animation");
        
        // Add a small delay to ensure state is updated
        setTimeout(() => {
          if (units.length > 0) {
            // Find the first unit with 0 attack meter and set it to a small value
            // to kickstart the animation
            setUnits(prevUnits => 
              prevUnits.map(unit => ({
                ...unit,
                attackMeter: unit.attackMeter > 0 ? unit.attackMeter : 5
              }))
            );
            
            // Start the battle animation
            advanceBattle();
          }
        }, 100);
      }
    } else {
      // Pausing playback
      if (battleAnimationRef.current) {
        console.log("Pausing battle animation");
        clearTimeout(battleAnimationRef.current);
        battleAnimationRef.current = null;
      }
    }
  };
  
  // Function to advance the battle animation
  const advanceBattle = () => {
    console.log("Advancing battle, current step:", battleStepRef.current);
    
    // Increment action counter
    setCurrentAction(prev => prev + 1);
    
    // Check if we have battle logs to process
    if (!battleLog || battleLog.length === 0) {
      console.log("No battle logs available");
      setActionLog(prev => [...prev, "No battle log data available"]);
      setIsPaused(true);
      return;
    }
    
    // Update battle state based on log
    if (battleLog && battleLog.length > battleStepRef.current) {
      const event = battleLog[battleStepRef.current];
      console.log("Processing event:", event.type, event);
      
      try {
        // Process event based on type
        if (event.type === 'round') {
          // Round events have actions
          if (event.actions && event.actions.length > 0) {
            // Add log entries for each action
            event.actions.forEach(action => {
              // Create a formatted action message string
              const actionMessage = `${action.actor} used ${action.skill} on ${action.target} for ${action.damage} damage${action.isCritical ? ' (CRITICAL!)' : ''}`;
              setActionLog(prev => [...prev, actionMessage]);
            });
          }
          
          // Update unit health based on remaining units
          if (event.allies && Array.isArray(event.allies)) {
            setUnits(prev => {
              const updatedUnits = [...prev];
              // Update ally units
              for (const ally of event.allies || []) {
                const allyIndex = updatedUnits.findIndex(u => u.id === ally.id);
                if (allyIndex >= 0) {
                  updatedUnits[allyIndex] = {
                    ...updatedUnits[allyIndex],
                    ...ally,
                    hp: ally.hp || 0, // Ensure HP is not undefined
                    attackMeter: ally.attackMeter || 0
                  };
                }
              }
              return updatedUnits;
            });
          }
          
          if (event.enemies && Array.isArray(event.enemies)) {
            setUnits(prev => {
              const updatedUnits = [...prev];
              // Update enemy units
              for (const enemy of event.enemies || []) {
                const enemyIndex = updatedUnits.findIndex(u => u.id === enemy.id);
                if (enemyIndex >= 0) {
                  updatedUnits[enemyIndex] = {
                    ...updatedUnits[enemyIndex],
                    ...enemy,
                    hp: enemy.hp || 0, // Ensure HP is not undefined
                    attackMeter: enemy.attackMeter || 0
                  };
                }
              }
              return updatedUnits;
            });
          }
        } else if (event.type === 'battle_start' || event.type === 'init') {
          // Battle initialization
          const message = typeof event.message === 'string' ? event.message : "Battle initialized";
          setActionLog(prev => [...prev, message]);
          
          // Set initial units if needed
          if (units.length === 0 && event.allies && event.enemies) {
            const allies = (event.allies || []).map(unit => ({
              ...unit,
              isAlly: true,
              hp: unit.hp || unit.maxHp,
              attackMeter: unit.attackMeter || 0
            }));
            
            const enemies = (event.enemies || []).map(unit => ({
              ...unit,
              isAlly: false,
              hp: unit.hp || unit.maxHp,
              attackMeter: unit.attackMeter || 0
            }));
            
            setUnits([...allies, ...enemies]);
          }
        } else if (event.type === 'stage_complete') {
          // Stage completion
          setCurrentStage(event.currentStage || 0);
          const message = typeof event.message === 'string' 
            ? event.message 
            : `Stage ${event.currentStage || '?'} completed!`;
          setActionLog(prev => [...prev, message]);
          
          // Update units with living allies for next stage
          if (event.aliveAllies && Array.isArray(event.aliveAllies)) {
            setUnits(prev => {
              // Filter out dead allies and keep enemies for visualization
              const updatedUnits = prev.filter(unit => 
                !unit.isAlly || (unit.isAlly && 
                  event.aliveAllies && 
                  Array.isArray(event.aliveAllies) && 
                  event.aliveAllies.some(a => a && a.id === unit.id))
              );
              
              // Update ally stats
              if (event.aliveAllies && Array.isArray(event.aliveAllies)) {
                for (const ally of event.aliveAllies) {
                  if (ally) {
                    const allyIndex = updatedUnits.findIndex(u => u.id === ally.id);
                    if (allyIndex >= 0) {
                      updatedUnits[allyIndex] = {
                        ...updatedUnits[allyIndex],
                        ...ally,
                        isAlly: true,
                        hp: (ally.hp != null) ? ally.hp : ally.maxHp, // Ensure HP is set
                        attackMeter: 0 // Reset attack meter for next stage
                      };
                    }
                  }
                }
              }
              
              return updatedUnits;
            });
          }
        } else if (event.type === 'stage_start') {
          // Start of a new stage
          setCurrentStage(event.currentStage || 0);
          const message = typeof event.message === 'string' 
            ? event.message 
            : `Stage ${event.currentStage || '?'} begins!`;
          setActionLog(prev => [...prev, message]);
          
          // Add new enemies for this stage
          if (event.enemies && Array.isArray(event.enemies)) {
            const newEnemies = event.enemies.map(enemy => ({
              ...enemy,
              isAlly: false,
              hp: enemy.hp || enemy.maxHp,
              attackMeter: 0
            }));
            
            // Update units by replacing enemies and keeping allies
            setUnits(prev => {
              // Keep only allies from previous stage
              const allies = prev.filter(unit => unit.isAlly);
              // Add new enemies
              return [...allies, ...newEnemies];
            });
          }
        } else if (event.type === 'battle_end') {
          // Battle ended
          setIsComplete(true);
          // Handle battle end message with proper type checking
          let message = "Battle completed!";
          
          if (typeof event.message === 'string') {
            message = event.message;
          } else if (typeof event.summary === 'string') {
            message = event.summary;
          }
          
          setActionLog(prev => [...prev, message]);
        } else if (event.type === 'system_message') {
          // System message - ensure we always add a valid string to the log
          let message = "System notification";
          
          if (event.system_message && typeof event.system_message === 'string') {
            message = event.system_message;
          } else if (event.message && typeof event.message === 'string') {
            message = event.message;
          }
          
          setActionLog(prev => [...prev, message]);
        } else {
          // Unknown event type
          setActionLog(prev => [...prev, `Unknown event: ${event.type}`]);
        }
      } catch (error) {
        console.error("Error processing battle event:", error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        setActionLog(prev => [...prev, `Error: ${errorMessage}`]);
      }
      
      // Increment step
      battleStepRef.current += 1;
    } else {
      // End of battle log
      setActionLog(prev => [...prev, "Battle playback complete"]);
      setIsPaused(true);
      return;
    }
    
    // Schedule next step with delay based on playback speed
    const delay = Math.max(200, 1000 / playbackSpeed);
    battleAnimationRef.current = setTimeout(() => {
      // Only continue if still in playback mode
      if (!isPaused) {
        advanceBattle();
      }
    }, delay);
  };
  
  // Function to handle changing playback speed
  const handleSpeedChange = (newSpeed: number) => {
    setPlaybackSpeed(newSpeed);
  };
  
  // Calculate health percentage for display
  const calculateHealthPercent = (hp: number, maxHp: number): number => {
    return Math.max(0, Math.min(100, (hp / maxHp) * 100));
  };
  
  // Calculate effective speed with status effects
  const calculateEffectiveSpeed = (unit: BattleUnit): number => {
    let baseSpeed = unit.stats.speed;
    
    // Apply aura speed bonus if available
    if (unit.auraBonus?.speed) {
      baseSpeed = Math.floor(baseSpeed * (1 + unit.auraBonus.speed / 100));
    }
    
    // Apply status effects if present
    if (unit.statusEffects && unit.statusEffects.length > 0) {
      // Find all speed reduction effects
      const speedReductionEffects = unit.statusEffects.filter(effect => 
        effect.effect === "ReduceSpd"
      );
      
      // Apply each effect
      for (const effect of speedReductionEffects) {
        const reductionMultiplier = 1 - (effect.value / 100);
        baseSpeed = Math.floor(baseSpeed * reductionMultiplier);
      }
    }
    
    return baseSpeed;
  };
  
  // Calculate effective attack with status effects
  const calculateEffectiveAttack = (unit: BattleUnit): number => {
    let attackValue = unit.stats.attack;
    
    // Apply aura attack bonus if available
    if (unit.auraBonus?.attack) {
      attackValue = Math.floor(attackValue * (1 + unit.auraBonus.attack / 100));
    }
    
    // Apply status effects if present
    if (unit.statusEffects && unit.statusEffects.length > 0) {
      // Find all attack reduction effects
      const attackReductionEffects = unit.statusEffects.filter(effect => 
        effect.effect === "ReduceAtk"
      );
      
      // Apply each effect
      for (const effect of attackReductionEffects) {
        const reductionMultiplier = 1 - (effect.value / 100);
        attackValue = Math.floor(attackValue * reductionMultiplier);
      }
    }
    
    return attackValue;
  };
  
  // Render status effect icon with tooltip
  const renderStatusEffect = (effect: StatusEffect, index: number, isAlly: boolean) => {
    // Get icon based on effect type
    let icon;
    let bgColor = "bg-gray-800";
    
    if (effect.effect === "ReduceAtk") {
      icon = <Swords size={14} className="text-red-400" />;
      bgColor = "bg-red-900/50";
    } else if (effect.effect === "ReduceSpd") {
      icon = <Zap size={14} className="text-blue-400" />;
      bgColor = "bg-blue-900/50";
    } else if (effect.effect === "Burn") {
      icon = <div className="w-2 h-2 bg-orange-500 rounded-full" />;
      bgColor = "bg-orange-900/50";
    } else if (effect.effect === "Poison") {
      icon = <div className="w-2 h-2 bg-green-500 rounded-full" />;
      bgColor = "bg-green-900/50";
    } else if (effect.effect === "Heal") {
      icon = <Heart size={14} className="text-green-400" />;
      bgColor = "bg-green-900/50";
    } else if (effect.effect === "Shield") {
      icon = <Shield size={14} className="text-blue-400" />;
      bgColor = "bg-blue-900/50";
    } else {
      icon = <Info size={14} className="text-gray-400" />;
    }
    
    return (
      <TooltipProvider key={`status-${effect.name}-${index}`}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className={`w-5 h-5 rounded-full flex items-center justify-center ${bgColor}`}>
              {icon}
              <span className="absolute -top-1 -right-1 text-[10px] bg-gray-900 rounded-full w-3 h-3 flex items-center justify-center">
                {effect.duration}
              </span>
            </div>
          </TooltipTrigger>
          <TooltipContent side={isAlly ? "top" : "bottom"} className="p-2 max-w-[200px] bg-[#251942] border border-[#6A3FB5]">
            <p className="font-semibold text-xs">{effect.name}</p>
            <p className="text-xs text-[#C8B8DB]">
              {effect.effect === "ReduceAtk" && `Reduces attack by ${effect.value}%`}
              {effect.effect === "ReduceSpd" && `Reduces speed by ${effect.value}%`}
              {effect.effect === "Burn" && `Deals ${effect.value} damage per action`}
              {effect.effect === "Poison" && `Deals ${effect.value} damage per action`}
              {effect.effect === "Heal" && `Heals ${effect.value} HP per action`}
              {effect.effect === "Shield" && `Absorbs ${effect.value} damage`}
            </p>
            {effect.source && <p className="text-xs italic mt-1">From: {effect.source}</p>}
            <p className="text-xs mt-1">Duration: {effect.duration} actions</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  };
  
  // Render unit stats in tooltip
  const renderUnitStats = (unit: BattleUnit) => {
    // Calculate effective stats with status effects
    const effectiveSpeed = calculateEffectiveSpeed(unit);
    const effectiveAttack = calculateEffectiveAttack(unit);
    
    return (
      <div className="space-y-2 text-xs">
        <div className="flex justify-between">
          <span className="flex items-center gap-1">
            <Swords size={12} /> Attack:
          </span>
          <span className="font-semibold">
            {effectiveAttack}
            {unit.auraBonus?.attack && (
              <span className="text-green-400 ml-1">+{unit.auraBonus.attack}%</span>
            )}
          </span>
        </div>
        
        <div className="flex justify-between">
          <span className="flex items-center gap-1">
            <Heart size={12} /> Vitality:
          </span>
          <span className="font-semibold">
            {unit.stats.vitality}
            {unit.auraBonus?.vitality && (
              <span className="text-green-400 ml-1">+{unit.auraBonus.vitality}%</span>
            )}
          </span>
        </div>
        
        <div className="flex justify-between">
          <span className="flex items-center gap-1">
            <Zap size={12} /> Speed:
          </span>
          <span className="font-semibold">
            {effectiveSpeed}
            {unit.auraBonus?.speed && (
              <span className="text-green-400 ml-1">+{unit.auraBonus.speed}%</span>
            )}
          </span>
        </div>
        
        <div className="mt-3 border-t border-[#6A3FB5] pt-2">
          <div className="text-[#C8B8DB] mb-1">Skills:</div>
          <div className="space-y-1">
            <div>Basic: {unit.skills.basic.name} ({unit.skills.basic.damage} dmg)</div>
            {unit.skills.advanced && (
              <div>Advanced: {unit.skills.advanced.name} ({unit.skills.advanced.damage} dmg)</div>
            )}
            {unit.skills.ultimate && (
              <div>Ultimate: {unit.skills.ultimate.name} ({unit.skills.ultimate.damage} dmg)</div>
            )}
          </div>
        </div>
        
        {/* Battle Statistics */}
        {unit.totalDamageDealt > 0 && (
          <div className="mt-3 border-t border-[#6A3FB5] pt-2">
            <div className="text-[#C8B8DB] mb-1">Battle Stats:</div>
            <div className="grid grid-cols-2 gap-y-1 gap-x-2">
              <div>Dmg Dealt: <span className="text-yellow-400">{Math.floor(unit.totalDamageDealt)}</span></div>
              <div>Dmg Taken: <span className="text-red-400">{Math.floor(unit.totalDamageReceived)}</span></div>
              {unit.totalHealingDone > 0 && (
                <div>Healing: <span className="text-green-400">{Math.floor(unit.totalHealingDone)}</span></div>
              )}
            </div>
          </div>
        )}
      </div>
    );
  };
  
  // Function to handle dialog close
  const handleClose = (open: boolean) => {
    if (!open) {
      // Reset state when closing dialog
      setUnits([]);
      setActionLog([]);
      setDetailedActionLog([]);
      setCurrentStage(0);
      setCurrentAction(0);
      setIsComplete(false);
      setIsPaused(true);
      setPlaybackSpeed(1);
      
      // Signal to parent component
      onClose();
    }
  };
  
  // Function to handle restart battle
  const restartBattle = () => {
    // Reset state
    setCurrentStage(0);
    setCurrentAction(0);
    setIsPaused(true);
    
    // Clear any pending animation
    if (battleAnimationRef.current) {
      clearTimeout(battleAnimationRef.current);
      battleAnimationRef.current = null;
    }
    
    // Reset battle step counter
    battleStepRef.current = 0;
    
    // Reset action log
    setActionLog(['Battle restarted. Press Play to begin...']);
    
    // Re-extract initial units from battle log
    const initEvent = battleLog.find(event => 
      event.type === 'battle_start' || 
      event.type === 'init'
    );
    
    if (initEvent) {
      // Extract allies and enemies with proper health values
      const allies = (initEvent.allies || []).map(unit => ({
        ...unit,
        isAlly: true,
        hp: unit.hp || unit.maxHp, // Ensure HP is set (fallback to maxHp if hp is 0)
        attackMeter: unit.attackMeter || 0 // Ensure attack meter is set
      }));
      
      const enemies = (initEvent.enemies || []).map(unit => ({
        ...unit,
        isAlly: false,
        hp: unit.hp || unit.maxHp, // Ensure HP is set (fallback to maxHp if hp is 0)
        attackMeter: unit.attackMeter || 0 // Ensure attack meter is set
      }));
      
      console.log("Restarting with units:", [...allies, ...enemies]);
      
      // Set units state
      setUnits([...allies, ...enemies]);
    }
  };
  
  // Function to handle complete dungeon button
  const handleCompleteDungeon = () => {
    if (runId && onCompleteDungeon) {
      onCompleteDungeon(runId);
    }
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center justify-between">
            <span>Dungeon Battle {currentStage > 0 ? `- Stage ${currentStage}` : ''}</span>
            <div className="flex gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={togglePlayback}
                className="h-8 w-8 p-0"
              >
                {isPaused ? <Play size={14} /> : <Pause size={14} />}
              </Button>
              
              <Button
                size="sm"
                variant={playbackSpeed === 1 ? "default" : "outline"}
                onClick={() => handleSpeedChange(1)}
                className="h-8 px-2 text-xs"
              >
                1x
              </Button>
              
              <Button
                size="sm"
                variant={playbackSpeed === 2 ? "default" : "outline"}
                onClick={() => handleSpeedChange(2)}
                className="h-8 px-2 text-xs"
              >
                2x
              </Button>
              
              <Button
                size="sm"
                variant={playbackSpeed === 4 ? "default" : "outline"}
                onClick={() => handleSpeedChange(4)}
                className="h-8 px-2 text-xs"
              >
                4x
              </Button>
              
              <Button
                size="sm"
                variant="outline"
                onClick={() => setActiveTab(activeTab === 'battle' ? 'stats' : 'battle')}
                className="h-8 px-2 text-xs"
              >
                {activeTab === 'battle' ? 'Stats' : 'Battle'}
              </Button>
            </div>
          </DialogTitle>
          <DialogDescription>
            Watch the battle unfold or check detailed statistics
          </DialogDescription>
        </DialogHeader>
        
        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 min-h-0 flex flex-col">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="battle">Battle View</TabsTrigger>
            <TabsTrigger value="log">Battle Log</TabsTrigger>
            <TabsTrigger value="stats">Detailed Stats</TabsTrigger>
          </TabsList>
          
          <TabsContent value="battle" className="flex-1 overflow-hidden flex flex-col">
            <div className="flex-1 min-h-0 bg-[#1D1128] rounded-md p-4 relative">
              {units.length > 0 ? (
                <div className="h-full flex flex-col">
                  {/* Battle Arena */}
                  <div className="flex-1 flex flex-col">
                    {/* Enemies Section */}
                    <div className="mb-6">
                      <h3 className="text-red-400 font-semibold mb-2">Enemies</h3>
                      <div className="grid grid-cols-3 gap-3">
                        {units
                          .filter(unit => unit.id?.toString().includes('enemy') || (!unit.id?.toString().includes('player') && !unit.id?.toString().includes('ally')))
                          .map((enemy, index) => (
                            <div key={`enemy-${index}`} className="bg-[#251942] p-3 rounded-md border border-red-900/30">
                              <div className="text-sm font-medium">{enemy.name}</div>
                              <div className="mt-2 bg-gray-800 h-2 rounded-full w-full overflow-hidden">
                                <div 
                                  className="bg-red-500 h-full rounded-full" 
                                  style={{ width: `${calculateHealthPercent(enemy.hp, enemy.maxHp)}%` }}
                                />
                              </div>
                              <div className="flex justify-between text-xs mt-1">
                                <span>HP: {Math.max(0, enemy.hp)}/{enemy.maxHp}</span>
                                <span>{calculateHealthPercent(enemy.hp, enemy.maxHp).toFixed(0)}%</span>
                              </div>
                              
                              {/* Attack Meter */}
                              <div className="mt-3 bg-gray-800 h-1.5 rounded-full w-full overflow-hidden">
                                <div 
                                  className="bg-yellow-500 h-full rounded-full" 
                                  style={{ width: `${enemy.attackMeter || 0}%` }}
                                />
                              </div>
                              <div className="text-xs text-center mt-1">Attack: {(enemy.attackMeter || 0).toFixed(0)}%</div>
                              
                              {/* Status Effects */}
                              {enemy.statusEffects && enemy.statusEffects.length > 0 && (
                                <div className="flex gap-1 mt-2 flex-wrap">
                                  {enemy.statusEffects.map((effect, i) => 
                                    renderStatusEffect(effect, i, false)
                                  )}
                                </div>
                              )}
                            </div>
                          ))}
                      </div>
                    </div>
                    
                    {/* Center Battle Area */}
                    <div className="my-4 border-t border-b border-[#6A3FB5]/30 py-3 text-center">
                      <div className="text-sm text-[#C8B8DB]">
                        {currentAction > 0 ? 
                          `Round ${Math.ceil(currentAction / (units.length || 1))}` : 
                          'Battle initialized. Press Play to begin...'}
                      </div>
                    </div>
                    
                    {/* Allies Section */}
                    <div className="mt-6">
                      <h3 className="text-green-400 font-semibold mb-2">Your Team</h3>
                      <div className="grid grid-cols-3 gap-3">
                        {units
                          .filter(unit => unit.id?.toString().includes('player') || unit.id?.toString().includes('ally'))
                          .map((ally, index) => (
                            <div key={`ally-${index}`} className="bg-[#251942] p-3 rounded-md border border-green-900/30">
                              <div className="text-sm font-medium">{ally.name}</div>
                              <div className="mt-2 bg-gray-800 h-2 rounded-full w-full overflow-hidden">
                                <div 
                                  className="bg-green-500 h-full rounded-full" 
                                  style={{ width: `${calculateHealthPercent(ally.hp, ally.maxHp)}%` }}
                                />
                              </div>
                              <div className="flex justify-between text-xs mt-1">
                                <span>HP: {Math.max(0, ally.hp)}/{ally.maxHp}</span>
                                <span>{calculateHealthPercent(ally.hp, ally.maxHp).toFixed(0)}%</span>
                              </div>
                              
                              {/* Attack Meter */}
                              <div className="mt-3 bg-gray-800 h-1.5 rounded-full w-full overflow-hidden">
                                <div 
                                  className="bg-blue-500 h-full rounded-full" 
                                  style={{ width: `${ally.attackMeter || 0}%` }}
                                />
                              </div>
                              <div className="text-xs text-center mt-1">Attack: {(ally.attackMeter || 0).toFixed(0)}%</div>
                              
                              {/* Status Effects */}
                              {ally.statusEffects && ally.statusEffects.length > 0 && (
                                <div className="flex gap-1 mt-2 flex-wrap">
                                  {ally.statusEffects.map((effect, i) => 
                                    renderStatusEffect(effect, i, true)
                                  )}
                                </div>
                              )}
                            </div>
                          ))}
                      </div>
                    </div>
                  </div>
                </div>
              ) : (
                <div className="h-full flex flex-col items-center justify-center">
                  <div className="text-center text-gray-400 italic mb-4">
                    No battle data available.
                  </div>
                  <div className="text-center text-sm max-w-md">
                    You can still complete this dungeon to free your characters for other tasks.
                    Click the "Complete Dungeon & Claim Rewards" button below.
                  </div>
                </div>
              )}
            </div>
          </TabsContent>
          
          <TabsContent value="log" className="flex-1 overflow-hidden">
            <ScrollArea className="h-full">
              <div className="p-4 space-y-2">
                {actionLog.map((message, index) => (
                  <div key={index} className="bg-[#251942] p-2 rounded-md text-sm">
                    {message}
                  </div>
                ))}
              </div>
            </ScrollArea>
          </TabsContent>
          
          <TabsContent value="stats" className="flex-1 overflow-hidden">
            <ScrollArea className="h-full">
              <div className="p-4 space-y-4">
                <h3 className="font-semibold text-lg">Battle Statistics</h3>
                
                <div className="grid grid-cols-2 gap-4">
                  {units.map((unit, index) => (
                    <div key={index} className="bg-[#251942] p-3 rounded-md">
                      <div className="font-medium mb-2">{unit.name}</div>
                      {renderUnitStats(unit)}
                    </div>
                  ))}
                </div>
              </div>
            </ScrollArea>
          </TabsContent>
        </Tabs>
        
        <DialogFooter className="flex flex-col gap-2">
          <div className="flex justify-between items-center w-full">
            <Button 
              size="sm" 
              variant="outline" 
              onClick={restartBattle}
              className="h-8 text-sm"
            >
              Restart
            </Button>
            
            <DialogClose asChild>
              <Button 
                variant="outline" 
                size="sm"
                className="h-8"
              >
                Close
              </Button>
            </DialogClose>
          </div>
          
          {runId && onCompleteDungeon && (
            <Button 
              size="lg" 
              onClick={handleCompleteDungeon}
              className="w-full mt-2 bg-[#6A3FB5] hover:bg-[#8352D3]"
            >
              Complete Dungeon & Claim Rewards
            </Button>
          )}
          
          {runId && onCompleteDungeon && (
            <div className="text-xs text-center text-[#C8B8DB] mt-1">
              Completing this dungeon will free your characters for other tasks
            </div>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default BattleLog;


=== client/src/components/townhall/TownhallView.tsx ===
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { 
  Building2, 
  ArrowUp, 
  CheckCircle, 
  Shield,
  Loader2,
  Plus
} from 'lucide-react';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger,
  DialogFooter,
  DialogDescription
} from '@/components/ui/dialog';
import CountdownTimer from '../common/CountdownTimer';
import { Separator } from '@/components/ui/separator';

import type { BuildingUpgrade } from '@shared/schema';

// Townhall building definition
const townhall = {
  id: 'townhall',
  name: 'Townhall',
  description: 'The central building that determines the maximum level of other buildings and unlocks additional farming and dungeon slots.',
  icon: <Building2 className="h-6 w-6" />,
  color: 'text-[#FF9D00] bg-[#FF9D00]/10',
  benefits: [
    { level: 1, text: 'Unlocks basic buildings and 3 farming slots' },
    { level: 2, text: 'Unlocks 4th farming slot' },
    { level: 3, text: 'Unlocks 5th farming slot and increase active character tasks' },
    { level: 4, text: 'Unlocks 6th farming slot' },
    { level: 5, text: 'Unlocks Guild access and all farming slots' },
    { level: 10, text: 'Allows other buildings to reach level 19' },
    { level: 20, text: 'Allows other buildings to reach level 29' },
    { level: 30, text: 'Allows other buildings to reach level 39' },
    { level: 40, text: 'Allows other buildings to reach level 49' }
  ],
  maxLevel: 9,
  baseUpgradeCost: { rogueCredits: 1000, forgeTokens: 100 },
  upgradeTimeInMinutes: 60
};

const TownhallView = () => {
  const { user, fetchUser } = useDiscordAuth();
  const { toast } = useToast();
  const [upgradeDialog, setUpgradeDialog] = useState<boolean>(false);
  const [skillTreeDialog, setSkillTreeDialog] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [selectedSkill, setSelectedSkill] = useState<string | null>(null);
  
  // Fetch building upgrades
  const { data: buildingUpgrades = [], isLoading, refetch: refetchBuildings } = useQuery<BuildingUpgrade[]>({
    queryKey: ['/api/buildings'],
    refetchInterval: 60000 // Refresh every minute
  });

  // Get building upgrade data
  const getBuildingData = () => {
    const found = buildingUpgrades.find(upgrade => upgrade.buildingType === 'townhall');
    if (found) {
      return found;
    }
    
    // If no building data found, create a new building instance
    return {
      id: 0,
      userId: 1,
      buildingType: 'townhall',
      currentLevel: 1,
      upgradeStartTime: null,
      upgradeEndTime: null,
      upgradeInProgress: false,
      unlockedSkills: [],
      availableSkillPoints: 1,
      skillDistribution: {}
    } as unknown as BuildingUpgrade;
  };

  const buildingData = getBuildingData();
  const currentLevel = buildingData?.currentLevel || 1;
  const isBeingUpgraded = buildingData?.upgradeInProgress || false;

  // Calculate upgrade cost based on current level
  const calculateUpgradeCost = (currentLevel: number) => {
    const levelMultiplier = currentLevel;
    return {
      rogueCredits: townhall.baseUpgradeCost.rogueCredits * levelMultiplier,
      forgeTokens: townhall.baseUpgradeCost.forgeTokens * levelMultiplier
    };
  };

  // Check if user can afford upgrade
  const canAffordUpgrade = (currentLevel: number) => {
    if (!user) return false;
    
    const cost = calculateUpgradeCost(currentLevel);
    const userCredits = user.rogueCredits || 0;
    const userTokens = user.forgeTokens || 0;
    
    return userCredits >= cost.rogueCredits && userTokens >= cost.forgeTokens;
  };

  // Check if building is at max level
  const isMaxLevel = (currentLevel: number) => {
    // Fixed max level of 9 for Townhall
    const maxAllowedLevel = 9;
    return currentLevel >= maxAllowedLevel;
  };

  // Calculate upgrade progress
  const calculateUpgradeProgress = (building: BuildingUpgrade) => {
    if (!building.upgradeStartTime || !building.upgradeEndTime) return 0;
    
    const startTime = new Date(building.upgradeStartTime).getTime();
    const endTime = new Date(building.upgradeEndTime).getTime();
    const now = new Date().getTime();
    
    return Math.min(100, Math.max(0, ((now - startTime) / (endTime - startTime)) * 100));
  };

  // Define the SkillTreeData type
  type SkillTreeData = {
    currentLevel: number;
    unlockedSkills: string[];
    availableSkillTree: Array<{
      id: string;
      name: string;
      description: string;
      maxLevel: number;
      path?: string;
      requires?: Record<string, number>;
    }>;
  };

  // Fetch building skill tree data with proper typing
  const { data: skillTreeData = { 
    currentLevel: 1, 
    unlockedSkills: [], 
    availableSkillTree: [] 
  } as SkillTreeData } = useQuery<SkillTreeData>({
    queryKey: [`/api/buildings/skills/townhall`],
    enabled: skillTreeDialog
  });

  // Allocate skill point
  const allocateSkill = async (skillId: string) => {
    setIsSubmitting(true);
    
    try {
      const response = await apiRequest('POST', `/api/buildings/skills/townhall`, {
        skillId: skillId
      });
      
      const data = await response.json();
      
      toast({
        title: "Skill Allocated",
        description: `You've allocated a skill point for Townhall.`,
      });
      
      setSelectedSkill(skillId);
      setSkillTreeDialog(false);
      
      // Continue with upgrade after skill allocation
      startUpgrade(skillId);
    } catch (error: any) {
      console.error('Error allocating skill:', error);
      toast({
        title: "Failed to Allocate Skill",
        description: error.message || "There was an error allocating the skill point.",
        variant: "destructive"
      });
      setIsSubmitting(false);
    }
  };

  // Start building upgrade
  const startUpgrade = async (allocatedSkill?: string) => {
    // Make sure we're using the correct building type
    const buildingType = 'townhall';
    
    if (isMaxLevel(currentLevel)) {
      toast({
        title: "Max Level Reached",
        description: `Townhall is already at maximum level.`,
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    if (isBeingUpgraded) {
      toast({
        title: "Already Upgrading",
        description: `Townhall is already being upgraded.`,
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    if (!canAffordUpgrade(currentLevel)) {
      toast({
        title: "Insufficient Resources",
        description: "You don't have enough resources for this upgrade.",
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    try {
      console.log("Starting upgrade for Townhall");
      
      // If user has selected a skill to allocate, include it in the upgrade request
      const requestData: any = {
        buildingType: buildingType,
      };
      
      if (allocatedSkill) {
        requestData.allocatedSkill = allocatedSkill;
      }
      
      // Use apiRequest instead of fetch for better error handling
      const response = await apiRequest('POST', '/api/buildings/upgrade', requestData);
      
      // apiRequest already returns the parsed JSON data
      const data = response;
      console.log("Upgrade response:", data);
      
      toast({
        title: "Upgrade Started",
        description: `Townhall is now being upgraded to level ${currentLevel + 1}.`,
      });
      
      // Reset selections and close dialog
      setUpgradeDialog(false);
      setSelectedSkill(null);
      
      // Refresh buildings and user data
      refetchBuildings();
      fetchUser();
    } catch (error: any) {
      console.error('Error starting upgrade:', error);
      toast({
        title: "Upgrade Failed",
        description: error.message || "There was an error starting the upgrade.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Complete building upgrade
  const completeUpgrade = async () => {
    setIsSubmitting(true);
    
    try {
      // Call API to complete upgrade
      await apiRequest('POST', `/api/buildings/complete/townhall`, {});
      
      toast({
        title: "Upgrade Complete!",
        description: `Townhall has been upgraded successfully.`,
      });
      
      // Refresh buildings and user data
      refetchBuildings();
      fetchUser();
    } catch (error) {
      console.error('Error completing upgrade:', error);
      toast({
        title: "Error",
        description: "Failed to complete the upgrade.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Check if there are any available skill points
  const hasAvailableSkillPoints = () => {
    if (!buildingData) {
      return false;
    }
    
    // Calculate available skill points based on building level and already allocated skills
    const totalSkillPoints = Math.max(0, buildingData.currentLevel - 1);
    const allocatedPoints = (buildingData.unlockedSkills?.length || 0);
    
    return totalSkillPoints > allocatedPoints;
  };

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#FF9D00] text-xl animate-pulse">Loading Townhall data...</div>
      </div>
    );
  }

  return (
    <>
      {/* Page Title */}
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#FF9D00] mb-2">Townhall</h1>
        <p className="text-[#C8B8DB]/80">
          The central building that manages your town and determines the maximum level of other buildings.
        </p>
      </div>
      
      {/* Skill Tree Dialog */}
      <Dialog open={skillTreeDialog} onOpenChange={(open) => {
        setSkillTreeDialog(open);
        if (!open) setSelectedSkill(null);
      }}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-2xl overflow-y-auto max-h-[80vh]">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">
              Townhall Skill Tree
            </DialogTitle>
            <DialogDescription>
              Allocate skill points to enhance your Townhall's capabilities. You gain skill points each time you level up your building.
            </DialogDescription>
          </DialogHeader>
          
          {skillTreeData ? (
            <div className="py-4">
              <div className="mb-6 bg-[#432874]/20 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="font-semibold">Available Skill Points:</span>
                  <Badge className="bg-[#FF9D00] text-[#1A1A2E]">
                    {skillTreeData.currentLevel - (skillTreeData.unlockedSkills?.length || 0)}
                  </Badge>
                </div>
              </div>
              
              <div className="grid gap-4">
                {skillTreeData.availableSkillTree?.map((skill: any) => {
                  const isUnlocked = skillTreeData.unlockedSkills?.includes(skill.id);
                  
                  return (
                    <div 
                      key={skill.id}
                      className={`border p-4 rounded-lg ${isUnlocked ? 'border-[#00B9AE] bg-[#00B9AE]/10' : 'border-[#432874]/30 bg-[#432874]/5'}`}
                    >
                      <div className="flex justify-between items-start">
                        <div>
                          <h3 className={`font-semibold ${isUnlocked ? 'text-[#00B9AE]' : 'text-[#FF9D00]'}`}>{skill.name}</h3>
                          <p className="text-sm mt-1">{skill.description}</p>
                        </div>
                        {isUnlocked ? (
                          <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] border-[#00B9AE]/50">
                            <CheckCircle className="h-4 w-4 mr-1" /> Unlocked
                          </Badge>
                        ) : (
                          <Button
                            size="sm"
                            className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                            onClick={() => allocateSkill(skill.id)}
                            disabled={!hasAvailableSkillPoints() || isSubmitting}
                          >
                            {isSubmitting ? (
                              <><Loader2 className="h-4 w-4 mr-1 animate-spin" /> Allocating...</>
                            ) : (
                              <><Plus className="h-4 w-4 mr-1" /> Allocate Point</>
                            )}
                          </Button>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="py-8 text-center">
              <div className="text-[#FF9D00] animate-pulse">Loading skill tree data...</div>
            </div>
          )}
          
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setSkillTreeDialog(false)}
              className="border-[#432874] text-[#C8B8DB]"
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Upgrade Dialog */}
      <Dialog open={upgradeDialog} onOpenChange={setUpgradeDialog}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
          <DialogHeader>
            <DialogTitle className="text-[#FF9D00] font-cinzel text-xl">Upgrade Townhall</DialogTitle>
            <DialogDescription>
              Are you sure you want to upgrade your Townhall to level {currentLevel + 1}?
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <div className="bg-[#432874]/20 p-4 rounded-lg mb-4">
              <div className="flex justify-between items-center mb-2">
                <span>Current Level:</span>
                <Badge variant="outline" className="border-[#FF9D00] text-[#FF9D00]">{currentLevel}</Badge>
              </div>
              
              <div className="flex justify-between items-center mb-2">
                <span>New Level:</span>
                <Badge className="bg-[#FF9D00] text-[#1A1A2E]">{currentLevel + 1}</Badge>
              </div>
              
              <Separator className="my-3 bg-[#432874]/50" />
              
              <div className="flex justify-between items-center mb-2">
                <span>Cost:</span>
                <div className="flex gap-2">
                  <span className="text-[#C8B8DB]">{calculateUpgradeCost(currentLevel).rogueCredits} Credits</span>
                  <span className="text-[#C8B8DB]">{calculateUpgradeCost(currentLevel).forgeTokens} Tokens</span>
                </div>
              </div>
              
              <div className="flex justify-between items-center">
                <span>Time:</span>
                <span className="text-[#C8B8DB]">{townhall.upgradeTimeInMinutes} minutes</span>
              </div>
            </div>
            
            <div className="bg-[#432874]/20 p-4 rounded-lg">
              <h3 className="font-semibold text-[#FF9D00] mb-2">Unlocks at Level {currentLevel + 1}:</h3>
              <ul className="list-disc pl-5 space-y-1">
                {townhall.benefits
                  .filter(benefit => benefit.level === currentLevel + 1)
                  .map((benefit, index) => (
                    <li key={index} className="text-sm text-[#C8B8DB]">{benefit.text}</li>
                  ))}
                {!townhall.benefits.some(benefit => benefit.level === currentLevel + 1) && (
                  <li className="text-sm text-[#C8B8DB]">General town management improvements</li>
                )}
              </ul>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setUpgradeDialog(false)}
              className="border-[#432874] text-[#C8B8DB]"
            >
              Cancel
            </Button>
            <Button 
              className="bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
              onClick={() => {
                // Check if user has skill points to allocate
                if (hasAvailableSkillPoints()) {
                  setUpgradeDialog(false);
                  setSkillTreeDialog(true);
                } else {
                  startUpgrade();
                }
              }}
              disabled={isSubmitting || !canAffordUpgrade(currentLevel)}
            >
              {isSubmitting ? (
                <><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Upgrading...</>
              ) : (
                <><ArrowUp className="h-4 w-4 mr-2" /> Start Upgrade</>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* Main Content */}
      <motion.div
        variants={container}
        initial="hidden"
        animate="show"
        className="grid gap-6 md:grid-cols-2"
      >
        {/* Townhall Card */}
        <motion.div
          variants={item}
          className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden col-span-2"
        >
          <CardHeader className={`pb-2 ${townhall.color}`}>
            <div className="flex justify-between items-start">
              <div className="flex items-center">
                {townhall.icon}
                <CardTitle className="ml-2 font-cinzel">{townhall.name}</CardTitle>
              </div>
              <Badge variant="outline" className="border-[#FF9D00] text-[#FF9D00]">
                Level {currentLevel}
              </Badge>
            </div>
            <CardDescription className="mt-2">{townhall.description}</CardDescription>
          </CardHeader>
          
          <CardContent className="pt-4">
            {isBeingUpgraded ? (
              <div className="mb-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-[#C8B8DB]/80">Upgrading to Level {currentLevel + 1}</span>
                  <span className="text-[#FF9D00]">{Math.round(calculateUpgradeProgress(buildingData))}%</span>
                </div>
                <Progress value={calculateUpgradeProgress(buildingData)} className="h-2 bg-[#432874]/30" />
                <div className="mt-2 flex justify-between items-center">
                  <span className="text-xs text-[#C8B8DB]/60">Time remaining:</span>
                  <CountdownTimer 
                    endTime={new Date(buildingData.upgradeEndTime || Date.now()).getTime()} 
                    onComplete={() => {
                      refetchBuildings();
                      fetchUser();
                    }}
                  />
                </div>
              </div>
            ) : (
              <>
                <h3 className="font-semibold text-[#FF9D00] mb-2">Benefits:</h3>
                <ul className="list-disc pl-5 space-y-1 mb-4">
                  {townhall.benefits
                    .filter(benefit => benefit.level <= currentLevel)
                    .map((benefit, index) => (
                      <li key={index} className="text-sm text-[#C8B8DB]">
                        <span className="text-[#00B9AE]">Level {benefit.level}:</span> {benefit.text}
                      </li>
                    ))}
                </ul>
                
                <h3 className="font-semibold text-[#FF9D00] mb-2">Next Upgrade:</h3>
                {!isMaxLevel(currentLevel) ? (
                  <>
                    <ul className="list-disc pl-5 space-y-1 mb-4">
                      {townhall.benefits
                        .filter(benefit => benefit.level === currentLevel + 1)
                        .map((benefit, index) => (
                          <li key={index} className="text-sm text-[#C8B8DB]">{benefit.text}</li>
                        ))}
                      {!townhall.benefits.some(benefit => benefit.level === currentLevel + 1) && (
                        <li className="text-sm text-[#C8B8DB]">General town management improvements</li>
                      )}
                    </ul>
                    
                    <div className="flex flex-wrap gap-2 bg-[#432874]/10 p-3 rounded-lg">
                      <div className="flex items-center">
                        <span className="text-sm text-[#C8B8DB]/80 mr-2">Cost:</span>
                        <Badge variant="outline" className="border-[#FF9D00]/30 bg-[#FF9D00]/5 text-[#FF9D00]">
                          {calculateUpgradeCost(currentLevel).rogueCredits} Credits
                        </Badge>
                      </div>
                      <div className="flex items-center">
                        <span className="text-sm text-[#C8B8DB]/80 mr-2">and</span>
                        <Badge variant="outline" className="border-[#FF9D00]/30 bg-[#FF9D00]/5 text-[#FF9D00]">
                          {calculateUpgradeCost(currentLevel).forgeTokens} Tokens
                        </Badge>
                      </div>
                      <div className="flex items-center ml-auto">
                        <span className="text-sm text-[#C8B8DB]/80 mr-2">Time:</span>
                        <Badge variant="outline" className="border-[#C8B8DB]/30 bg-[#C8B8DB]/5 text-[#C8B8DB]">
                          {townhall.upgradeTimeInMinutes} minutes
                        </Badge>
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="bg-[#432874]/10 p-3 rounded-lg text-center text-[#C8B8DB]">
                    Maximum level reached
                  </div>
                )}
              </>
            )}
          </CardContent>
          
          <CardFooter className="pt-0 gap-2">
            {isBeingUpgraded ? (
              <Button 
                className="flex-1 bg-[#00B9AE] hover:bg-[#00B9AE]/80 text-[#1A1A2E]"
                onClick={completeUpgrade}
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Completing...</>
                ) : (
                  <><CheckCircle className="h-4 w-4 mr-2" /> Complete Now</>
                )}
              </Button>
            ) : (
              <>
                <Button 
                  className="flex-1 bg-[#FF9D00] hover:bg-[#FF9D00]/80 text-[#1A1A2E]"
                  onClick={() => setUpgradeDialog(true)}
                  disabled={isMaxLevel(currentLevel)}
                >
                  <ArrowUp className="h-4 w-4 mr-2" /> Upgrade
                </Button>
                <Button 
                  variant="outline" 
                  className="border-[#432874] text-[#C8B8DB]"
                  onClick={() => setSkillTreeDialog(true)}
                >
                  <Shield className="h-4 w-4 mr-2" /> Skill Tree
                </Button>
              </>
            )}
          </CardFooter>
        </motion.div>
        
        {/* Stats and Town Info */}
        <motion.div
          variants={item}
          className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden"
        >
          <CardHeader className="pb-2">
            <CardTitle className="font-cinzel text-[#FF9D00]">Town Statistics</CardTitle>
            <CardDescription>Key metrics about your town's development</CardDescription>
          </CardHeader>
          
          <CardContent className="pt-4">
            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-[#C8B8DB]/80">Total Buildings:</span>
                <span className="font-medium text-[#C8B8DB]">6</span>
              </div>
              <div className="flex justify-between">
                <span className="text-[#C8B8DB]/80">Farming Slots:</span>
                <span className="font-medium text-[#C8B8DB]">{Math.min(currentLevel + 2, 7)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-[#C8B8DB]/80">Dungeon Slots:</span>
                <span className="font-medium text-[#C8B8DB]">{Math.min(currentLevel + 1, 5)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-[#C8B8DB]/80">Max Building Level:</span>
                <span className="font-medium text-[#C8B8DB]">{Math.min(currentLevel + 8, 50)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-[#C8B8DB]/80">Guild Access:</span>
                <span className="font-medium text-[#C8B8DB]">{currentLevel >= 5 ? 'Unlocked' : 'Locked'}</span>
              </div>
            </div>
          </CardContent>
        </motion.div>
        
        {/* Building Management */}
        <motion.div
          variants={item}
          className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden"
        >
          <CardHeader className="pb-2">
            <CardTitle className="font-cinzel text-[#FF9D00]">Building Management</CardTitle>
            <CardDescription>Manage your town's buildings and resources</CardDescription>
          </CardHeader>
          
          <CardContent className="pt-4">
            <div className="space-y-4">
              <div className="bg-[#432874]/10 p-3 rounded-lg">
                <h3 className="font-semibold text-[#FF9D00] mb-2">Building Limits</h3>
                <p className="text-sm text-[#C8B8DB]">
                  Your Townhall (Level {currentLevel}) allows other buildings to reach a maximum of level {Math.min(currentLevel + 8, 50)}.
                </p>
              </div>
              
              <div className="bg-[#432874]/10 p-3 rounded-lg">
                <h3 className="font-semibold text-[#FF9D00] mb-2">Resource Production</h3>
                <p className="text-sm text-[#C8B8DB]">
                  Each Townhall level increases passive resource generation by 5%.
                </p>
                <div className="mt-2 flex justify-between">
                  <span className="text-xs text-[#C8B8DB]/80">Current Bonus:</span>
                  <span className="text-xs font-medium text-[#00B9AE]">+{(currentLevel - 1) * 5}%</span>
                </div>
              </div>
            </div>
          </CardContent>
          
          <CardFooter className="pt-0">
            <Button 
              variant="outline" 
              className="w-full border-[#432874] text-[#C8B8DB]"
              onClick={() => window.location.href = '/buildings'}
            >
              View All Buildings
            </Button>
          </CardFooter>
        </motion.div>
      </motion.div>
    </>
  );
};

export default TownhallView;

=== client/src/components/tavern/TavernView.tsx ===
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { useQuery } from '@tanstack/react-query';
import { useGameStore } from '@/lib/zustandStore';
import { useDiscordAuth } from '@/lib/discordAuth';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { 
  User, 
  ArrowUp, 
  CheckCircle, 
  Shield,
  Loader2,
  Plus,
  Ticket,
  RefreshCcw,
  Users
} from 'lucide-react';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle,
  DialogFooter,
  DialogDescription
} from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import CountdownTimer from '../common/CountdownTimer';
import { Separator } from '@/components/ui/separator';

import type { BuildingUpgrade } from '@shared/schema';

// Tavern building definition
const tavern = {
  id: 'tavern',
  name: 'Tavern',
  description: 'Specialized trading post that offers character trades and generates energy/tickets for dungeons.',
  icon: <User className="h-6 w-6" />,
  color: 'text-[#4169E1] bg-[#4169E1]/10',
  benefits: [
    { level: 1, text: 'Basic trade options (3 common for 1 rare)' },
    { level: 2, text: 'Improved trade options (3 rare for 1 epic)' },
    { level: 3, text: 'Generate 2 dungeon tickets per day' },
    { level: 4, text: 'Generate 4 dungeon tickets per day' },
    { level: 5, text: 'Elite trade options (3 epic for 1 legendary)' }
  ],
  maxLevel: 9,
  baseUpgradeCost: { rogueCredits: 700, forgeTokens: 70 },
  upgradeTimeInMinutes: 35
};

const TavernView = () => {
  const { user, fetchUser } = useDiscordAuth();
  const { toast } = useToast();
  const [upgradeDialog, setUpgradeDialog] = useState<boolean>(false);
  const [skillTreeDialog, setSkillTreeDialog] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [selectedSkill, setSelectedSkill] = useState<string | null>(null);
  
  // Fetch building upgrades
  const { data: buildingUpgrades = [], isLoading, refetch: refetchBuildings } = useQuery<BuildingUpgrade[]>({
    queryKey: ['/api/buildings'],
    refetchInterval: 60000 // Refresh every minute
  });

  // Get building upgrade data
  const getBuildingData = () => {
    const found = buildingUpgrades.find(upgrade => upgrade.buildingType === 'tavern');
    if (found) {
      return found;
    }
    
    // If no building data found, create a new building instance
    return {
      id: 0,
      userId: 1,
      buildingType: 'tavern',
      currentLevel: 1,
      upgradeStartTime: null,
      upgradeEndTime: null,
      upgradeInProgress: false,
      unlockedSkills: [],
      availableSkillPoints: 1,
      skillDistribution: {}
    } as unknown as BuildingUpgrade;
  };

  const buildingData = getBuildingData();
  const currentLevel = buildingData?.currentLevel || 1;
  const isBeingUpgraded = buildingData?.upgradeInProgress || false;

  // Calculate upgrade cost based on current level
  const calculateUpgradeCost = (currentLevel: number) => {
    const levelMultiplier = currentLevel;
    return {
      rogueCredits: tavern.baseUpgradeCost.rogueCredits * levelMultiplier,
      forgeTokens: tavern.baseUpgradeCost.forgeTokens * levelMultiplier
    };
  };

  // Check if user can afford upgrade
  const canAffordUpgrade = (currentLevel: number) => {
    if (!user) return false;
    
    const cost = calculateUpgradeCost(currentLevel);
    const userCredits = user.rogueCredits || 0;
    const userTokens = user.forgeTokens || 0;
    
    return userCredits >= cost.rogueCredits && userTokens >= cost.forgeTokens;
  };

  // Check if building is at max level
  const isMaxLevel = (currentLevel: number) => {
    // Get townhall level
    const townhall = buildingUpgrades.find(upgrade => upgrade.buildingType === 'townhall');
    const townhallLevel = townhall?.currentLevel || 1;
    
    // Fixed max level of 9 for Tavern
    const maxAllowedLevel = 9;
    
    return currentLevel >= maxAllowedLevel;
  };

  // Calculate upgrade progress
  const calculateUpgradeProgress = (building: BuildingUpgrade) => {
    if (!building.upgradeStartTime || !building.upgradeEndTime) return 0;
    
    const startTime = new Date(building.upgradeStartTime).getTime();
    const endTime = new Date(building.upgradeEndTime).getTime();
    const now = new Date().getTime();
    
    return Math.min(100, Math.max(0, ((now - startTime) / (endTime - startTime)) * 100));
  };

  // Define the SkillTreeData type
  type SkillTreeData = {
    currentLevel: number;
    unlockedSkills: string[];
    availableSkillTree: Array<{
      id: string;
      name: string;
      description: string;
      maxLevel: number;
      path?: string;
      requires?: Record<string, number>;
    }>;
  };

  // Fetch building skill tree data with proper typing
  const { data: skillTreeData = { 
    currentLevel: 1, 
    unlockedSkills: [], 
    availableSkillTree: [] 
  } as SkillTreeData } = useQuery<SkillTreeData>({
    queryKey: [`/api/buildings/skills/tavern`],
    enabled: skillTreeDialog
  });

  // Allocate skill point
  const allocateSkill = async (skillId: string) => {
    setIsSubmitting(true);
    
    try {
      const response = await apiRequest('POST', `/api/buildings/skills/tavern`, {
        skillId: skillId
      });
      
      const data = await response.json();
      
      toast({
        title: "Skill Allocated",
        description: `You've allocated a skill point for Tavern.`,
      });
      
      setSelectedSkill(skillId);
      setSkillTreeDialog(false);
      
      // Continue with upgrade after skill allocation
      startUpgrade(skillId);
    } catch (error: any) {
      console.error('Error allocating skill:', error);
      toast({
        title: "Failed to Allocate Skill",
        description: error.message || "There was an error allocating the skill point.",
        variant: "destructive"
      });
      setIsSubmitting(false);
    }
  };

  // Start building upgrade
  const startUpgrade = async (allocatedSkill?: string) => {
    // Make sure we're using the correct building type
    const buildingType = 'tavern';
    
    if (isMaxLevel(currentLevel)) {
      toast({
        title: "Max Level Reached",
        description: `Tavern is already at maximum level.`,
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    if (isBeingUpgraded) {
      toast({
        title: "Already Upgrading",
        description: `Tavern is already being upgraded.`,
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    if (!canAffordUpgrade(currentLevel)) {
      toast({
        title: "Insufficient Resources",
        description: "You don't have enough resources for this upgrade.",
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    
    try {
      console.log("Starting upgrade for Tavern");
      
      // If user has selected a skill to allocate, include it in the upgrade request
      const requestData: any = {
        buildingType: buildingType,
      };
      
      if (allocatedSkill) {
        requestData.allocatedSkill = allocatedSkill;
      }
      
      // Use apiRequest instead of fetch for better error handling
      const response = await apiRequest('POST', '/api/buildings/upgrade', requestData);
      
      // apiRequest already returns the parsed JSON data
      const data = response;
      console.log("Upgrade response:", data);
      
      toast({
        title: "Upgrade Started",
        description: `Tavern is now being upgraded to level ${currentLevel + 1}.`,
      });
      
      // Reset selections and close dialog
      setUpgradeDialog(false);
      setSelectedSkill(null);
      
      // Refresh buildings and user data
      refetchBuildings();
      fetchUser();
    } catch (error: any) {
      console.error('Error starting upgrade:', error);
      toast({
        title: "Upgrade Failed",
        description: error.message || "There was an error starting the upgrade.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Complete building upgrade
  const completeUpgrade = async () => {
    setIsSubmitting(true);
    
    try {
      // Call API to complete upgrade
      await apiRequest('POST', `/api/buildings/complete/tavern`, {});
      
      toast({
        title: "Upgrade Complete!",
        description: `Tavern has been upgraded successfully.`,
      });
      
      // Refresh buildings and user data
      refetchBuildings();
      fetchUser();
    } catch (error) {
      console.error('Error completing upgrade:', error);
      toast({
        title: "Error",
        description: "Failed to complete the upgrade.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Check if there are any available skill points
  const hasAvailableSkillPoints = () => {
    if (!buildingData) {
      return false;
    }
    
    // Calculate available skill points based on building level and already allocated skills
    const totalSkillPoints = Math.max(0, buildingData.currentLevel - 1);
    const allocatedPoints = (buildingData.unlockedSkills?.length || 0);
    
    return totalSkillPoints > allocatedPoints;
  };

  // Mock data for characters available for trading
  const tradeableCharacters = [
    {
      name: 'Novice Warrior',
      level: 12,
      rarity: 'common',
      image: 'https://placehold.co/80',
      cost: 3,
      target: 'Sentinel Guardian',
      targetRarity: 'rare'
    },
    {
      name: 'Acolyte Mage',
      level: 15,
      rarity: 'common',
      image: 'https://placehold.co/80',
      cost: 3,
      target: 'Arcane Master',
      targetRarity: 'rare'
    },
    {
      name: 'Scout',
      level: 14,
      rarity: 'common',
      image: 'https://placehold.co/80',
      cost: 3,
      target: 'Shadow Hunter',
      targetRarity: 'rare'
    }
  ];

  // Mock data for rare trades (level 2+)
  const rareTradeableCharacters = [
    {
      name: 'Sentinel Guardian',
      level: 25,
      rarity: 'rare',
      image: 'https://placehold.co/80',
      cost: 3,
      target: 'Eternal Defender',
      targetRarity: 'epic'
    },
    {
      name: 'Arcane Master',
      level: 28,
      rarity: 'rare',
      image: 'https://placehold.co/80',
      cost: 3,
      target: 'Dimensional Mage',
      targetRarity: 'epic'
    }
  ];

  // Mock data for epic trades (level 5+)
  const epicTradeableCharacters = [
    {
      name: 'Eternal Defender',
      level: 40,
      rarity: 'epic',
      image: 'https://placehold.co/80',
      cost: 3,
      target: 'Celestial Protector',
      targetRarity: 'legendary'
    }
  ];

  // Animation variants
  const container = {
    hidden: { opacity: 0 },
    show: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };

  const item = {
    hidden: { opacity: 0, y: 20 },
    show: { opacity: 1, y: 0 }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-[#4169E1] text-xl animate-pulse">Loading Tavern data...</div>
      </div>
    );
  }

  // Get available dungeon tickets per day based on level
  const getDungeonTicketsPerDay = () => {
    if (currentLevel < 3) return 0;
    if (currentLevel < 4) return 2;
    return 4;
  };

  return (
    <>
      {/* Page Title */}
      <div className="mb-6">
        <h1 className="text-3xl font-cinzel font-bold text-[#4169E1] mb-2">Tavern</h1>
        <p className="text-[#C8B8DB]/80">
          A place to trade characters and earn dungeon tickets to advance your journey.
        </p>
      </div>
      
      {/* Skill Tree Dialog */}
      <Dialog open={skillTreeDialog} onOpenChange={(open) => {
        setSkillTreeDialog(open);
        if (!open) setSelectedSkill(null);
      }}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB] max-w-2xl overflow-y-auto max-h-[80vh]">
          <DialogHeader>
            <DialogTitle className="text-[#4169E1] font-cinzel text-xl">
              Tavern Skill Tree
            </DialogTitle>
            <DialogDescription>
              Allocate skill points to enhance your Tavern's capabilities. You gain skill points each time you level up your building.
            </DialogDescription>
          </DialogHeader>
          
          {skillTreeData ? (
            <div className="py-4">
              <div className="mb-6 bg-[#432874]/20 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="font-semibold">Available Skill Points:</span>
                  <Badge className="bg-[#4169E1] text-[#1A1A2E]">
                    {skillTreeData.currentLevel - (skillTreeData.unlockedSkills?.length || 0)}
                  </Badge>
                </div>
              </div>
              
              <div className="grid gap-4">
                {skillTreeData.availableSkillTree?.map((skill: any) => {
                  const isUnlocked = skillTreeData.unlockedSkills?.includes(skill.id);
                  
                  return (
                    <div 
                      key={skill.id}
                      className={`border p-4 rounded-lg ${isUnlocked ? 'border-[#00B9AE] bg-[#00B9AE]/10' : 'border-[#432874]/30 bg-[#432874]/5'}`}
                    >
                      <div className="flex justify-between items-start">
                        <div>
                          <h3 className={`font-semibold ${isUnlocked ? 'text-[#00B9AE]' : 'text-[#4169E1]'}`}>{skill.name}</h3>
                          <p className="text-sm mt-1">{skill.description}</p>
                        </div>
                        {isUnlocked ? (
                          <Badge className="bg-[#00B9AE]/20 text-[#00B9AE] border-[#00B9AE]/50">
                            <CheckCircle className="h-4 w-4 mr-1" /> Unlocked
                          </Badge>
                        ) : (
                          <Button
                            size="sm"
                            className="bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
                            onClick={() => allocateSkill(skill.id)}
                            disabled={!hasAvailableSkillPoints() || isSubmitting}
                          >
                            {isSubmitting ? (
                              <><Loader2 className="h-4 w-4 mr-1 animate-spin" /> Allocating...</>
                            ) : (
                              <><Plus className="h-4 w-4 mr-1" /> Allocate Point</>
                            )}
                          </Button>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="py-8 text-center">
              <div className="text-[#4169E1] animate-pulse">Loading skill tree data...</div>
            </div>
          )}
          
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setSkillTreeDialog(false)}
              className="border-[#432874] text-[#C8B8DB]"
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Upgrade Dialog */}
      <Dialog open={upgradeDialog} onOpenChange={setUpgradeDialog}>
        <DialogContent className="bg-[#1A1A2E] border border-[#432874] text-[#C8B8DB]">
          <DialogHeader>
            <DialogTitle className="text-[#4169E1] font-cinzel text-xl">Upgrade Tavern</DialogTitle>
            <DialogDescription>
              Are you sure you want to upgrade your Tavern to level {currentLevel + 1}?
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <div className="bg-[#432874]/20 p-4 rounded-lg mb-4">
              <div className="flex justify-between items-center mb-2">
                <span>Current Level:</span>
                <Badge variant="outline" className="border-[#4169E1] text-[#4169E1]">{currentLevel}</Badge>
              </div>
              
              <div className="flex justify-between items-center mb-2">
                <span>New Level:</span>
                <Badge className="bg-[#4169E1] text-[#1A1A2E]">{currentLevel + 1}</Badge>
              </div>
              
              <Separator className="my-3 bg-[#432874]/50" />
              
              <div className="flex justify-between items-center mb-2">
                <span>Cost:</span>
                <div className="flex gap-2">
                  <span className="text-[#C8B8DB]">{calculateUpgradeCost(currentLevel).rogueCredits} Credits</span>
                  <span className="text-[#C8B8DB]">{calculateUpgradeCost(currentLevel).forgeTokens} Tokens</span>
                </div>
              </div>
              
              <div className="flex justify-between items-center">
                <span>Time:</span>
                <span className="text-[#C8B8DB]">{tavern.upgradeTimeInMinutes} minutes</span>
              </div>
            </div>
            
            <div className="bg-[#432874]/20 p-4 rounded-lg">
              <h3 className="font-semibold text-[#4169E1] mb-2">Unlocks at Level {currentLevel + 1}:</h3>
              <ul className="list-disc pl-5 space-y-1">
                {tavern.benefits
                  .filter(benefit => benefit.level === currentLevel + 1)
                  .map((benefit, index) => (
                    <li key={index} className="text-sm text-[#C8B8DB]">{benefit.text}</li>
                  ))}
                {!tavern.benefits.some(benefit => benefit.level === currentLevel + 1) && (
                  <li className="text-sm text-[#C8B8DB]">General tavern improvements</li>
                )}
              </ul>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setUpgradeDialog(false)}
              className="border-[#432874] text-[#C8B8DB]"
            >
              Cancel
            </Button>
            <Button 
              className="bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
              onClick={() => {
                // Check if user has skill points to allocate
                if (hasAvailableSkillPoints()) {
                  setUpgradeDialog(false);
                  setSkillTreeDialog(true);
                } else {
                  startUpgrade();
                }
              }}
              disabled={isSubmitting || !canAffordUpgrade(currentLevel)}
            >
              {isSubmitting ? (
                <><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Upgrading...</>
              ) : (
                <><ArrowUp className="h-4 w-4 mr-2" /> Start Upgrade</>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* Main Content */}
      <motion.div
        variants={container}
        initial="hidden"
        animate="show"
        className="grid gap-6 md:grid-cols-2"
      >
        {/* Tavern Card */}
        <motion.div
          variants={item}
          className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden col-span-2"
        >
          <CardHeader className={`pb-2 ${tavern.color}`}>
            <div className="flex justify-between items-start">
              <div className="flex items-center">
                {tavern.icon}
                <CardTitle className="ml-2 font-cinzel">{tavern.name}</CardTitle>
              </div>
              <Badge variant="outline" className="border-[#4169E1] text-[#4169E1]">
                Level {currentLevel}
              </Badge>
            </div>
            <CardDescription className="mt-2">{tavern.description}</CardDescription>
          </CardHeader>
          
          <CardContent className="pt-4">
            {isBeingUpgraded ? (
              <div className="mb-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-[#C8B8DB]/80">Upgrading to Level {currentLevel + 1}</span>
                  <span className="text-[#4169E1]">{Math.round(calculateUpgradeProgress(buildingData))}%</span>
                </div>
                <Progress value={calculateUpgradeProgress(buildingData)} className="h-2 bg-[#432874]/30" />
                <div className="mt-2 flex justify-between items-center">
                  <span className="text-xs text-[#C8B8DB]/60">Time remaining:</span>
                  <CountdownTimer 
                    endTime={new Date(buildingData.upgradeEndTime || Date.now()).getTime()} 
                    onComplete={() => {
                      refetchBuildings();
                      fetchUser();
                    }}
                  />
                </div>
              </div>
            ) : (
              <>
                <h3 className="font-semibold text-[#4169E1] mb-2">Current Benefits:</h3>
                <ul className="list-disc pl-5 space-y-1 mb-4">
                  {tavern.benefits
                    .filter(benefit => benefit.level <= currentLevel)
                    .map((benefit, index) => (
                      <li key={index} className="text-sm text-[#C8B8DB]">
                        <span className="text-[#00B9AE]">Level {benefit.level}:</span> {benefit.text}
                      </li>
                    ))}
                </ul>
                
                <h3 className="font-semibold text-[#4169E1] mb-2">Next Upgrade:</h3>
                {!isMaxLevel(currentLevel) ? (
                  <>
                    <ul className="list-disc pl-5 space-y-1 mb-4">
                      {tavern.benefits
                        .filter(benefit => benefit.level === currentLevel + 1)
                        .map((benefit, index) => (
                          <li key={index} className="text-sm text-[#C8B8DB]">{benefit.text}</li>
                        ))}
                      {!tavern.benefits.some(benefit => benefit.level === currentLevel + 1) && (
                        <li className="text-sm text-[#C8B8DB]">General tavern improvements</li>
                      )}
                    </ul>
                    
                    <div className="flex flex-wrap gap-2 bg-[#432874]/10 p-3 rounded-lg">
                      <div className="flex items-center">
                        <span className="text-sm text-[#C8B8DB]/80 mr-2">Cost:</span>
                        <Badge variant="outline" className="border-[#4169E1]/30 bg-[#4169E1]/5 text-[#4169E1]">
                          {calculateUpgradeCost(currentLevel).rogueCredits} Credits
                        </Badge>
                      </div>
                      <div className="flex items-center">
                        <span className="text-sm text-[#C8B8DB]/80 mr-2">and</span>
                        <Badge variant="outline" className="border-[#4169E1]/30 bg-[#4169E1]/5 text-[#4169E1]">
                          {calculateUpgradeCost(currentLevel).forgeTokens} Tokens
                        </Badge>
                      </div>
                      <div className="flex items-center ml-auto">
                        <span className="text-sm text-[#C8B8DB]/80 mr-2">Time:</span>
                        <Badge variant="outline" className="border-[#C8B8DB]/30 bg-[#C8B8DB]/5 text-[#C8B8DB]">
                          {tavern.upgradeTimeInMinutes} minutes
                        </Badge>
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="bg-[#432874]/10 p-3 rounded-lg text-center text-[#C8B8DB]">
                    Maximum level reached
                  </div>
                )}
              </>
            )}
          </CardContent>
          
          <CardFooter className="pt-0 gap-2">
            {isBeingUpgraded ? (
              <Button 
                className="flex-1 bg-[#00B9AE] hover:bg-[#00B9AE]/80 text-[#1A1A2E]"
                onClick={completeUpgrade}
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Completing...</>
                ) : (
                  <><CheckCircle className="h-4 w-4 mr-2" /> Complete Now</>
                )}
              </Button>
            ) : (
              <>
                <Button 
                  className="flex-1 bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
                  onClick={() => setUpgradeDialog(true)}
                  disabled={isMaxLevel(currentLevel)}
                >
                  <ArrowUp className="h-4 w-4 mr-2" /> Upgrade
                </Button>
                <Button 
                  variant="outline" 
                  className="border-[#432874] text-[#C8B8DB]"
                  onClick={() => setSkillTreeDialog(true)}
                >
                  <Shield className="h-4 w-4 mr-2" /> Skill Tree
                </Button>
              </>
            )}
          </CardFooter>
        </motion.div>
        
        {/* Dungeon Tickets */}
        <motion.div
          variants={item}
          className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden"
        >
          <CardHeader className="pb-2">
            <div className="flex items-center">
              <Ticket className="h-5 w-5 text-[#4169E1] mr-2" />
              <CardTitle className="font-cinzel text-[#4169E1]">Dungeon Tickets</CardTitle>
            </div>
            <CardDescription>Collect tickets to enter dungeons</CardDescription>
          </CardHeader>
          
          <CardContent className="pt-4">
            <div className="bg-[#432874]/20 p-4 rounded-lg mb-4">
              <div className="flex justify-between items-center mb-2">
                <span className="text-[#C8B8DB]/80">Available Tickets:</span>
                <Badge className="bg-[#4169E1] text-[#1A1A2E]">
                  {user?.dungeonTickets || 0}
                </Badge>
              </div>
              
              <div className="flex justify-between items-center">
                <span className="text-[#C8B8DB]/80">Daily Generation:</span>
                <Badge variant="outline" className="border-[#00B9AE] text-[#00B9AE]">
                  {getDungeonTicketsPerDay()} tickets
                </Badge>
              </div>
              
              <div className="mt-4">
                <Button
                  className="w-full bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
                  disabled={currentLevel < 3}
                  onClick={() => {
                    toast({
                      title: "Tickets Collected",
                      description: "You've collected your daily dungeon tickets!",
                    });
                    fetchUser();
                  }}
                >
                  <RefreshCcw className="h-4 w-4 mr-2" /> Collect Daily Tickets
                </Button>
                {currentLevel < 3 && (
                  <p className="text-xs text-[#C8B8DB]/70 text-center mt-2">
                    Unlock daily tickets at Tavern Level 3
                  </p>
                )}
              </div>
            </div>
            
            <div className="text-sm text-[#C8B8DB]">
              <p>Use tickets to enter dungeons and earn valuable rewards. Higher Tavern levels generate more tickets daily.</p>
            </div>
          </CardContent>
        </motion.div>
        
        {/* Character Trading */}
        <motion.div
          variants={item}
          className="bg-[#1A1A2E] border border-[#432874]/30 rounded-xl overflow-hidden col-span-2"
        >
          <CardHeader className="pb-2">
            <div className="flex items-center">
              <Users className="h-5 w-5 text-[#4169E1] mr-2" />
              <CardTitle className="font-cinzel text-[#4169E1]">Character Trading</CardTitle>
            </div>
            <CardDescription>Trade multiple characters to obtain rarer ones</CardDescription>
          </CardHeader>
          
          <CardContent className="pt-4">
            <Tabs defaultValue="common">
              <TabsList className="grid w-full grid-cols-3 bg-[#1A1A2E]">
                <TabsTrigger value="common" className="data-[state=active]:bg-[#4169E1]/20 data-[state=active]:text-[#4169E1]">
                  Common Trades
                </TabsTrigger>
                <TabsTrigger value="rare" disabled={currentLevel < 2} className="data-[state=active]:bg-[#4169E1]/20 data-[state=active]:text-[#4169E1]">
                  Rare Trades
                </TabsTrigger>
                <TabsTrigger value="epic" disabled={currentLevel < 5} className="data-[state=active]:bg-[#4169E1]/20 data-[state=active]:text-[#4169E1]">
                  Epic Trades
                </TabsTrigger>
              </TabsList>
              
              <TabsContent value="common" className="mt-4">
                <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
                  {tradeableCharacters.map((character, index) => (
                    <div 
                      key={index} 
                      className="bg-[#432874]/10 rounded-lg p-4 border border-[#432874]/30"
                    >
                      <div className="flex justify-between items-start mb-4">
                        <div className="flex space-x-3">
                          <div className="w-14 h-14 rounded-full bg-[#432874]/40 flex items-center justify-center overflow-hidden">
                            <img src={character.image} alt={character.name} />
                          </div>
                          <div>
                            <h3 className="font-semibold text-[#C8B8DB]">{character.name}</h3>
                            <div className="flex items-center space-x-2 mt-1">
                              <Badge variant="outline" className="border-[#C8B8DB]/30 text-[#C8B8DB]/80 text-xs">
                                Lvl {character.level}
                              </Badge>
                              <Badge variant="outline" className="border-[#4169E1]/30 bg-[#4169E1]/10 text-[#4169E1] text-xs">
                                {character.rarity}
                              </Badge>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <div className="flex items-center justify-between mb-3">
                        <div className="text-sm text-[#C8B8DB]/70">Trade {character.cost}x for:</div>
                        <Badge className="bg-[#FF9D00]/20 text-[#FF9D00] border-[#FF9D00]/30">
                          {character.targetRarity}
                        </Badge>
                      </div>
                      
                      <div className="text-sm text-[#C8B8DB] mb-4">
                        {character.target}
                      </div>
                      
                      <Button
                        className="w-full bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
                        onClick={() => {
                          toast({
                            title: "Trade Complete",
                            description: `You've traded for a ${character.target}!`,
                          });
                        }}
                      >
                        Trade Characters
                      </Button>
                    </div>
                  ))}
                </div>
              </TabsContent>
              
              <TabsContent value="rare" className="mt-4">
                {currentLevel >= 2 ? (
                  <div className="grid gap-4 grid-cols-1 md:grid-cols-2">
                    {rareTradeableCharacters.map((character, index) => (
                      <div 
                        key={index} 
                        className="bg-[#432874]/10 rounded-lg p-4 border border-[#432874]/30"
                      >
                        <div className="flex justify-between items-start mb-4">
                          <div className="flex space-x-3">
                            <div className="w-14 h-14 rounded-full bg-[#432874]/40 flex items-center justify-center overflow-hidden">
                              <img src={character.image} alt={character.name} />
                            </div>
                            <div>
                              <h3 className="font-semibold text-[#C8B8DB]">{character.name}</h3>
                              <div className="flex items-center space-x-2 mt-1">
                                <Badge variant="outline" className="border-[#C8B8DB]/30 text-[#C8B8DB]/80 text-xs">
                                  Lvl {character.level}
                                </Badge>
                                <Badge variant="outline" className="border-[#FF9D00]/30 bg-[#FF9D00]/10 text-[#FF9D00] text-xs">
                                  {character.rarity}
                                </Badge>
                              </div>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex items-center justify-between mb-3">
                          <div className="text-sm text-[#C8B8DB]/70">Trade {character.cost}x for:</div>
                          <Badge className="bg-[#C70039]/20 text-[#C70039] border-[#C70039]/30">
                            {character.targetRarity}
                          </Badge>
                        </div>
                        
                        <div className="text-sm text-[#C8B8DB] mb-4">
                          {character.target}
                        </div>
                        
                        <Button
                          className="w-full bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
                          onClick={() => {
                            toast({
                              title: "Trade Complete",
                              description: `You've traded for a ${character.target}!`,
                            });
                          }}
                        >
                          Trade Characters
                        </Button>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-12 bg-[#432874]/10 rounded-lg">
                    <Badge variant="outline" className="border-[#FF9D00] text-[#FF9D00] mb-2">Locked</Badge>
                    <p className="text-[#C8B8DB]/80">Upgrade Tavern to Level 2 to unlock Rare trades</p>
                  </div>
                )}
              </TabsContent>
              
              <TabsContent value="epic" className="mt-4">
                {currentLevel >= 5 ? (
                  <div className="grid gap-4 grid-cols-1 md:grid-cols-2">
                    {epicTradeableCharacters.map((character, index) => (
                      <div 
                        key={index} 
                        className="bg-[#432874]/10 rounded-lg p-4 border border-[#432874]/30"
                      >
                        <div className="flex justify-between items-start mb-4">
                          <div className="flex space-x-3">
                            <div className="w-14 h-14 rounded-full bg-[#432874]/40 flex items-center justify-center overflow-hidden">
                              <img src={character.image} alt={character.name} />
                            </div>
                            <div>
                              <h3 className="font-semibold text-[#C8B8DB]">{character.name}</h3>
                              <div className="flex items-center space-x-2 mt-1">
                                <Badge variant="outline" className="border-[#C8B8DB]/30 text-[#C8B8DB]/80 text-xs">
                                  Lvl {character.level}
                                </Badge>
                                <Badge variant="outline" className="border-[#C70039]/30 bg-[#C70039]/10 text-[#C70039] text-xs">
                                  {character.rarity}
                                </Badge>
                              </div>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex items-center justify-between mb-3">
                          <div className="text-sm text-[#C8B8DB]/70">Trade {character.cost}x for:</div>
                          <Badge className="bg-[#FFD700]/20 text-[#FFD700] border-[#FFD700]/30">
                            {character.targetRarity}
                          </Badge>
                        </div>
                        
                        <div className="text-sm text-[#C8B8DB] mb-4">
                          {character.target}
                        </div>
                        
                        <Button
                          className="w-full bg-[#4169E1] hover:bg-[#4169E1]/80 text-[#1A1A2E]"
                          onClick={() => {
                            toast({
                              title: "Trade Complete",
                              description: `You've traded for a ${character.target}!`,
                            });
                          }}
                        >
                          Trade Characters
                        </Button>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-12 bg-[#432874]/10 rounded-lg">
                    <Badge variant="outline" className="border-[#FFD700] text-[#FFD700] mb-2">Locked</Badge>
                    <p className="text-[#C8B8DB]/80">Upgrade Tavern to Level 5 to unlock Epic trades</p>
                  </div>
                )}
              </TabsContent>
            </Tabs>
          </CardContent>
        </motion.div>
      </motion.div>
    </>
  );
};

export default TavernView;

=== client/src/hooks/use-mobile.tsx ===
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


=== client/src/hooks/use-toast.ts ===
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


=== client/src/lib/queryClient.ts ===
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey[0] as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});


=== client/src/lib/utils.ts ===
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


=== client/src/lib/discordAuth.ts ===
import { useAuthStore } from './zustandStore';

/**
 * Handles the Discord OAuth2 authentication flow.
 */
export const discordAuth = {
  /**
   * Redirects the user to Discord's authorization endpoint.
   */
  login: () => {
    useAuthStore.getState().loginWithDiscord();
  },
  
  /**
   * Logs the user out by clearing their session.
   */
  logout: async () => {
    await useAuthStore.getState().logout();
  },
  
  /**
   * Checks if the user is authenticated.
   */
  isAuthenticated: (): boolean => {
    return useAuthStore.getState().isAuthenticated;
  },
  
  /**
   * Gets the current authenticated user.
   */
  getUser: () => {
    return useAuthStore.getState().user;
  },
  
  /**
   * Refreshes the user information from the server.
   */
  refreshUser: async () => {
    return await useAuthStore.getState().fetchUser();
  }
};

/**
 * Custom hook for using Discord auth in components
 */
export const useDiscordAuth = () => {
  const { user, isAuthenticated, isLoading, loginWithDiscord, logout, fetchUser } = useAuthStore();
  
  return {
    user,
    isAuthenticated,
    isLoading,
    login: loginWithDiscord,
    logout,
    fetchUser
  };
};


=== client/src/lib/tooltipData.ts ===
import { GameMechanicTooltip } from "@/components/common/GameTooltip";

// Define all game tooltips data
export const gameMechanicsTooltips: GameMechanicTooltip[] = [
  // Combat Mechanics
  {
    id: 'attack-meter',
    title: 'Attack Meter',
    description: 'Determines when a character can attack. The meter fills based on Speed stat, and when it reaches 100% the character can perform an action.',
    category: 'combat'
  },
  {
    id: 'status-effects',
    title: 'Status Effects',
    description: 'Temporary conditions that affect characters in battle. Effects include Burning (damage over time), Poisoned (damage over time), Weakened (reduced attack), and Slowed (reduced speed).',
    category: 'combat'
  },
  {
    id: 'skill-cooldown',
    title: 'Skill Cooldown',
    description: 'Powerful skills can only be used every X number of turns. Basic skills have no cooldown, while Advanced and Ultimate skills trigger based on a set number of attacks.',
    category: 'combat'
  },
  {
    id: 'elemental-types',
    title: 'Elemental Types',
    description: 'Characters and auras have elemental types (Fire, Water, Earth, Air) that affect their skills and potential strengths against enemies of specific elements.',
    category: 'combat'
  },

  // Character Stats
  {
    id: 'attack-stat',
    title: 'Attack',
    description: 'Determines the base damage a character deals with skills. Damage is calculated as: Attack  Skill Damage Multiplier.',
    category: 'character'
  },
  {
    id: 'vitality-stat',
    title: 'Vitality',
    description: 'Determines a character\'s maximum health points (HP). Higher vitality means more survivability in battle.',
    category: 'character'
  },
  {
    id: 'speed-stat',
    title: 'Speed',
    description: 'Determines how quickly the Attack Meter fills, allowing characters to act more frequently in battle.',
    category: 'character'
  },
  {
    id: 'focus-stat',
    title: 'Focus',
    description: 'Improves the chance of landing critical hits and increases critical damage.',
    category: 'character'
  },
  {
    id: 'accuracy-stat',
    title: 'Accuracy',
    description: 'Determines the chance to hit enemies. Higher accuracy reduces the chance of missing attacks.',
    category: 'character'
  },
  {
    id: 'defense-stat',
    title: 'Defense',
    description: 'Reduces incoming physical damage. Each point of defense reduces damage by a percentage.',
    category: 'character'
  },
  {
    id: 'resilience-stat',
    title: 'Resilience',
    description: 'Reduces the duration and effects of negative status conditions. Also provides resistance to magical damage.',
    category: 'character'
  },

  // Aura Mechanics
  {
    id: 'aura-bonuses',
    title: 'Aura Bonuses',
    description: 'Auras provide percentage-based boosts to character stats when equipped. These bonuses are shown as green numbers next to the base stat values.',
    category: 'aura'
  },
  {
    id: 'aura-rarities',
    title: 'Aura Rarities',
    description: 'Auras come in different rarities: Common, Uncommon, Rare, Epic, and Legendary. Higher rarity auras provide stronger stat bonuses and skills.',
    category: 'aura'
  },
  {
    id: 'aura-skills',
    title: 'Aura Skills',
    description: 'Auras grant skills to characters. Each aura can provide Basic, Advanced, and occasionally Ultimate skills based on its rarity.',
    category: 'aura'
  },

  // Farming Mechanics
  {
    id: 'farming-tasks',
    title: 'Farming Tasks',
    description: 'Send characters to gather resources from different locations. Tasks take real time to complete, and yield resources based on the character\'s level and the task difficulty.',
    category: 'farming'
  },
  {
    id: 'resource-types',
    title: 'Resource Types',
    description: 'Different resources are used for various activities: Basic materials for crafting, premium currencies for special items, and building materials for upgrades.',
    category: 'farming'
  },
  {
    id: 'farming-slots',
    title: 'Farming Slots',
    description: 'The number of simultaneous farming tasks you can have is determined by your Townhall level and unlocked skills.',
    category: 'farming'
  },

  // Forge Mechanics
  {
    id: 'forging-tasks',
    title: 'Forging Tasks',
    description: 'Create new auras by combining elemental essences. The forge transforms these essences into auras with random stats and skills based on the recipe used.',
    category: 'forge'
  },
  {
    id: 'forge-slots',
    title: 'Forge Slots',
    description: 'The number of simultaneous forging tasks you can have is determined by your Townhall level and unlocked skills.',
    category: 'forge'
  },
  {
    id: 'forge-recipes',
    title: 'Forge Recipes',
    description: 'Different combinations of materials produce different types of auras. Higher quality materials and rare recipes are more likely to produce powerful auras.',
    category: 'forge'
  },

  // Dungeon Mechanics
  {
    id: 'dungeon-types',
    title: 'Dungeon Types',
    description: 'Dungeons come in different elemental types and difficulties. Each dungeon has unique enemies and potential rewards.',
    category: 'dungeons'
  },
  {
    id: 'dungeon-stages',
    title: 'Dungeon Stages',
    description: 'Each dungeon consists of multiple stages with progressively stronger enemies. The final stage typically contains a boss with special abilities.',
    category: 'dungeons'
  },
  {
    id: 'dungeon-rewards',
    title: 'Dungeon Rewards',
    description: 'Completing dungeons rewards you with resources, currencies, and occasionally rare auras. Higher difficulty dungeons provide better rewards.',
    category: 'dungeons'
  },

  // Building Mechanics
  {
    id: 'townhall-upgrades',
    title: 'Townhall Upgrades',
    description: 'The Townhall is your main building that determines the maximum level of other buildings and unlocks new features.',
    category: 'building'
  },
  {
    id: 'skill-tree',
    title: 'Skill Tree',
    description: 'Unlock powerful abilities and bonuses through the skill tree. Skill points are earned by leveling up your Townhall and completing special quests.',
    category: 'building'
  },
  {
    id: 'building-slots',
    title: 'Building Slots',
    description: 'You can construct various buildings that provide unique benefits, such as additional farming slots, forge improvements, or character bonuses.',
    category: 'building'
  },

  // General Mechanics
  {
    id: 'level-progression',
    title: 'Level Progression',
    description: 'Characters, buildings, and auras gain levels through experience or upgrades. Higher levels provide stronger stats and unlock new abilities.',
    category: 'general'
  },
  {
    id: 'currencies',
    title: 'Currencies',
    description: 'The game features multiple currencies: Rogue Credits (common), Soul Shards (premium), and Forge Tokens (special crafting currency).',
    category: 'general'
  },
  {
    id: 'seasons',
    title: 'Seasons',
    description: 'Limited-time events that offer special challenges, unique rewards, and themed content. Seasonal progress is tracked separately from main progression.',
    category: 'general'
  }
];

// Utility function to get tooltip by ID
export function getTooltipById(id: string): GameMechanicTooltip | undefined {
  return gameMechanicsTooltips.find(tooltip => tooltip.id === id);
}

// Utility function to get tooltips by category
export function getTooltipsByCategory(category: GameMechanicTooltip['category']): GameMechanicTooltip[] {
  return gameMechanicsTooltips.filter(tooltip => tooltip.category === category);
}

=== client/src/lib/zustandStore.ts ===
import { create } from 'zustand';
import { apiRequest } from './queryClient';
import type { User, Character, Aura, Resource, FarmingTask, DungeonRun, ForgingTask, BlackMarketListing, BountyQuest } from '@shared/schema';

// Add selected character IDs to the store
interface StoreState {
  selectedCharacterIds: number[];
  setSelectedCharacterIds: (characterIds: number[]) => void;
}

// Export a store specifically for selected character IDs
export const useStore = create<StoreState>((set) => ({
  selectedCharacterIds: [],
  setSelectedCharacterIds: (characterIds) => set({ selectedCharacterIds: characterIds }),
}));

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  loginWithDiscord: () => void;
  logout: () => void;
  fetchUser: () => Promise<User | null>;
}

interface GameState {
  // Resources
  forgeTokens: number;
  rogueCredits: number;
  soulShards: number;
  resources: Resource[];
  
  // Game Settings
  speedBoostActive: boolean;
  speedBoostMultiplier: number;
  
  // Collections
  characters: Character[];
  auras: Aura[];
  auraInventory: any[]; // For equipped auras with stat bonuses
  buildings: any[]; // Building levels for account power
  
  // Active tasks
  farmingTasks: FarmingTask[];
  dungeonRuns: DungeonRun[];
  forgingTasks: ForgingTask[];
  
  // Marketplace
  blackMarketListings: BlackMarketListing[];
  
  // Bounties
  bountyQuests: BountyQuest[];
  
  // Discord chat
  discordMessages: { id: string; username: string; content: string; timestamp: Date }[];
  
  // Functions
  updateCurrencies: (forgeTokens: number, rogueCredits: number, soulShards: number) => void;
  fetchResources: () => Promise<void>;
  fetchCharacters: () => Promise<void>;
  fetchAuras: () => Promise<void>;
  fetchFarmingTasks: () => Promise<void>;
  fetchDungeonRuns: () => Promise<void>;
  fetchForgingTasks: () => Promise<void>;
  fetchBlackMarketListings: () => Promise<void>;
  fetchBountyQuests: () => Promise<void>;
  
  addDiscordMessage: (username: string, content: string) => void;
}

// Auth store
export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  isLoading: true,
  isAuthenticated: false,
  
  loginWithDiscord: () => {
    // In development mode, we can use the dev-login endpoint
    const isLocal = window.location.hostname === 'localhost' || window.location.hostname.includes('replit');
    
    if (isLocal) {
      console.log('Using dev login route for local/replit development');
      window.location.href = '/api/auth/dev-login';
    } else {
      // Use real Discord auth in production
      window.location.href = '/api/auth/discord';
    }
  },
  
  logout: async () => {
    try {
      await apiRequest('GET', '/api/auth/logout', undefined);
      set({ user: null, isAuthenticated: false });
    } catch (error) {
      console.error('Logout failed:', error);
    }
  },
  
  fetchUser: async () => {
    set({ isLoading: true });
    try {
      const res = await fetch('/api/auth/user', { credentials: 'include' });
      if (res.ok) {
        const user = await res.json();
        set({ user, isAuthenticated: true, isLoading: false });
        
        // Update game store with user's currencies
        const gameStore = useGameStore.getState();
        gameStore.updateCurrencies(user.forgeTokens || 0, user.rogueCredits || 0, user.soulShards || 0);
        
        return user;
      } else {
        set({ user: null, isAuthenticated: false, isLoading: false });
        return null;
      }
    } catch (error) {
      console.error('Error fetching user:', error);
      set({ user: null, isAuthenticated: false, isLoading: false });
      return null;
    }
  }
}));

// Game store
export const useGameStore = create<GameState>((set, get) => ({
  // Resources
  forgeTokens: 0,
  rogueCredits: 0,
  soulShards: 0,
  resources: [],
  
  // Game Settings
  speedBoostActive: true,
  speedBoostMultiplier: 10,
  
  // Collections
  characters: [],
  auras: [],
  auraInventory: [],
  buildings: [],
  
  // Active tasks
  farmingTasks: [],
  dungeonRuns: [],
  forgingTasks: [],
  
  // Marketplace
  blackMarketListings: [],
  
  // Bounties
  bountyQuests: [],
  
  // Discord chat
  discordMessages: [
    { id: '1', username: 'GuildMaster', content: 'Anyone want to try the new dungeon?', timestamp: new Date() },
    { id: '2', username: 'AuraCollector', content: 'I got a rare Fire Aura from fusion!', timestamp: new Date() },
    { id: '3', username: 'ForgeHero', content: "I'll join the dungeon run in 5", timestamp: new Date() }
  ],
  
  // Update currencies
  updateCurrencies: (forgeTokens, rogueCredits, soulShards) => {
    set({ forgeTokens, rogueCredits, soulShards });
  },
  
  // Functions
  fetchResources: async () => {
    try {
      const res = await fetch('/api/resources', { credentials: 'include' });
      if (res.ok) {
        const resources = await res.json();
        set({ resources });
      }
    } catch (error) {
      console.error('Error fetching resources:', error);
    }
  },
  
  fetchCharacters: async () => {
    try {
      const res = await fetch('/api/characters', { credentials: 'include' });
      if (res.ok) {
        const characters = await res.json();
        set({ characters });
      }
    } catch (error) {
      console.error('Error fetching characters:', error);
    }
  },
  
  fetchAuras: async () => {
    try {
      const res = await fetch('/api/auras', { credentials: 'include' });
      if (res.ok) {
        const auras = await res.json();
        set({ auras });
      }
    } catch (error) {
      console.error('Error fetching auras:', error);
    }
  },
  
  fetchFarmingTasks: async () => {
    try {
      const res = await fetch('/api/farming/tasks', { credentials: 'include' });
      if (res.ok) {
        const farmingTasks = await res.json();
        set({ farmingTasks });
      }
    } catch (error) {
      console.error('Error fetching farming tasks:', error);
    }
  },
  
  fetchDungeonRuns: async () => {
    try {
      const res = await fetch('/api/dungeons/runs', { credentials: 'include' });
      if (res.ok) {
        const dungeonRuns = await res.json();
        set({ dungeonRuns });
      }
    } catch (error) {
      console.error('Error fetching dungeon runs:', error);
    }
  },
  
  fetchForgingTasks: async () => {
    try {
      const res = await fetch('/api/forge/tasks', { credentials: 'include' });
      if (res.ok) {
        const forgingTasks = await res.json();
        set({ forgingTasks });
      }
    } catch (error) {
      console.error('Error fetching forging tasks:', error);
    }
  },
  
  fetchBlackMarketListings: async () => {
    try {
      const res = await fetch('/api/blackmarket/listings', { credentials: 'include' });
      if (res.ok) {
        const blackMarketListings = await res.json();
        set({ blackMarketListings });
      }
    } catch (error) {
      console.error('Error fetching black market listings:', error);
    }
  },
  
  fetchBountyQuests: async () => {
    try {
      const res = await fetch('/api/bounty/quests', { credentials: 'include' });
      if (res.ok) {
        const bountyQuests = await res.json();
        set({ bountyQuests });
      }
    } catch (error) {
      console.error('Error fetching bounty quests:', error);
    }
  },
  
  addDiscordMessage: (username: string, content: string) => {
    const newMessage = {
      id: Date.now().toString(),
      username,
      content,
      timestamp: new Date()
    };
    set((state) => ({
      discordMessages: [...state.discordMessages, newMessage].slice(-100) // Keep only latest 100 messages
    }));
  }
}));


=== client/src/pages/not-found.tsx ===
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}


=== client/src/pages/dashboard.tsx ===
import DashboardView from "@/components/dashboard/DashboardView";

const Dashboard = () => {
  return <DashboardView />;
};

export default Dashboard;


=== client/src/pages/characters.tsx ===
import CharactersView from "@/components/characters/CharactersView";

const Characters = () => {
  return <CharactersView />;
};

export default Characters;


=== client/src/pages/dungeons.tsx ===
import DungeonView from "@/components/dungeons/DungeonView";

const Dungeons = () => {
  return <DungeonView />;
};

export default Dungeons;


=== client/src/pages/farming.tsx ===
import FarmingView from "@/components/farming/FarmingView";

const Farming = () => {
  return <FarmingView />;
};

export default Farming;


=== client/src/pages/forge.tsx ===
import ForgeView from "@/components/forge/ForgeView";

const Forge = () => {
  return <ForgeView />;
};

export default Forge;


=== client/src/pages/blackmarket.tsx ===
import BlackMarketView from "@/components/blackmarket/BlackMarketView";

const BlackMarket = () => {
  return <BlackMarketView />;
};

export default BlackMarket;


=== client/src/pages/buildings.tsx ===
import BuildingsView from "@/components/buildings/BuildingsView";

const Buildings = () => {
  return <BuildingsView />;
};

export default Buildings;


=== client/src/pages/bounty.tsx ===
import BountyBoardView from "@/components/bounty/BountyBoardView";

const Bounty = () => {
  return <BountyBoardView />;
};

export default Bounty;


=== client/src/pages/collections.tsx ===
import { useEffect } from 'react';
import CollectionsView from '@/components/collections/CollectionsView';
import { useDiscordAuth } from '@/lib/discordAuth';
import { Redirect } from 'wouter';

export default function Collections() {
  const { user } = useDiscordAuth();

  // Redirect unauthenticated users
  if (!user) {
    return <Redirect to="/" />;
  }

  return (
    <div className="container mx-auto p-4">
      <CollectionsView />
    </div>
  );
}

=== client/src/pages/inventory.tsx ===
import InventoryView from '@/components/inventory/InventoryView';

export default function InventoryPage() {
  return <InventoryView />;
}

=== client/src/pages/townhall.tsx ===
import TownhallView from '@/components/townhall/TownhallView';

const Townhall = () => {
  return (
    <div className="container px-4 py-6 mx-auto max-w-7xl">
      <TownhallView />
    </div>
  );
};

export default Townhall;

=== client/src/pages/tavern.tsx ===
import TavernView from '@/components/tavern/TavernView';

const Tavern = () => {
  return (
    <div className="container px-4 py-6 mx-auto max-w-7xl">
      <TavernView />
    </div>
  );
};

export default Tavern;

=== client/src/main.tsx ===
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

const meta = document.createElement('meta');
meta.name = 'description';
meta.content = 'The Forge - Aura Forge management platform for crafting, fusion, farming, and dungeon exploration.';
document.head.appendChild(meta);

const title = document.createElement('title');
title.textContent = 'The Forge - Fantasy RPG Management Platform';
document.head.appendChild(title);

// Import fonts
const fontLink = document.createElement('link');
fontLink.rel = 'stylesheet';
fontLink.href = 'https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Nunito:wght@300;400;600;700&family=Metamorphous&display=swap';
document.head.appendChild(fontLink);

createRoot(document.getElementById("root")!).render(<App />);


=== client/src/index.css ===
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 240 35% 11%;
    --foreground: 263 30% 85%;

    --card: 240 35% 13%;
    --card-foreground: 263 30% 85%;

    --popover: 240 38% 13%;
    --popover-foreground: 263 30% 85%;

    --primary: 263 48% 30%;
    --primary-foreground: 26 100% 50%;

    --secondary: 26 100% 50%;
    --secondary-foreground: 240 38% 13%;

    --muted: 263 15% 25%;
    --muted-foreground: 263 20% 70%;

    --accent: 174 100% 36%;
    --accent-foreground: 240 38% 13%;

    --destructive: 0 84% 60%;
    --destructive-foreground: 210 20% 98%;

    --border: 263 30% 30%;
    --input: 263 30% 20%;
    --ring: 263 50% 45%;

    --radius: 0.5rem;

    --chart-1: 263 48% 30%;
    --chart-2: 26 100% 50%;
    --chart-3: 174 100% 36%;
    --chart-4: 184 80% 50%;
    --chart-5: 330 80% 50%;

    --sidebar-background: 240 35% 13%;
    --sidebar-foreground: 263 30% 85%;
    --sidebar-primary: 263 48% 30%;
    --sidebar-primary-foreground: 26 100% 50%;
    --sidebar-accent: 174 100% 36%;
    --sidebar-accent-foreground: 240 38% 13%;
    --sidebar-border: 263 30% 30%;
    --sidebar-ring: 263 50% 45%;
  }
  
  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
  }
}

/* Custom font families */
.font-cinzel {
  font-family: 'Cinzel', serif;
}

.font-nunito {
  font-family: 'Nunito', sans-serif;
}

.font-metamorphous {
  font-family: 'Metamorphous', cursive;
}


=== client/src/App.tsx ===
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import NotFound from "@/pages/not-found";
import MainLayout from "@/components/layout/MainLayout";
import Dashboard from "@/pages/dashboard";
import Inventory from "@/pages/inventory";
import Dungeons from "@/pages/dungeons";
import Farming from "@/pages/farming";
import Forge from "@/pages/forge";
import BlackMarket from "@/pages/blackmarket";
import Buildings from "@/pages/buildings";
import Bounty from "@/pages/bounty";
import Collections from "@/pages/collections";
import Townhall from "@/pages/townhall";
import Tavern from "@/pages/tavern";

function Router() {
  return (
    <Switch>
      <Route path="/" component={Dashboard} />
      <Route path="/inventory" component={Inventory} />
      <Route path="/dungeons" component={Dungeons} />
      <Route path="/farming" component={Farming} />
      <Route path="/forge" component={Forge} />
      <Route path="/blackmarket" component={BlackMarket} />
      <Route path="/townhall" component={Townhall} />
      <Route path="/tavern" component={Tavern} />
      <Route path="/buildings" component={Buildings} />
      <Route path="/bountyboard" component={Bounty} />
      <Route path="/collections" component={Collections} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MainLayout>
        <Router />
      </MainLayout>
      <Toaster />
    </QueryClientProvider>
  );
}

export default App;


=== client/index.html ===
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <link rel="icon" type="image/svg+xml" href="https://cdn-icons-png.flaticon.com/512/1156/1156897.png" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>


=== server/vite.ts ===
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}


=== server/types.d.ts ===
// Extending express-session with custom session data
import 'express-session';

declare module 'express-session' {
  interface SessionData {
    userId: number;
  }
}

=== server/db.ts ===
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });

=== server/index.ts ===
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { registerAdminRoutes } from "./admin";
import { setupVite, serveStatic, log } from "./vite";

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);
  
  // Register admin routes
  await registerAdminRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = 5000;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();


=== server/admin.ts ===
import { Express, Request, Response } from 'express';
import { storage } from './storage';

export async function registerAdminRoutes(app: Express) {
  // Admin endpoint to add 15,000 Essence
  app.post('/api/admin/add-essence', async (req: Request, res: Response) => {
    try {
      // Get user ID (using ID 1 for development)
      const userId = 1;
      
      // Check if Essence resource exists
      let essence = await storage.getResourceByNameAndUserId('Essence', userId);
      
      if (essence) {
        // Update existing resource
        const updatedEssence = await storage.updateResource(essence.id, {
          quantity: (essence.quantity || 0) + 15000
        });
        res.json(updatedEssence);
      } else {
        // Create new Essence resource
        const newEssence = await storage.createResource({
          userId,
          name: 'Essence',
          description: 'Magical essence used for crafting and upgrading',
          type: 'crafting',
          iconUrl: 'https://images.unsplash.com/photo-1614728263952-84ea256f9679?w=150&h=150&fit=crop',
          quantity: 15000
        });
        res.json(newEssence);
      }
      
      // Log activity
      await storage.createActivityLog({
        userId,
        activityType: 'resource_added',
        description: 'Added 15,000 Essence',
        relatedIds: {}
      });
      
      console.log('Added 15,000 Essence to user account');
      
    } catch (error) {
      console.error('Error adding essence:', error);
      res.status(500).json({ message: 'Failed to add essence' });
    }
  });
  
  // Admin endpoint to add 5,000 Rogue Credits and 5,000 Forge Tokens
  app.post('/api/admin/add-currency', async (req: Request, res: Response) => {
    try {
      // Get user ID (using ID 1 for development)
      const userId = 1;
      
      // Get the user
      const user = await storage.getUserById(userId);
      
      if (user) {
        // Update user with additional currency
        const updatedUser = await storage.updateUser(userId, {
          rogueCredits: (user.rogueCredits || 0) + 5000,
          forgeTokens: (user.forgeTokens || 0) + 5000
        });
        
        // Log activity
        await storage.createActivityLog({
          userId,
          activityType: 'currency_added',
          description: 'Added 5,000 Rogue Credits and 5,000 Forge Tokens',
          relatedIds: {}
        });
        
        console.log('Added currency to user account', updatedUser);
        res.json({ success: true, user: updatedUser });
      } else {
        res.status(404).json({ message: 'User not found' });
      }
    } catch (error) {
      console.error('Error adding currency:', error);
      res.status(500).json({ message: 'Failed to add currency' });
    }
  });
  
  // Add more admin routes here as needed
}

=== server/townhallSkills.ts ===
// Townhall skill tree structure
export const townhallSkillTree = [
  // Main Townhall skills
  {
    id: 'resource_production',
    name: 'Resource Production',
    description: 'Increases resource gain by 5% per level',
    maxLevel: 5
  },
  {
    id: 'experience_boost',
    name: 'Experience Boost',
    description: 'Increases XP gain by 5% per level',
    maxLevel: 5
  },
  {
    id: 'construction_speed',
    name: 'Construction Speed',
    description: 'Reduces building upgrade time by 5% per level',
    maxLevel: 5
  },
  {
    id: 'extra_farming_slot',
    name: 'Extra Farming Slot',
    description: 'Unlocks an additional farming slot',
    maxLevel: 5
  },

  // Farm Plot unlocks
  { 
    id: 'th_farm_plot_1', 
    name: 'Farm Plot #1', 
    description: 'Unlocks farm plot #1 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_farm_plot_2', 
    name: 'Farm Plot #2', 
    description: 'Unlocks farm plot #2 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_farm_plot_3', 
    name: 'Farm Plot #3', 
    description: 'Unlocks farm plot #3 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_farm_plot_4', 
    name: 'Farm Plot #4', 
    description: 'Unlocks farm plot #4 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_farm_plot_5', 
    name: 'Farm Plot #5', 
    description: 'Unlocks farm plot #5 (requires Building Plans)', 
    maxLevel: 1 
  },
  
  // Forge Crafting Slot unlocks
  { 
    id: 'th_forge_slot_1', 
    name: 'Forge Crafting Slot #1', 
    description: 'Unlocks forge crafting slot #1 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_forge_slot_2', 
    name: 'Forge Crafting Slot #2', 
    description: 'Unlocks forge crafting slot #2 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_forge_slot_3', 
    name: 'Forge Crafting Slot #3', 
    description: 'Unlocks forge crafting slot #3 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_forge_slot_4', 
    name: 'Forge Crafting Slot #4', 
    description: 'Unlocks forge crafting slot #4 (requires Building Plans)', 
    maxLevel: 1 
  },
  { 
    id: 'th_forge_slot_5', 
    name: 'Forge Crafting Slot #5', 
    description: 'Unlocks forge crafting slot #5 (requires Building Plans)', 
    maxLevel: 1 
  },
  
  // Special unlocks (every 5th level)
  { 
    id: 'th_crafting_station_1', 
    name: 'Crafting Station #1', 
    description: 'Unlocks crafting station #1 (available at Townhall level 5)', 
    maxLevel: 1, 
    requires: { townhall_level: 5 } 
  },
  { 
    id: 'th_crafting_station_2', 
    name: 'Crafting Station #2', 
    description: 'Unlocks crafting station #2 (available at Townhall level 10)', 
    maxLevel: 1, 
    requires: { townhall_level: 10 } 
  },
  { 
    id: 'th_farm_expansion_1', 
    name: 'Farm Expansion #1', 
    description: 'Unlocks an extra farm expansion (available at Townhall level 5)', 
    maxLevel: 1, 
    requires: { townhall_level: 5 } 
  },
  { 
    id: 'th_farm_expansion_2', 
    name: 'Farm Expansion #2', 
    description: 'Unlocks an extra farm expansion (available at Townhall level 10)', 
    maxLevel: 1, 
    requires: { townhall_level: 10 } 
  },
];

/**
 * Checks if a player has the required Building Plans resource
 * @param userId The user ID to check
 * @param storage The storage interface to use
 * @returns True if the player has Building Plans, false otherwise
 */
export async function hasBuildingPlans(userId: number, storage: any): Promise<boolean> {
  try {
    const resource = await storage.getResourceByNameAndUserId('Building Plans', userId);
    return resource && resource.quantity && resource.quantity >= 1;
  } catch (error) {
    console.error('Error checking for Building Plans:', error);
    return false;
  }
}

/**
 * Consumes a Building Plan resource from the player's inventory
 * @param userId The user ID to consume from
 * @param storage The storage interface to use
 * @returns True if successful, false otherwise
 */
export async function consumeBuildingPlan(userId: number, storage: any): Promise<boolean> {
  try {
    const resource = await storage.getResourceByNameAndUserId('Building Plans', userId);
    if (!resource || !resource.quantity || resource.quantity < 1) {
      return false;
    }
    
    await storage.updateResource(resource.id, {
      quantity: resource.quantity - 1
    });
    
    return true;
  } catch (error) {
    console.error('Error consuming Building Plan:', error);
    return false;
  }
}

/**
 * Gets the total available farming plots based on unlocked skills
 * @param unlockedSkills Array of unlocked skill IDs
 * @returns The number of available farming plots
 */
export function getAvailableFarmingPlots(unlockedSkills: string[]): number {
  return unlockedSkills.filter(skill => skill.startsWith('th_farm_plot_')).length;
}

/**
 * Gets the total available forge slots based on unlocked skills
 * @param unlockedSkills Array of unlocked skill IDs
 * @returns The number of available forge slots
 */
export function getAvailableForgeSlots(unlockedSkills: string[]): number {
  return unlockedSkills.filter(skill => skill.startsWith('th_forge_slot_')).length;
}

/**
 * Checks if the player needs to make a special upgrade choice
 * @param currentLevel The current Townhall level
 * @param unlockedSkills Array of unlocked skill IDs
 * @returns True if a special choice is available, false otherwise
 */
export function hasSpecialUpgradeChoice(currentLevel: number, unlockedSkills: string[]): boolean {
  if (currentLevel % 5 !== 0) return false;
  
  const levelSpecificUpgrades = townhallSkillTree.filter(skill => 
    skill.requires && skill.requires.townhall_level === currentLevel
  );
  
  // Check if any of these upgrades haven't been unlocked yet
  return levelSpecificUpgrades.some(skill => !unlockedSkills.includes(skill.id));
}

=== server/battle-system.ts ===
/**
 * New Battle System for The Forge
 * Clean implementation with improved architecture
 */

/**
 * Type definitions for the battle system
 */

// Status effect applied to units in battle
export interface StatusEffect {
  name: string;           // Display name of the effect
  type: string;           // Effect type (burn, poison, slow, weaken, etc.)
  value: number;          // Magnitude of the effect
  duration: number;       // Remaining turns/actions
  source?: string;        // Source of the effect (character/skill name)
}

// Core battle unit (character or enemy)
export interface BattleUnit {
  id: string;             // Unique identifier 
  name: string;           // Display name
  hp: number;             // Current health points
  maxHp: number;          // Maximum health points
  attackMeter: number;    // Current attack meter progress (0-100)
  
  // Base stats
  stats: {
    attack: number;       // Base attack power
    vitality: number;     // Base vitality (affects max HP)
    speed: number;        // Base speed (affects attack meter fill rate)
    [key: string]: number; // Additional stats
  };
  
  // Combat skills
  skills: {
    basic: BattleSkill;   // Always available skill
    advanced: BattleSkill | null; // Skill with moderate cooldown
    ultimate: BattleSkill | null; // Powerful skill with long cooldown
    [key: string]: BattleSkill | null; // Additional skills
  };
  
  // Optional bonuses from auras
  auraBonus?: {
    attack: number;       // % bonus to attack
    vitality: number;     // % bonus to vitality
    speed: number;        // % bonus to speed
    focus?: number;       // % bonus to critical chance
    accuracy?: number;    // % reduction in miss chance
    defense?: number;     // % reduction in damage taken
    resilience?: number;  // % resistance to status effects
    element?: string;     // Elemental affinity
    [key: string]: any;   // Other bonuses
  } | null;
  
  // Gameplay state tracking
  advancedSkillCooldown: number;  // Turns until advanced skill is available
  ultimateSkillCooldown: number;  // Turns until ultimate skill is available
  statusEffects: StatusEffect[];  // Active status effects on this unit
  
  // Battle statistics
  totalDamageDealt?: number;      // Total damage dealt in battle
  totalDamageReceived?: number;   // Total damage received in battle
  totalHealingDone?: number;      // Total healing done to allies
  totalHealingReceived?: number;  // Total healing received
}

// Skill definition
export interface BattleSkill {
  name: string;           // Display name
  damage: number;         // Base damage/healing value
  cooldown?: number;      // Turns between uses
  special?: string;       // Special effect type
  aoe?: boolean;          // Whether it hits multiple targets
}

// Combat action performed in battle
export interface BattleAction {
  actor: string;          // Name of the unit performing the action
  skill: string;          // Name of the skill used
  target: string;         // Name of the target unit
  damage: number;         // Amount of damage/healing done
  isCritical: boolean;    // Whether the hit was critical
  healing?: boolean;      // Whether this is a healing action
  message?: string;       // Display message for this action
  type?: string;          // Action type (attack, status, defeat, etc.)
}

// Battle log entry types
export interface BattleEvent {
  type: string;           // Event type (round, system_message, etc.)
  timestamp?: number;     // When this event occurred
  
  // Round-specific properties
  number?: number;            // Round number (when type === 'round')
  actions?: BattleAction[];   // Array of actions in this round
  remainingAllies?: number;   // Number of allies still alive after round
  remainingEnemies?: number;  // Number of enemies still alive after round
  
  // Stage progress properties
  allies?: BattleUnit[];      // All allies in battle
  enemies?: BattleUnit[];     // All enemies in battle
  currentStage?: number;      // Current dungeon stage
  totalStages?: number;       // Total stages in dungeon
  message?: string;           // Display message
  aliveAllies?: BattleUnit[]; // Allies still alive
  newEnemies?: BattleUnit[];  // New enemies that appeared
  completedStages?: number;   // Number of stages completed
  survivingAllies?: string[]; // Names of surviving allies
  victory?: boolean;          // Whether the battle/stage was won
  summary?: string;           // Battle summary
  
  // System message
  system_message?: string;    // System message to display
  
  // Any other properties
  [key: string]: any;
}

/**
 * Primary function to generate a battle log for a dungeon run
 * @param run The dungeon run data including characters and dungeon info
 * @param success Whether the run is predetermined to succeed
 * @returns A complete battle log with all events
 */
export async function generateBattleLog(run: any, success: boolean): Promise<BattleEvent[]> {
  console.log('======= BATTLE SYSTEM: START =======');
  console.log('Generating battle log for run:', run.id);
  console.log('Success preset:', success);
  console.log('Run character IDs:', run.characterIds);
  console.log('Run dungeon level:', run.dungeonLevel);
  
  // Create an empty battle log
  const battleLog: BattleEvent[] = [];
  
  // Add system initialization message
  battleLog.push({
    type: 'system_message',
    message: 'Initializing battle system...',
    timestamp: Date.now()
  });
  
  // In the full implementation, this would contain:
  // 1. Character data loading
  // 2. Enemy generation based on dungeon
  // 3. Full combat simulation with mechanics
  // 4. Multi-stage progression
  
  // For now, we'll return a placeholder battle log
  battleLog.push({
    type: 'system_message',
    message: 'New battle system is being implemented. Check back soon!',
    timestamp: Date.now()
  });
  
  console.log('======= BATTLE SYSTEM: COMPLETE =======');
  return battleLog;
}


=== server/storage.ts ===
import { db } from './db';
import {
  users, characters, auras, resources, farmingTasks, dungeonTypes, dungeonRuns,
  forgingTasks, blackMarketListings, bountyQuests, buildingUpgrades, activityLogs, metadata,
  type User, type InsertUser, type Character, type InsertCharacter,
  type Aura, type InsertAura, type Resource, type InsertResource,
  type FarmingTask, type InsertFarmingTask, 
  type DungeonType, type InsertDungeonType, type DungeonRun, type InsertDungeonRun,
  type ForgingTask, type InsertForgingTask, type BlackMarketListing, type InsertBlackMarketListing,
  type BountyQuest, type InsertBountyQuest, type BuildingUpgrade, type InsertBuildingUpgrade,
  type ActivityLog, type InsertActivityLog, type Metadata, type InsertMetadata
} from '@shared/schema';
import { eq, and, desc, sql } from 'drizzle-orm';

export interface IStorage {
  // User methods
  getUserById(id: number): Promise<User | undefined>;
  getUserByDiscordId(discordId: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;

  // Character methods
  getCharacters(userId: number): Promise<Character[]>;
  getCharacterById(id: number): Promise<Character | undefined>;
  createCharacter(character: InsertCharacter): Promise<Character>;
  updateCharacter(id: number, updates: Partial<Character>): Promise<Character | undefined>;
  deleteCharacter(id: number): Promise<boolean>;
  getActiveCharacterTasks(characterId: number): Promise<(FarmingTask | ForgingTask)[]>;
  
  // Aura methods
  getAuras(userId: number): Promise<Aura[]>;
  getAuraById(id: number): Promise<Aura | undefined>;
  getCharacterAuras(characterId: number): Promise<Aura[]>;
  createAura(aura: InsertAura): Promise<Aura>;
  updateAura(id: number, updates: Partial<Aura>): Promise<Aura | undefined>;
  deleteAura(id: number): Promise<boolean>;
  
  // Resource methods
  getResources(userId: number): Promise<Resource[]>;
  getResourceByNameAndUserId(name: string, userId: number): Promise<Resource | undefined>;
  createResource(resource: InsertResource): Promise<Resource>;
  updateResource(id: number, updates: Partial<Resource>): Promise<Resource | undefined>;
  
  // Farming Task methods
  getFarmingTasks(userId: number): Promise<FarmingTask[]>;
  getFarmingTaskById(id: number): Promise<FarmingTask | undefined>;
  createFarmingTask(task: InsertFarmingTask): Promise<FarmingTask>;
  updateFarmingTask(id: number, updates: Partial<FarmingTask>): Promise<FarmingTask | undefined>;
  deleteFarmingTask(id: number): Promise<boolean>;
  
  // Dungeon Type methods
  getDungeonTypes(): Promise<DungeonType[]>;
  getDungeonTypeById(id: number): Promise<DungeonType | undefined>;
  getDungeonTypesByElement(elementalType: string): Promise<DungeonType[]>;
  getDungeonTypesByDifficulty(difficulty: string): Promise<DungeonType[]>;
  createDungeonType(dungeonType: InsertDungeonType): Promise<DungeonType>;
  updateDungeonType(id: number, updates: Partial<DungeonType>): Promise<DungeonType | undefined>;
  
  // Dungeon Run methods
  getDungeonRuns(userId: number): Promise<DungeonRun[]>;
  getDungeonRunById(id: number): Promise<DungeonRun | undefined>;
  createDungeonRun(run: InsertDungeonRun): Promise<DungeonRun>;
  updateDungeonRun(id: number, updates: Partial<DungeonRun>): Promise<DungeonRun | undefined>;
  
  // Forging Task methods
  getForgingTasks(userId: number): Promise<ForgingTask[]>;
  getForgingTaskById(id: number): Promise<ForgingTask | undefined>;
  createForgingTask(task: InsertForgingTask): Promise<ForgingTask>;
  updateForgingTask(id: number, updates: Partial<ForgingTask>): Promise<ForgingTask | undefined>;
  
  // Black Market methods
  getBlackMarketListings(userId?: number): Promise<BlackMarketListing[]>;
  getBlackMarketListingById(id: number): Promise<BlackMarketListing | undefined>;
  createBlackMarketListing(listing: InsertBlackMarketListing): Promise<BlackMarketListing>;
  updateBlackMarketListing(id: number, updates: Partial<BlackMarketListing>): Promise<BlackMarketListing | undefined>;
  deleteBlackMarketListing(id: number): Promise<boolean>;
  
  // Bounty Quest methods
  getBountyQuests(userId: number): Promise<BountyQuest[]>;
  getBountyQuestById(id: number): Promise<BountyQuest | undefined>;
  createBountyQuest(quest: InsertBountyQuest): Promise<BountyQuest>;
  updateBountyQuest(id: number, updates: Partial<BountyQuest>): Promise<BountyQuest | undefined>;
  
  // Building Upgrade methods
  getBuildingUpgrades(userId: number): Promise<BuildingUpgrade[]>;
  getBuildingUpgradeByTypeAndUserId(buildingType: string, userId: number): Promise<BuildingUpgrade | undefined>;
  createBuildingUpgrade(upgrade: InsertBuildingUpgrade): Promise<BuildingUpgrade>;
  updateBuildingUpgrade(id: number, updates: Partial<BuildingUpgrade>): Promise<BuildingUpgrade | undefined>;
  
  // Activity Log methods
  getActivityLogs(userId: number, limit?: number): Promise<ActivityLog[]>;
  createActivityLog(log: InsertActivityLog): Promise<ActivityLog>;
}

export class DatabaseStorage implements IStorage {
  async getUserById(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByDiscordId(discordId: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.discordId, discordId));
    return user;
  }

  async createUser(user: InsertUser): Promise<User> {
    const [newUser] = await db.insert(users).values(user).returning();
    return newUser;
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    const [updatedUser] = await db.update(users)
      .set(updates)
      .where(eq(users.id, id))
      .returning();
    return updatedUser;
  }

  async getCharacters(userId: number): Promise<Character[]> {
    return db.select().from(characters).where(eq(characters.userId, userId));
  }

  async getCharacterById(id: number): Promise<Character | undefined> {
    const [character] = await db.select().from(characters).where(eq(characters.id, id));
    return character;
  }

  async createCharacter(character: InsertCharacter): Promise<Character> {
    const [newCharacter] = await db.insert(characters).values(character).returning();
    return newCharacter;
  }

  async updateCharacter(id: number, updates: Partial<Character>): Promise<Character | undefined> {
    const [updatedCharacter] = await db.update(characters)
      .set(updates)
      .where(eq(characters.id, id))
      .returning();
    return updatedCharacter;
  }

  async deleteCharacter(id: number): Promise<boolean> {
    const result = await db.delete(characters).where(eq(characters.id, id));
    return !!result.rowCount;
  }
  
  async getActiveCharacterTasks(characterId: number): Promise<(FarmingTask | ForgingTask)[]> {
    // Get active farming tasks
    const activeFarmingTasks = await db.select()
      .from(farmingTasks)
      .where(
        and(
          eq(farmingTasks.characterId, characterId),
          eq(farmingTasks.completed, false)
        )
      );
    
    // Get active forging tasks
    const activeForgingTasks = await db.select()
      .from(forgingTasks)
      .where(
        and(
          eq(forgingTasks.characterId, characterId),
          eq(forgingTasks.completed, false)
        )
      );
    
    // Combine both task types
    return [...activeFarmingTasks, ...activeForgingTasks];
  }

  async getAuras(userId: number): Promise<Aura[]> {
    return db.select().from(auras).where(eq(auras.userId, userId));
  }

  async getAuraById(id: number): Promise<Aura | undefined> {
    const [aura] = await db.select().from(auras).where(eq(auras.id, id));
    return aura;
  }

  async createAura(aura: InsertAura): Promise<Aura> {
    const [newAura] = await db.insert(auras).values(aura).returning();
    return newAura;
  }

  async updateAura(id: number, updates: Partial<Aura>): Promise<Aura | undefined> {
    const [updatedAura] = await db.update(auras)
      .set(updates)
      .where(eq(auras.id, id))
      .returning();
    return updatedAura;
  }

  async deleteAura(id: number): Promise<boolean> {
    const result = await db.delete(auras).where(eq(auras.id, id));
    return !!result.rowCount;
  }
  
  async getCharacterAuras(characterId: number): Promise<Aura[]> {
    // Find the character first to get its userId
    const character = await this.getCharacterById(characterId);
    if (!character) {
      return [];
    }
    
    // Get all auras for this user that are equipped on this character
    return db.select()
      .from(auras)
      .where(
        and(
          eq(auras.userId, character.userId),
          eq(auras.equippedByCharacterId, characterId)
        )
      );
  }

  async getResources(userId: number): Promise<Resource[]> {
    return db.select().from(resources).where(eq(resources.userId, userId));
  }

  async getResourceByNameAndUserId(name: string, userId: number): Promise<Resource | undefined> {
    const [resource] = await db.select().from(resources)
      .where(and(eq(resources.name, name), eq(resources.userId, userId)));
    return resource;
  }

  async createResource(resource: InsertResource): Promise<Resource> {
    const [newResource] = await db.insert(resources).values(resource).returning();
    return newResource;
  }

  async updateResource(id: number, updates: Partial<Resource>): Promise<Resource | undefined> {
    const [updatedResource] = await db.update(resources)
      .set(updates)
      .where(eq(resources.id, id))
      .returning();
    return updatedResource;
  }

  async getFarmingTasks(userId: number): Promise<FarmingTask[]> {
    return db.select().from(farmingTasks).where(eq(farmingTasks.userId, userId));
  }

  async getFarmingTaskById(id: number): Promise<FarmingTask | undefined> {
    const [task] = await db.select().from(farmingTasks).where(eq(farmingTasks.id, id));
    return task;
  }

  async createFarmingTask(task: InsertFarmingTask): Promise<FarmingTask> {
    const [newTask] = await db.insert(farmingTasks).values(task).returning();
    return newTask;
  }

  async updateFarmingTask(id: number, updates: Partial<FarmingTask>): Promise<FarmingTask | undefined> {
    const [updatedTask] = await db.update(farmingTasks)
      .set(updates)
      .where(eq(farmingTasks.id, id))
      .returning();
    return updatedTask;
  }

  async deleteFarmingTask(id: number): Promise<boolean> {
    const result = await db.delete(farmingTasks).where(eq(farmingTasks.id, id));
    return !!result.rowCount;
  }

  async getDungeonTypes(): Promise<DungeonType[]> {
    return db.select().from(dungeonTypes);
  }

  async getDungeonTypeById(id: number): Promise<DungeonType | undefined> {
    const [dungeonType] = await db.select().from(dungeonTypes).where(eq(dungeonTypes.id, id));
    return dungeonType;
  }

  async getDungeonTypesByElement(elementalType: string): Promise<DungeonType[]> {
    return db.select().from(dungeonTypes).where(eq(dungeonTypes.elementalType, elementalType));
  }

  async getDungeonTypesByDifficulty(difficulty: string): Promise<DungeonType[]> {
    return db.select().from(dungeonTypes).where(eq(dungeonTypes.difficulty, difficulty));
  }

  async createDungeonType(dungeonType: InsertDungeonType): Promise<DungeonType> {
    const [newDungeonType] = await db.insert(dungeonTypes).values(dungeonType).returning();
    return newDungeonType;
  }

  async updateDungeonType(id: number, updates: Partial<DungeonType>): Promise<DungeonType | undefined> {
    const [updatedDungeonType] = await db.update(dungeonTypes)
      .set(updates)
      .where(eq(dungeonTypes.id, id))
      .returning();
    return updatedDungeonType;
  }

  async getDungeonRuns(userId: number): Promise<DungeonRun[]> {
    return db.select().from(dungeonRuns).where(eq(dungeonRuns.userId, userId));
  }

  async getDungeonRunById(id: number): Promise<DungeonRun | undefined> {
    const [run] = await db.select().from(dungeonRuns).where(eq(dungeonRuns.id, id));
    return run;
  }

  async createDungeonRun(run: InsertDungeonRun): Promise<DungeonRun> {
    const [newRun] = await db.insert(dungeonRuns).values(run).returning();
    return newRun;
  }

  async updateDungeonRun(id: number, updates: Partial<DungeonRun>): Promise<DungeonRun | undefined> {
    const [updatedRun] = await db.update(dungeonRuns)
      .set(updates)
      .where(eq(dungeonRuns.id, id))
      .returning();
    return updatedRun;
  }

  async getForgingTasks(userId: number): Promise<ForgingTask[]> {
    return db.select().from(forgingTasks).where(eq(forgingTasks.userId, userId));
  }

  async getForgingTaskById(id: number): Promise<ForgingTask | undefined> {
    const [task] = await db.select().from(forgingTasks).where(eq(forgingTasks.id, id));
    return task;
  }

  async createForgingTask(task: InsertForgingTask): Promise<ForgingTask> {
    const [newTask] = await db.insert(forgingTasks).values(task).returning();
    return newTask;
  }

  async updateForgingTask(id: number, updates: Partial<ForgingTask>): Promise<ForgingTask | undefined> {
    const [updatedTask] = await db.update(forgingTasks)
      .set(updates)
      .where(eq(forgingTasks.id, id))
      .returning();
    return updatedTask;
  }

  async getBlackMarketListings(userId?: number): Promise<BlackMarketListing[]> {
    if (userId) {
      return db.select().from(blackMarketListings).where(eq(blackMarketListings.userId, userId));
    }
    return db.select().from(blackMarketListings);
  }

  async getBlackMarketListingById(id: number): Promise<BlackMarketListing | undefined> {
    const [listing] = await db.select().from(blackMarketListings).where(eq(blackMarketListings.id, id));
    return listing;
  }

  async createBlackMarketListing(listing: InsertBlackMarketListing): Promise<BlackMarketListing> {
    const [newListing] = await db.insert(blackMarketListings).values(listing).returning();
    return newListing;
  }

  async updateBlackMarketListing(id: number, updates: Partial<BlackMarketListing>): Promise<BlackMarketListing | undefined> {
    const [updatedListing] = await db.update(blackMarketListings)
      .set(updates)
      .where(eq(blackMarketListings.id, id))
      .returning();
    return updatedListing;
  }

  async deleteBlackMarketListing(id: number): Promise<boolean> {
    const result = await db.delete(blackMarketListings).where(eq(blackMarketListings.id, id));
    return !!result.rowCount;
  }

  async getBountyQuests(userId: number): Promise<BountyQuest[]> {
    return db.select().from(bountyQuests).where(eq(bountyQuests.userId, userId));
  }

  async getBountyQuestById(id: number): Promise<BountyQuest | undefined> {
    const [quest] = await db.select().from(bountyQuests).where(eq(bountyQuests.id, id));
    return quest;
  }

  async createBountyQuest(quest: InsertBountyQuest): Promise<BountyQuest> {
    const [newQuest] = await db.insert(bountyQuests).values(quest).returning();
    return newQuest;
  }

  async updateBountyQuest(id: number, updates: Partial<BountyQuest>): Promise<BountyQuest | undefined> {
    const [updatedQuest] = await db.update(bountyQuests)
      .set(updates)
      .where(eq(bountyQuests.id, id))
      .returning();
    return updatedQuest;
  }

  async getBuildingUpgrades(userId: number): Promise<BuildingUpgrade[]> {
    return db.select().from(buildingUpgrades).where(eq(buildingUpgrades.userId, userId));
  }

  async getBuildingUpgradeByTypeAndUserId(buildingType: string, userId: number): Promise<BuildingUpgrade | undefined> {
    const [upgrade] = await db.select().from(buildingUpgrades)
      .where(and(eq(buildingUpgrades.buildingType, buildingType), eq(buildingUpgrades.userId, userId)));
    return upgrade;
  }

  async createBuildingUpgrade(upgrade: InsertBuildingUpgrade): Promise<BuildingUpgrade> {
    const [newUpgrade] = await db.insert(buildingUpgrades).values(upgrade).returning();
    return newUpgrade;
  }

  async updateBuildingUpgrade(id: number, updates: Partial<BuildingUpgrade>): Promise<BuildingUpgrade | undefined> {
    const [updatedUpgrade] = await db.update(buildingUpgrades)
      .set(updates)
      .where(eq(buildingUpgrades.id, id))
      .returning();
    return updatedUpgrade;
  }

  async getActivityLogs(userId: number, limit?: number): Promise<ActivityLog[]> {
    const baseQuery = db.select()
      .from(activityLogs)
      .where(eq(activityLogs.userId, userId))
      .orderBy(desc(activityLogs.timestamp));

    if (limit) {
      return baseQuery.limit(limit);
    }

    return baseQuery;
  }

  async createActivityLog(log: InsertActivityLog): Promise<ActivityLog> {
    const [newLog] = await db.insert(activityLogs).values(log).returning();
    return newLog;
  }

  // Building upgrade methods
  async getBuildingById(id: number): Promise<any | undefined> {
    // This is a placeholder implementation. In a real app, we would have a buildings table
    // For now, we'll return a mock building object
    return {
      id,
      name: 'Mock Building',
      level: 1,
      maxLevel: 5
    };
  }

  async upgradeBuilding(id: number): Promise<any> {
    // This is a placeholder implementation
    return {
      id,
      name: 'Mock Building',
      level: 2, // Incremented level
      maxLevel: 5
    };
  }

  // Building upgrades with skill paths
  async getBuildingUpgradesByUserId(userId: number): Promise<any | undefined> {
    try {
      // Get building upgrades from the metadata table
      const [existingData] = await db.select()
        .from(metadata)
        .where(and(
          eq(metadata.userId, userId),
          eq(metadata.key, 'building_upgrades')
        ));

      if (existingData && existingData.value) {
        return JSON.parse(existingData.value);
      }
      return undefined;
    } catch (error) {
      console.error('Error getting building upgrades:', error);
      return undefined;
    }
  }

  async createBuildingUpgrades(data: any): Promise<any> {
    try {
      // Store the building upgrades in the metadata table as JSON
      const [newData] = await db.insert(metadata)
        .values({
          userId: data.userId,
          key: 'building_upgrades',
          value: JSON.stringify(data)
        })
        .returning();

      return JSON.parse(newData.value);
    } catch (error) {
      console.error('Error creating building upgrades:', error);
      throw error;
    }
  }

  async updateBuildingUpgrades(userId: number, data: any): Promise<any> {
    try {
      // Update the existing building upgrades in the metadata table
      const [updatedData] = await db.update(metadata)
        .set({
          value: JSON.stringify(data)
        })
        .where(and(
          eq(metadata.userId, userId),
          eq(metadata.key, 'building_upgrades')
        ))
        .returning();

      if (!updatedData) {
        // If no records were updated, insert a new one
        return this.createBuildingUpgrades(data);
      }

      return JSON.parse(updatedData.value);
    } catch (error) {
      console.error('Error updating building upgrades:', error);
      throw error;
    }
  }
}

export const storage = new DatabaseStorage();

=== server/routes.ts ===
import type { Express, Request, Response, NextFunction } from "express";
import session from "express-session";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";
import { townhallSkillTree, hasBuildingPlans, consumeBuildingPlan } from './townhallSkills';
import { registerDungeonRoutes } from './dungeon-routes';
import {
  insertUserSchema,
  insertCharacterSchema,
  insertAuraSchema,
  insertResourceSchema,
  insertFarmingTaskSchema,
  insertDungeonRunSchema,
  insertForgingTaskSchema,
  insertBlackMarketListingSchema,
  insertBountyQuestSchema,
  insertBuildingUpgradeSchema,
  insertActivityLogSchema
} from "@shared/schema";

// Global speed boost settings for faster gameplay
const SPEED_BOOST_ACTIVE = true;
const SPEED_BOOST_MULTIPLIER = 10; // 10x speed

// Helper function to apply speed boost to durations
function applySpeedBoost(durationMs: number): number {
  if (SPEED_BOOST_ACTIVE) {
    return Math.floor(durationMs / SPEED_BOOST_MULTIPLIER);
  }
  return durationMs;
}

// Configure session middleware for authentication
const configureSession = (app: Express) => {
  app.use(session({
    secret: process.env.SESSION_SECRET || 'forge-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: { 
      secure: process.env.NODE_ENV === 'production',
      maxAge: 1000 * 60 * 60 * 24 // 24 hours
    }
  }));
};

// Authentication middleware
const authenticateUser = async (req: Request, res: Response, next: Function) => {
  if (!req.session.userId) {
    return res.status(401).json({ message: 'Unauthorized. Please log in.' });
  }
  
  const user = await storage.getUserById(req.session.userId);
  if (!user) {
    req.session.destroy(() => {});
    return res.status(401).json({ message: 'User not found. Please log in again.' });
  }
  
  next();
};

// Error handling middleware
const handleErrors = (err: any, req: Request, res: Response, next: Function) => {
  if (err instanceof ZodError) {
    const validationError = fromZodError(err);
    return res.status(400).json({ message: validationError.message });
  }
  
  console.error('Error:', err);
  res.status(500).json({ message: 'Internal server error' });
};

export async function registerRoutes(app: Express): Promise<Server> {
  configureSession(app);
  const httpServer = createServer(app);
  
  // WebSocket functionality temporarily removed to fix startup issues
  
  // Discord OAuth routes
  app.get('/api/auth/discord', (req, res) => {
    // In a real implementation, you would redirect to Discord OAuth
    // For this MVP, we'll simulate a successful login
    res.redirect('/api/auth/discord/callback?code=mock_code');
  });
  
  // Direct login route for development
  app.get('/api/auth/dev-login', async (req, res) => {
    try {
      console.log('Starting dev login process');
      
      // Define a default dev user
      const devUserId = 'dev123456';
      
      let user;
      
      // First try to find an existing user
      try {
        user = await storage.getUserByDiscordId(devUserId);
        console.log('User exists check result:', user ? 'Found existing user' : 'No user found, creating new one');
      } catch (findError) {
        console.error('Error checking for existing user:', findError);
        user = null;
      }
      
      if (!user) {
        try {
          // Create new dev user with fixed details
          const mockUser = {
            discordId: devUserId,
            username: 'DevUser',
            avatarUrl: 'https://cdn.pixabay.com/photo/2021/03/02/12/03/avatar-6062252_1280.png',
            roles: ['member'],
            forgeTokens: 5000,
            rogueCredits: 2000,
            soulShards: 25,
            lastLogin: new Date(),
            isAdmin: true
          };
          
          // Create new dev user
          user = await storage.createUser(mockUser);
          console.log('Created new dev user with ID:', user.id);
          
          // Create initial resources
          await storage.createResource({
            userId: user.id,
            name: 'Celestial Ore',
            type: 'material',
            quantity: 100,
            description: 'A rare material used in crafting Auras',
            iconUrl: 'https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop'
          });
          
          // Add more starter resources
          await storage.createResource({
            userId: user.id,
            name: 'Abyssal Pearl',
            type: 'material',
            quantity: 50,
            description: 'A rare material from the ocean depths',
            iconUrl: 'https://images.unsplash.com/photo-1576566588028-4147f3842f27?w=150&h=150&fit=crop'
          });
          
          // Create a starter character
          await storage.createCharacter({
            userId: user.id,
            name: 'Dragonslayer',
            class: 'Warrior',
            level: 15,
            attack: 25,
            defense: 30,
            vitality: 150,
            speed: 20,
            focus: 15,
            accuracy: 22,
            resilience: 28,
            avatarUrl: 'https://images.unsplash.com/photo-1580519542036-c47de6d5f458?w=250&h=250&fit=crop'
          });
          
          console.log('Created initial resources and starter character');
        } catch (createError) {
          console.error('Error creating dev user or starter content:', createError);
          return res.status(500).json({ 
            message: 'Dev login failed - Could not create user', 
            error: String(createError) 
          });
        }
      } else {
        console.log('Using existing dev user with ID:', user.id);
        
        // Update login time
        try {
          user = await storage.updateUser(user.id, { lastLogin: new Date() });
          console.log('Updated user login time');
        } catch (updateError) {
          console.error('Failed to update login time:', updateError);
          // Continue anyway as this is not critical
        }
      }
      
      if (!user || !user.id) {
        throw new Error('Failed to get a valid user object');
      }
      
      // Set session
      req.session.userId = user.id;
      console.log('Set session userId to:', user.id);
      
      // Redirect to client
      res.redirect('/?dev=true');
    } catch (error) {
      console.error('Dev login error:', error);
      res.status(500).json({ 
        message: 'Dev login failed', 
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  app.get('/api/auth/discord/callback', async (req, res) => {
    try {
      // Simulate getting user from Discord
      const mockDiscordUser = {
        id: '123456789',
        username: 'ForgeHero',
        avatar: 'https://cdn.pixabay.com/photo/2021/03/02/12/03/avatar-6062252_1280.png',
        roles: ['member']
      };
      
      console.log('In Discord callback route with mock user:', mockDiscordUser);
      
      // Declare the user variable outside the try/catch block so it's accessible throughout the function
      let userData = null;
      
      try {
        // Check if user exists
        userData = await storage.getUserByDiscordId(mockDiscordUser.id);
        console.log('Retrieved user from database:', userData ? 'User found' : 'User not found');
        
        if (!userData) {
          // Create new user
          console.log('Creating new user');
          userData = await storage.createUser({
            discordId: mockDiscordUser.id,
            username: mockDiscordUser.username,
            avatarUrl: mockDiscordUser.avatar,
            roles: mockDiscordUser.roles,
            forgeTokens: 6200,
            rogueCredits: 2450,
            soulShards: 34,
            lastLogin: new Date(),
            isAdmin: false // Explicitly set isAdmin field for new users
          });
          console.log('New user created with ID:', userData.id);
          
          // Create initial resources for new user
          await storage.createResource({
            userId: userData.id,
            name: 'Celestial Ore',
            type: 'material',
            quantity: 156,
            description: 'A rare material used in crafting Auras',
            iconUrl: 'https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop'
          });
          console.log('Initial resources created for new user');
        } else {
          // Update existing user's login time
          console.log('Updating existing user login time, ID:', userData.id);
          userData = await storage.updateUser(userData.id, { lastLogin: new Date() });
        }
      } catch (dbError) {
        console.error('Database error during user lookup/creation:', dbError);
        // Create a temporary user to continue with the auth flow for debugging
        const tempUser = {
          id: 1,
          discordId: mockDiscordUser.id,
          username: mockDiscordUser.username,
          avatarUrl: mockDiscordUser.avatar,
          roles: mockDiscordUser.roles,
          lastLogin: new Date(),
          forgeTokens: 1000,
          rogueCredits: 500,
          soulShards: 10,
          isAdmin: true
        };
        console.log('Created temporary user for debugging:', tempUser);
        
        // Set session with temp user
        req.session.userId = tempUser.id;
        return res.redirect('/?debug=true');
      }
      
      // If we get here, we should check the userData object
      if (!userData || !userData.id) {
        return res.status(500).json({ message: 'Failed to create or retrieve user' });
      }
      
      // Set session
      req.session.userId = userData.id;
      console.log('Setting session userId to:', userData.id);
      
      // Redirect to client
      res.redirect('/');
    } catch (error) {
      console.error('Auth error:', error);
      res.status(500).json({ message: 'Authentication failed' });
    }
  });
  
  app.get('/api/auth/logout', (req, res) => {
    req.session.destroy(() => {
      res.redirect('/');
    });
  });
  
  app.get('/api/auth/user', async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: 'Not authenticated' });
    }
    
    try {
      const user = await storage.getUserById(req.session.userId);
      if (!user) {
        req.session.destroy(() => {});
        return res.status(401).json({ message: 'User not found' });
      }
      
      return res.json(user);
    } catch (error) {
      console.error('Error fetching user:', error);
      res.status(500).json({ message: 'Failed to fetch user data' });
    }
  });
  
  // Character routes
  app.get('/api/characters', authenticateUser, async (req, res) => {
    try {
      const characters = await storage.getCharacters(req.session.userId!);
      res.json(characters);
    } catch (error) {
      console.error('Error fetching characters:', error);
      res.status(500).json({ message: 'Failed to fetch characters' });
    }
  });
  
  app.post('/api/characters', authenticateUser, async (req, res) => {
    try {
      const characterData = insertCharacterSchema.parse({
        ...req.body,
        userId: req.session.userId
      });
      
      const character = await storage.createCharacter(characterData);
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'character_created',
        description: `Added new character: ${character.name}`,
        relatedIds: { characterId: character.id }
      });
      
      res.status(201).json(character);
    } catch (error) {
      handleErrors(error, req, res, () => {});
    }
  });
  
  // Character level-up route
  app.post('/api/characters/:id/level-up', authenticateUser, async (req, res) => {
    try {
      const characterId = parseInt(req.params.id);
      const { levelIncrease = 1 } = req.body;
      
      // Get the character
      const character = await storage.getCharacterById(characterId);
      
      if (!character) {
        return res.status(404).json({ message: 'Character not found' });
      }
      
      if (character.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to level up this character' });
      }
      
      // Calculate new level
      const currentLevel = character.level || 1;
      const newLevel = currentLevel + levelIncrease;
      
      // Update character level and stats
      const updatedCharacter = await storage.updateCharacter(characterId, {
        level: newLevel,
        // Increase stats proportionally (approximately 3-5% per level)
        attack: Math.floor((character.attack || 10) * (1 + 0.04 * levelIncrease)),
        defense: Math.floor((character.defense || 10) * (1 + 0.04 * levelIncrease)),
        vitality: Math.floor((character.vitality || 100) * (1 + 0.03 * levelIncrease)),
        speed: Math.floor((character.speed || 10) * (1 + 0.05 * levelIncrease)),
        focus: Math.floor((character.focus || 10) * (1 + 0.04 * levelIncrease)),
        accuracy: Math.floor((character.accuracy || 10) * (1 + 0.03 * levelIncrease)),
        resilience: Math.floor((character.resilience || 10) * (1 + 0.03 * levelIncrease))
      });
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'character_leveled',
        description: `${character.name} reached level ${newLevel}`,
        relatedIds: { characterId }
      });
      
      res.json(updatedCharacter);
    } catch (error) {
      console.error('Error leveling up character:', error);
      res.status(500).json({ message: 'Failed to level up character' });
    }
  });
  
  // Aura routes
  app.get('/api/auras', authenticateUser, async (req, res) => {
    try {
      const auras = await storage.getAuras(req.session.userId!);
      res.json(auras);
    } catch (error) {
      console.error('Error fetching auras:', error);
      res.status(500).json({ message: 'Failed to fetch auras' });
    }
  });
  
  app.post('/api/auras', authenticateUser, async (req, res) => {
    try {
      const auraData = insertAuraSchema.parse({
        ...req.body,
        userId: req.session.userId
      });
      
      const aura = await storage.createAura(auraData);
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'aura_created',
        description: `Created new ${aura.element} Aura: ${aura.name}`,
        relatedIds: { auraId: aura.id }
      });
      
      res.status(201).json(aura);
    } catch (error) {
      handleErrors(error, req, res, () => {});
    }
  });
  
  app.get('/api/auras/:id', authenticateUser, async (req, res) => {
    try {
      const auraId = parseInt(req.params.id);
      const aura = await storage.getAuraById(auraId);
      
      if (!aura) {
        return res.status(404).json({ message: 'Aura not found' });
      }
      
      if (aura.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to access this aura' });
      }
      
      res.json(aura);
    } catch (error) {
      console.error('Error fetching aura:', error);
      res.status(500).json({ message: 'Failed to fetch aura' });
    }
  });
  
  // Equip Aura to Character endpoint
  app.post('/api/characters/:characterId/equip-aura/:auraId', authenticateUser, async (req, res) => {
    try {
      const characterId = parseInt(req.params.characterId);
      const auraId = parseInt(req.params.auraId);
      
      // Check if character and aura exist and belong to the user
      const character = await storage.getCharacterById(characterId);
      const aura = await storage.getAuraById(auraId);
      
      if (!character || !aura) {
        return res.status(404).json({ message: 'Character or Aura not found' });
      }
      
      if (character.userId !== req.session.userId || aura.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to use this character or aura' });
      }
      
      if (character.isActive) {
        return res.status(400).json({ message: 'Cannot equip aura to an active character' });
      }
      
      if (aura.isFusing) {
        return res.status(400).json({ message: 'Cannot equip an aura that is currently fusing' });
      }
      
      if (aura.equippedByCharacterId) {
        return res.status(400).json({ message: 'Aura is already equipped by another character' });
      }
      
      // If character already has an aura, unequip it first
      if (character.equippedAuraId) {
        const oldAura = await storage.getAuraById(character.equippedAuraId);
        if (oldAura) {
          await storage.updateAura(oldAura.id, { equippedByCharacterId: null });
        }
      }
      
      // Update character with new aura
      await storage.updateCharacter(characterId, { equippedAuraId: auraId });
      
      // Update aura with character reference
      await storage.updateAura(auraId, { equippedByCharacterId: characterId });
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'aura_equipped',
        description: `Equipped ${aura.name} to ${character.name}`,
        relatedIds: { characterId, auraId }
      });
      
      res.json({ success: true, message: 'Aura equipped successfully' });
    } catch (error) {
      console.error('Error equipping aura:', error);
      res.status(500).json({ message: 'Failed to equip aura' });
    }
  });
  
  // Resource routes
  app.get('/api/resources', authenticateUser, async (req, res) => {
    try {
      const resources = await storage.getResources(req.session.userId!);
      res.json(resources);
    } catch (error) {
      console.error('Error fetching resources:', error);
      res.status(500).json({ message: 'Failed to fetch resources' });
    }
  });
  
  // Update resource - administrative endpoint
  app.post('/api/resources/update', authenticateUser, async (req, res) => {
    try {
      const { resourceName, amount } = req.body;
      
      if (!resourceName || typeof amount !== 'number') {
        return res.status(400).json({ message: 'Resource name and amount are required' });
      }
      
      // Find the resource
      let resource = await storage.getResourceByNameAndUserId(resourceName, req.session.userId!);
      
      // If resource doesn't exist, create it
      if (!resource) {
        resource = await storage.createResource({
          userId: req.session.userId!,
          name: resourceName,
          description: `${resourceName} resource`,
          quantity: amount,
          type: 'material'
        });
      } else {
        // Update existing resource
        resource = await storage.updateResource(resource.id, {
          quantity: resource.quantity + amount
        });
      }
      
      res.json(resource);
    } catch (error) {
      console.error('Error updating resource:', error);
      res.status(500).json({ message: 'Failed to update resource' });
    }
  });
  
  // Farming routes
  app.get('/api/farming/tasks', authenticateUser, async (req, res) => {
    try {
      const tasks = await storage.getFarmingTasks(req.session.userId!);
      res.json(tasks);
    } catch (error) {
      console.error('Error fetching farming tasks:', error);
      res.status(500).json({ message: 'Failed to fetch farming tasks' });
    }
  });
  
  app.post('/api/farming/tasks', authenticateUser, async (req, res) => {
    try {
      console.log('Farming task request body:', JSON.stringify(req.body));
      
      // If endTime is provided as an ISO string, convert it to Date
      let processedBody = {...req.body};
      if (typeof processedBody.endTime === 'string') {
        try {
          processedBody.endTime = new Date(processedBody.endTime);
          console.log('Converted farming endTime to Date object');
        } catch (e) {
          console.error('Failed to convert farming endTime string to Date:', e);
        }
      }
      
      // Apply speed boost to farming task duration
      if (processedBody.endTime) {
        const farmStartTime = new Date();
        const farmDuration = new Date(processedBody.endTime).getTime() - farmStartTime.getTime();
        const boostedDuration = applySpeedBoost(farmDuration);
        const boostedEndTime = new Date(farmStartTime.getTime() + boostedDuration);
        console.log(`Applied speed boost: Original farm duration ${farmDuration}ms, boosted ${boostedDuration}ms`);
        processedBody.endTime = boostedEndTime;
      }
      
      const taskData = insertFarmingTaskSchema.parse({
        ...processedBody,
        userId: req.session.userId
      });
      
      console.log('Parsed farming task data:', JSON.stringify(taskData));
      
      // Check if character is available
      const character = await storage.getCharacterById(taskData.characterId);
      if (!character) {
        return res.status(404).json({ message: 'Character not found' });
      }
      
      if (character.isActive) {
        return res.status(400).json({ message: 'Character is already active in another task' });
      }
      
      // Characters must have an aura equipped to start farming
      if (!character.equippedAuraId) {
        return res.status(400).json({ message: 'Character must have an aura equipped to start farming' });
      }
      
      // Mark character as active in farming
      await storage.updateCharacter(character.id, {
        isActive: true,
        activityType: 'farming',
        activityEndTime: taskData.endTime
      });
      
      const task = await storage.createFarmingTask(taskData);
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'farming_started',
        description: `Started farming ${task.resourceName}`,
        relatedIds: { characterId: character.id, taskId: task.id }
      });
      
      console.log('Farming task created successfully:', task.id);
      res.status(201).json(task);
    } catch (error) {
      console.error('Error starting farming task:', error);
      handleErrors(error, req, res, () => {});
    }
  });
  
  app.post('/api/farming/complete/:id', authenticateUser, async (req, res) => {
    try {
      const taskId = parseInt(req.params.id);
      const task = await storage.getFarmingTaskById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Farming task not found' });
      }
      
      if (task.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to access this task' });
      }
      
      if (task.completed) {
        return res.status(400).json({ message: 'Task already completed' });
      }
      
      // Mark task as completed
      await storage.updateFarmingTask(taskId, { completed: true });
      
      // Free up the character
      await storage.updateCharacter(task.characterId, {
        isActive: false,
        activityType: null,
        activityEndTime: null
      });
      
      // Add resources to user inventory
      const resource = await storage.getResourceByNameAndUserId(task.resourceName, req.session.userId!);
      
      if (resource) {
        // Random amount between 10-30
        const gainedAmount = Math.floor(Math.random() * 21) + 10;
        await storage.updateResource(resource.id, { quantity: resource.quantity + gainedAmount });
        
        // Log activity
        await storage.createActivityLog({
          userId: req.session.userId!,
          activityType: 'farming_completed',
          description: `Completed farming and gained ${gainedAmount} ${task.resourceName}`,
          relatedIds: { characterId: task.characterId, taskId: task.id }
        });
        
        return res.json({
          success: true,
          resource: task.resourceName,
          amount: gainedAmount
        });
      } else {
        // Create new resource if it doesn't exist
        const gainedAmount = Math.floor(Math.random() * 21) + 10;
        await storage.createResource({
          userId: req.session.userId!,
          name: task.resourceName,
          type: 'material',
          quantity: gainedAmount,
          description: `A material obtained from farming`,
          iconUrl: 'https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop'
        });
        
        return res.json({
          success: true,
          resource: task.resourceName,
          amount: gainedAmount
        });
      }
    } catch (error) {
      console.error('Error completing farming task:', error);
      res.status(500).json({ message: 'Failed to complete farming task' });
    }
  });
  
  // Dungeon routes
  app.get('/api/dungeons/types', authenticateUser, async (req, res) => {
    try {
      let dungeonTypes;
      const { element, difficulty } = req.query;
      
      if (element) {
        dungeonTypes = await storage.getDungeonTypesByElement(element as string);
      } else if (difficulty) {
        dungeonTypes = await storage.getDungeonTypesByDifficulty(difficulty as string);
      } else {
        dungeonTypes = await storage.getDungeonTypes();
      }
      
      res.json(dungeonTypes);
    } catch (error) {
      console.error('Error fetching dungeon types:', error);
      res.status(500).json({ message: 'Failed to fetch dungeon types' });
    }
  });

  app.get('/api/dungeons/types/:id', authenticateUser, async (req, res) => {
    try {
      const dungeonType = await storage.getDungeonTypeById(parseInt(req.params.id));
      
      if (!dungeonType) {
        return res.status(404).json({ message: 'Dungeon type not found' });
      }
      
      res.json(dungeonType);
    } catch (error) {
      console.error('Error fetching dungeon type:', error);
      res.status(500).json({ message: 'Failed to fetch dungeon type' });
    }
  });
  
  app.post('/api/dungeons/types', authenticateUser, async (req, res) => {
    try {
      // Only admins can create dungeon types
      const user = await storage.getUserById(req.session.userId!);
      if (!user?.isAdmin) {
        return res.status(403).json({ message: 'Unauthorized to create dungeon types' });
      }
      
      const dungeonType = await storage.createDungeonType(req.body);
      res.status(201).json(dungeonType);
    } catch (error) {
      console.error('Error creating dungeon type:', error);
      res.status(500).json({ message: 'Failed to create dungeon type' });
    }
  });
  
  app.patch('/api/dungeons/types/:id', authenticateUser, async (req, res) => {
    try {
      // Only admins can update dungeon types
      const user = await storage.getUserById(req.session.userId!);
      if (!user?.isAdmin) {
        return res.status(403).json({ message: 'Unauthorized to update dungeon types' });
      }
      
      const dungeonType = await storage.updateDungeonType(parseInt(req.params.id), req.body);
      
      if (!dungeonType) {
        return res.status(404).json({ message: 'Dungeon type not found' });
      }
      
      res.json(dungeonType);
    } catch (error) {
      console.error('Error updating dungeon type:', error);
      res.status(500).json({ message: 'Failed to update dungeon type' });
    }
  });

  app.get('/api/dungeons/runs', authenticateUser, async (req, res) => {
    try {
      const runs = await storage.getDungeonRuns(req.session.userId!);
      res.json(runs);
    } catch (error) {
      console.error('Error fetching dungeon runs:', error);
      res.status(500).json({ message: 'Failed to fetch dungeon runs' });
    }
  });
  
  app.post('/api/dungeons/start', authenticateUser, async (req, res) => {
    try {
      // Convert the endTime string to a Date object if it's a string
      let endTimeData = req.body.endTime;
      if (typeof endTimeData === 'string') {
        endTimeData = new Date(endTimeData);
        console.log('Converted dungeon endTime to Date object');
      }
      
      // Apply speed boost to dungeon run time if needed
      // We need to preserve the original end time from client but boost it server-side
      const dungeonEndTime = new Date();
      const duration = new Date(endTimeData).getTime() - dungeonEndTime.getTime();
      const boostedDuration = applySpeedBoost(duration);
      const boostedEndTime = new Date(dungeonEndTime.getTime() + boostedDuration);
      console.log(`Applied speed boost: Original duration ${duration}ms, boosted ${boostedDuration}ms`);
      endTimeData = boostedEndTime;
      
      const runData = insertDungeonRunSchema.parse({
        ...req.body,
        userId: req.session.userId,
        startTime: new Date(),
        endTime: endTimeData,
        completed: false
      });
      
      // Check if all characters are available
      for (const charId of runData.characterIds) {
        const character = await storage.getCharacterById(charId);
        if (!character) {
          return res.status(404).json({ message: `Character ${charId} not found` });
        }
        
        if (character.isActive) {
          return res.status(400).json({
            message: `Character ${character.name} is already active in another task`
          });
        }
        
        // Check if character has an aura equipped
        if (!character.equippedAuraId) {
          return res.status(400).json({ 
            message: `Character ${character.name} must have an aura equipped to enter dungeons` 
          });
        }
      }
      
      // Mark all characters as active
      for (const charId of runData.characterIds) {
        await storage.updateCharacter(charId, {
          isActive: true,
          activityType: 'dungeon',
          activityEndTime: runData.endTime
        });
      }
      
      const run = await storage.createDungeonRun(runData);
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'dungeon_started',
        description: `Started dungeon: ${run.dungeonName} (Level ${run.dungeonLevel})`,
        relatedIds: { runId: run.id, characterIds: runData.characterIds }
      });
      
      res.status(201).json(run);
    } catch (error) {
      handleErrors(error, req, res, () => {});
    }
  });
  
  app.post('/api/dungeons/complete/:id', authenticateUser, async (req, res) => {
    try {
      const runId = parseInt(req.params.id);
      const run = await storage.getDungeonRunById(runId);
      
      if (!run) {
        return res.status(404).json({ message: 'Dungeon run not found' });
      }
      
      if (run.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to access this run' });
      }
      
      if (run.completed) {
        return res.status(400).json({ message: 'Run already completed' });
      }
      
      // Determine success (70% chance for simplicity)
      const success = Math.random() < 0.7;
      
      // Note: Using the imported dungeon-routes module for processing
      // This is a fallback that should never be called in practice
      const battleLog = [{ 
        type: 'system_message', 
        timestamp: Date.now(), 
        message: 'Dungeon run processing has been moved to the dungeon-routes module. Please use the new APIs.'
      }];
      
      // Generate rewards if successful
      let rewards = null;
      if (success) {
        rewards = {
          rogueCredits: Math.floor(Math.random() * 101) + 50,
          soulShards: Math.floor(Math.random() * 3) + 1,
          materials: [
            { name: 'Celestial Ore', amount: Math.floor(Math.random() * 11) + 5 }
          ]
        };
        
        // Update user resources
        const user = await storage.getUserById(req.session.userId!);
        if (user) {
          await storage.updateUser(user.id, {
            rogueCredits: user.rogueCredits + rewards.rogueCredits,
            soulShards: user.soulShards + rewards.soulShards
          });
        }
        
        // Update material resources
        for (const material of rewards.materials) {
          const resource = await storage.getResourceByNameAndUserId(material.name, req.session.userId!);
          if (resource) {
            await storage.updateResource(resource.id, {
              quantity: resource.quantity + material.amount
            });
          } else {
            await storage.createResource({
              userId: req.session.userId!,
              name: material.name,
              type: 'material',
              quantity: material.amount,
              description: 'A valuable material found in dungeons',
              iconUrl: 'https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop'
            });
          }
        }
      }
      
      // Mark run as completed
      await storage.updateDungeonRun(runId, {
        completed: true,
        success,
        battleLog,
        rewards
      });
      
      // Free up the characters
      for (const charId of run.characterIds) {
        await storage.updateCharacter(charId, {
          isActive: false,
          activityType: null,
          activityEndTime: null
        });
      }
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'dungeon_completed',
        description: `${success ? 'Successfully' : 'Failed to'} complete dungeon: ${run.dungeonName}`,
        relatedIds: { runId: run.id }
      });
      
      // CRITICAL FIX: Sanitize battle log to ensure all units have full health at battle start
      // This is our final safeguard before sending data to the client
      const sanitizedBattleLog = battleLog.map(entry => {
        // Only process battle_start events which contain unit data
        if (entry.type === 'battle_start') {
          // Ensure all allies have proper HP values (not 0 or less)
          if (entry.allies && Array.isArray(entry.allies)) {
            entry.allies = entry.allies.map(ally => {
              // If HP is 0 or invalid, set it to maxHp
              if (!ally.hp || ally.hp <= 0) {
                console.warn(`API Response Fix: Correcting ally ${ally.name} with invalid HP (${ally.hp}) to ${ally.maxHp}`);
                return { ...ally, hp: ally.maxHp };
              }
              return ally;
            });
          }
          
          // Ensure all enemies have proper HP values (not 0 or less)
          if (entry.enemies && Array.isArray(entry.enemies)) {
            entry.enemies = entry.enemies.map(enemy => {
              // If HP is 0 or invalid, set it to maxHp
              if (!enemy.hp || enemy.hp <= 0) {
                console.warn(`API Response Fix: Correcting enemy ${enemy.name} with invalid HP (${enemy.hp}) to ${enemy.maxHp}`);
                return { ...enemy, hp: enemy.maxHp };
              }
              return enemy;
            });
          }
        }
        
        return entry;
      });
      
      console.log('Sanitized battle log to ensure proper health values before sending to client');
      
      res.json({
        success,
        battleLog: sanitizedBattleLog,
        rewards
      });
    } catch (error) {
      console.error('Error completing dungeon run:', error);
      res.status(500).json({ message: 'Failed to complete dungeon run' });
    }
  });
  
  // Forge routes
  app.get('/api/forge/tasks', authenticateUser, async (req, res) => {
    try {
      const tasks = await storage.getForgingTasks(req.session.userId!);
      res.json(tasks);
    } catch (error) {
      console.error('Error fetching forging tasks:', error);
      res.status(500).json({ message: 'Failed to fetch forging tasks' });
    }
  });
  
  app.post('/api/forge/craft', authenticateUser, async (req, res) => {
    try {
      console.log('Forge craft request body:', JSON.stringify(req.body));
      
      // Validate character selection
      const characterId = req.body.characterId;
      if (!characterId) {
        return res.status(400).json({ message: 'Character ID is required for crafting' });
      }
      
      // Check if character exists and belongs to the user
      const character = await storage.getCharacterById(characterId);
      if (!character || character.userId !== req.session.userId) {
        return res.status(404).json({ message: 'Character not found or not owned by you' });
      }
      
      // Check if character is available (not assigned to another task)
      const activeCharacterTasks = await storage.getActiveCharacterTasks(characterId);
      if (activeCharacterTasks.length > 0) {
        return res.status(400).json({ message: 'Character is already assigned to another task' });
      }
      
      // If endTime is provided as an ISO string, convert it to Date
      let processedBody = {...req.body};
      if (typeof processedBody.endTime === 'string') {
        try {
          processedBody.endTime = new Date(processedBody.endTime);
          console.log('Converted endTime to Date object');
        } catch (e) {
          console.error('Failed to convert endTime string to Date:', e);
        }
      }
      
      // Apply speed boost to crafting duration
      if (processedBody.endTime) {
        const craftStartTime = new Date();
        const craftDuration = new Date(processedBody.endTime).getTime() - craftStartTime.getTime();
        const boostedDuration = applySpeedBoost(craftDuration);
        const boostedEndTime = new Date(craftStartTime.getTime() + boostedDuration);
        console.log(`Applied speed boost: Original craft duration ${craftDuration}ms, boosted ${boostedDuration}ms`);
        processedBody.endTime = boostedEndTime;
      }
      
      const taskData = insertForgingTaskSchema.parse({
        ...processedBody,
        userId: req.session.userId,
        taskType: 'craft',
        startTime: new Date(),
        completed: false
      });
      
      console.log('Parsed task data:', JSON.stringify(taskData));
      
      // Verify user has the required materials
      if (taskData.requiredMaterials) {
        for (const [materialName, amount] of Object.entries(taskData.requiredMaterials)) {
          const resource = await storage.getResourceByNameAndUserId(materialName, req.session.userId!);
          if (!resource || resource.quantity < amount) {
            return res.status(400).json({
              message: `Insufficient ${materialName} for crafting`
            });
          }
          
          // Subtract materials
          await storage.updateResource(resource.id, {
            quantity: resource.quantity - amount
          });
        }
      }
      
      const task = await storage.createForgingTask(taskData);
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'aura_crafting_started',
        description: `Started crafting a ${taskData.targetElement} Aura`,
        relatedIds: { taskId: task.id }
      });
      
      console.log('Forge task created successfully:', task.id);
      res.status(201).json(task);
    } catch (error) {
      console.error('Error in forge/craft endpoint:', error);
      handleErrors(error, req, res, () => {});
    }
  });
  
  app.post('/api/forge/fusion', authenticateUser, async (req, res) => {
    try {
      const { primaryAuraId, secondaryAuraId } = req.body;
      
      // Check if auras exist and belong to the user
      const primaryAura = await storage.getAuraById(primaryAuraId);
      const secondaryAura = await storage.getAuraById(secondaryAuraId);
      
      if (!primaryAura || !secondaryAura) {
        return res.status(404).json({ message: 'One or both auras not found' });
      }
      
      if (primaryAura.userId !== req.session.userId || secondaryAura.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to use these auras' });
      }
      
      if (primaryAura.isFusing || secondaryAura.isFusing) {
        return res.status(400).json({ message: 'One or both auras are already in fusion' });
      }
      
      // Mark auras as fusing
      const fusionDuration = 60 * 1000; // 1 minute for demo
      const fusionEndTime = new Date(Date.now() + applySpeedBoost(fusionDuration)); // Apply speed boost
      await storage.updateAura(primaryAuraId, {
        isFusing: true,
        fusionEndTime
      });
      
      await storage.updateAura(secondaryAuraId, {
        isFusing: true,
        fusionEndTime
      });
      
      // Create fusion task
      const characterId = req.body.characterId;
      if (!characterId) {
        return res.status(400).json({ message: 'Character ID is required for fusion' });
      }
      
      // Check if character exists and belongs to the user
      const character = await storage.getCharacterById(characterId);
      if (!character || character.userId !== req.session.userId) {
        return res.status(404).json({ message: 'Character not found or not owned by you' });
      }
      
      // Check if character is available (not assigned to another task)
      const activeCharacterTasks = await storage.getActiveCharacterTasks(characterId);
      if (activeCharacterTasks.length > 0) {
        return res.status(400).json({ message: 'Character is already assigned to another task' });
      }
      
      const taskData = {
        userId: req.session.userId!,
        characterId: characterId,
        taskType: 'fusion',
        primaryAuraId,
        secondaryAuraId,
        startTime: new Date(),
        endTime: fusionEndTime,
        completed: false
      };
      
      const task = await storage.createForgingTask(taskData);
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'aura_fusion_started',
        description: `Started fusing ${primaryAura.name} with ${secondaryAura.name}`,
        relatedIds: { taskId: task.id, auraIds: [primaryAuraId, secondaryAuraId] }
      });
      
      res.status(201).json(task);
    } catch (error) {
      console.error('Error starting fusion:', error);
      res.status(500).json({ message: 'Failed to start fusion process' });
    }
  });
  
  app.post('/api/forge/complete/:id', authenticateUser, async (req, res) => {
    try {
      const taskId = parseInt(req.params.id);
      const task = await storage.getForgingTaskById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Forging task not found' });
      }
      
      if (task.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to access this task' });
      }
      
      if (task.completed) {
        return res.status(400).json({ message: 'Task already completed' });
      }
      
      // Different logic based on task type
      if (task.taskType === 'craft') {
        // Create new aura with stat bonuses ranging from -10% to +10%
        // Generate a value between -10 and +10 for each stat
        const generateStatBonus = () => Math.floor(Math.random() * 21) - 10; // -10 to +10
        
        // Default element if not specified (fire, water, earth, wind)
        const elementType = task.targetElement || ['fire', 'water', 'earth', 'wind'][Math.floor(Math.random() * 4)];
        
        // Get aura name based on element
        let auraName = '';
        switch(elementType) {
          case 'fire': 
            auraName = 'Inferno\'s Embrace';
            break;
          case 'water': 
            auraName = 'Ocean\'s Mercy';
            break;
          case 'earth': 
            auraName = 'Stoneguard\'s Pact';
            break;
          case 'wind': 
            auraName = 'Zephyr\'s Whisper';
            break;
          default:
            auraName = `${elementType.charAt(0).toUpperCase() + elementType.slice(1)} Aura`;
        }
        
        // Generate skills for the aura based on element
        // 50% chance of getting either basic skill for the element
        const skills = [];
        
        // Define the basic skills for each element
        const elementSkills = {
          fire: [
            {
              name: "Ember",
              type: "Basic",
              description: "A focused burst of flame latches onto the target, searing over time.",
              damage: 1.0,
              level: 1,
              effect: "10% chance to apply 1 Burn Stack for 1 Turn",
              targets: 1
            },
            {
              name: "Wildfire",
              type: "Basic",
              description: "Unpredictable flames leap across the battlefield in violent bursts.",
              damage: 0.8,
              level: 1,
              effect: "10% chance to hit 1 more target",
              targets: "2-3 Random"
            }
          ],
          water: [
            {
              name: "Soothing Current",
              type: "Basic",
              description: "A soft wave crashes through the enemy and flows into an ally.",
              damage: 0.8,
              level: 1,
              healing: 5,
              healTargetType: "lowest",
              logic: "0.8x Damage to 1 Target and Heal the lowest HP Ally for 5% of the Caster's Max Health",
              targets: 1
            },
            {
              name: "Cleansing Tide",
              type: "Basic",
              description: "Water surges over the battlefield, sweeping away ailing effects.",
              damage: 0.7,
              level: 1,
              effect: "10% chance to remove 1 Debuff from a Random Ally",
              targets: 1
            }
          ],
          earth: [
            {
              name: "Stone Slam",
              type: "Basic",
              description: "A hammering blow backed by earth essence dulls the target's edge.",
              damage: 1.0,
              level: 1,
              effect: "20% chance to apply Weakness (-10% Damage Dealt) for 1 Turn",
              targets: 1
            },
            {
              name: "Dust Spikes",
              type: "Basic",
              description: "Fragments of stone erupt from the ground and scatter outward.",
              damage: 0.9,
              level: 1,
              effect: "No special effect at Level 1",
              targets: "2 Random"
            }
          ],
          wind: [
            {
              name: "Gust",
              type: "Basic",
              description: "A sharp burst of wind knocks the enemy off balance.",
              damage: 0.8,
              level: 1,
              effect: "10% chance to apply Minor Slow (Speed -20%) for 1 Turn",
              targets: 1
            },
            {
              name: "Breeze",
              type: "Basic",
              description: "A disruptive current slips beneath the target, breaking their momentum.",
              damage: 0.7,
              level: 1,
              effect: "10% chance to reduce Turn Meter by 10%",
              targets: 1
            }
          ]
        };
        
        // 50% chance to get either skill, but only add ONE skill (not both)
        const skillIndex = Math.random() < 0.5 ? 0 : 1;
        // Use type assertion to handle the element type safely
        const elementTypeSafe = elementType as keyof typeof elementSkills;
        if (elementSkills[elementTypeSafe]) {
          // Only add one skill to the array (replacing any existing skills)
          skills[0] = elementSkills[elementTypeSafe][skillIndex];
        }
        
        const newAura = await storage.createAura({
          userId: req.session.userId!,
          name: auraName,
          level: 1,
          element: elementType,
          tier: 1,
          // Add stat bonuses in the range of -10% to +10%
          attack: generateStatBonus(),
          defense: generateStatBonus(),
          vitality: generateStatBonus(),
          speed: generateStatBonus(),
          focus: generateStatBonus(),
          resilience: generateStatBonus(), 
          accuracy: generateStatBonus(),
          fusionSource: false,
          creatorCharacterId: task.characterId,
          skills: skills
        });
        
        // Update task
        await storage.updateForgingTask(taskId, {
          completed: true,
          resultAuraId: newAura.id
        });
        
        // Free up the character
        if (task.characterId) {
          await storage.updateCharacter(task.characterId, {
            isActive: false,
            activityType: null,
            activityEndTime: null
          });
          
          const character = await storage.getCharacterById(task.characterId);
          if (character) {
            await storage.createActivityLog({
              userId: req.session.userId!,
              activityType: 'character_task_completed',
              description: `${character.name} has completed crafting a new aura`,
              relatedIds: { characterId: character.id, auraId: newAura.id }
            });
          }
        }
        
        // Log activity
        await storage.createActivityLog({
          userId: req.session.userId!,
          activityType: 'aura_crafted',
          description: `Crafted a new ${newAura.element} Aura (Level ${newAura.level})`,
          relatedIds: { auraId: newAura.id }
        });
        
        return res.json({
          success: true,
          aura: newAura
        });
      } else if (task.taskType === 'fusion') {
        // Get auras
        const primaryAura = await storage.getAuraById(task.primaryAuraId!);
        const secondaryAura = await storage.getAuraById(task.secondaryAuraId!);
        
        if (!primaryAura || !secondaryAura) {
          return res.status(404).json({ message: 'One or both fusion auras not found' });
        }
        
        // Create upgraded aura (level + 1)
        const newLevel = Math.min(primaryAura.level !== null ? primaryAura.level + 1 : 2, 5);
        
        // Enhance stat bonuses by 1-2 points, capping at +10
        const enhanceStat = (baseStat: number | null) => {
          if (baseStat === null) return Math.floor(Math.random() * 5); // Random 0-4 if null
          
          // Add 1-2 points, but cap at 10
          const enhancement = Math.floor(Math.random() * 2) + 1;
          return Math.min(baseStat + enhancement, 10);
        };
        
        // Apply secondary aura's best stat if it's higher
        const combineBestStat = (primaryStat: number | null, secondaryStat: number | null) => {
          const pStat = primaryStat !== null ? primaryStat : -5;
          const sStat = secondaryStat !== null ? secondaryStat : -5;
          return Math.max(pStat, sStat);
        };
        
        // Get aura name based on element (maintain core aura names)
        let auraName = '';
        switch(primaryAura.element) {
          case 'fire': 
            auraName = 'Inferno\'s Embrace';
            break;
          case 'water': 
            auraName = 'Ocean\'s Mercy';
            break;
          case 'earth': 
            auraName = 'Stoneguard\'s Pact';
            break;
          case 'wind': 
            auraName = 'Zephyr\'s Whisper';
            break;
          default:
            auraName = `Enhanced ${primaryAura.element} Aura`;
        }
        
        // Keep the primary aura's skills (no chance-based upgrades)
        // Just carry over the existing skills
        const processedSkills = [...(primaryAura.skills || [])];
        
        // When fusing to create a Tier 2 aura, add an Advanced skill
        // Check if this will be a Tier 2 aura based on the primary aura's tier and the new level
        if ((primaryAura.tier === 1 || !primaryAura.tier) && newLevel >= 2) {
          // Define advanced skills for each element
          const advancedSkills = {
            fire: [
              {
                name: "Flame Whip",
                type: "Advanced",
                description: "A cracking lash of fire that scorches in a line.",
                damage: 1.2,
                level: 2,
                effect: "25% chance to apply 1 Burn Stack for 2 Turns",
                targets: "2-3 in a row"
              },
              {
                name: "Combustion",
                type: "Advanced",
                description: "Focuses heat into a precise explosion that weakens all defenses.",
                damage: 1.3,
                level: 2,
                effect: "15% chance to apply Defense Down (-20%) for 1 Turn",
                targets: 1
              }
            ],
            water: [
              {
                name: "Tidal Wave",
                type: "Advanced",
                description: "A wall of rushing water crashes over multiple enemies.",
                damage: 1.1,
                level: 2,
                effect: "15% chance to Knockback (reduce Turn Meter by 20%)",
                targets: "2-3 Random"
              },
              {
                name: "Mist Veil",
                type: "Advanced",
                description: "A protective fog envelops allies, protecting them from harm.",
                damage: 0.7,
                level: 2,
                effect: "Apply Shield (10% of Caster's Max HP) to lowest HP Ally",
                targets: 1
              }
            ],
            earth: [
              {
                name: "Fissure",
                type: "Advanced",
                description: "The ground breaks open beneath the enemy, disrupting their stance.",
                damage: 1.3,
                level: 2,
                effect: "35% chance to apply Stagger (miss next turn)",
                targets: 1
              },
              {
                name: "Stone Armor",
                type: "Advanced",
                description: "Layers of rock form a protective coating around the caster.",
                damage: 0.6,
                level: 2,
                effect: "Self buff: Defense Up (+30%) for 2 Turns",
                targets: 1
              }
            ],
            wind: [
              {
                name: "Cyclone",
                type: "Advanced",
                description: "A spinning vortex pulls in multiple enemies and tosses them about.",
                damage: 1.0,
                level: 2,
                effect: "35% chance to apply Confusion (50% chance to attack ally) for 1 Turn",
                targets: "2 Random"
              },
              {
                name: "Tailwind",
                type: "Advanced",
                description: "Favorable winds increase party movement speed.",
                damage: 0.6,
                level: 2,
                effect: "Grant Speed Up (+20%) to all allies for 2 Turns",
                targets: "All Allies"
              }
            ]
          };
          
          // Safely get the element type
          const elementTypeSafe = primaryAura.element as keyof typeof advancedSkills;
          
          // Select a random Advanced skill to add
          if (advancedSkills[elementTypeSafe]) {
            const randomIndex = Math.floor(Math.random() * advancedSkills[elementTypeSafe].length);
            const advancedSkill = advancedSkills[elementTypeSafe][randomIndex];
            
            // Add the Advanced skill if one doesn't already exist
            if (!processedSkills.some(skill => skill.type === "Advanced")) {
              processedSkills.push(advancedSkill);
            }
          }
        }
        
        // When fusing to create a Tier 3 aura, add an Ultimate skill
        if ((primaryAura.tier === 2 || newLevel >= 3) && newLevel >= 3) {
          // Define ultimate skills for each element
          const ultimateSkills = {
            fire: {
              name: "Supernova",
              type: "Ultimate",
              description: "All surrounding matter ignites in a cataclysmic blast of energy.",
              damage: 1.8,
              level: 3,
              effect: "Apply Burn (5% HP damage per turn) to all enemies for 2 Turns",
              targets: "All Enemies"
            },
            water: {
              name: "Abyssal Depths",
              type: "Ultimate",
              description: "The crushing pressure of the deep ocean consumes all enemies.",
              damage: 1.5,
              level: 3,
              effect: "Apply Slow (speed -40%) to all enemies for 2 Turns",
              targets: "All Enemies"
            },
            earth: {
              name: "Tectonic Shift",
              type: "Ultimate",
              description: "The battlefield fractures as massive stone pillars erupt from below.",
              damage: 1.7,
              level: 3,
              effect: "50% chance to Stun each enemy for 1 Turn",
              targets: "All Enemies"
            },
            wind: {
              name: "Hurricane",
              type: "Ultimate",
              description: "A devastating storm tears through the battlefield with unmatched fury.",
              damage: 1.6,
              level: 3,
              effect: "Reduce Turn Meter of all enemies by 30%",
              targets: "All Enemies"
            }
          };
          
          // Safely get the element type
          const elementTypeSafe = primaryAura.element as keyof typeof ultimateSkills;
          
          // Add the Ultimate skill if one doesn't already exist
          if (!processedSkills.some(skill => skill.type === "Ultimate") && 
              ultimateSkills[elementTypeSafe]) {
            processedSkills.push(ultimateSkills[elementTypeSafe]);
          }
        }
        
        const resultAura = await storage.createAura({
          userId: req.session.userId!,
          name: auraName,
          level: newLevel,
          element: primaryAura.element,
          tier: primaryAura.tier !== null ? primaryAura.tier + 1 : 2,
          // Enhance stat bonuses, capping at +10%
          attack: combineBestStat(enhanceStat(primaryAura.attack), secondaryAura.attack),
          defense: combineBestStat(enhanceStat(primaryAura.defense), secondaryAura.defense),
          vitality: combineBestStat(enhanceStat(primaryAura.vitality), secondaryAura.vitality),
          speed: combineBestStat(enhanceStat(primaryAura.speed), secondaryAura.speed),
          focus: combineBestStat(enhanceStat(primaryAura.focus), secondaryAura.focus),
          resilience: combineBestStat(enhanceStat(primaryAura.resilience), secondaryAura.resilience),
          accuracy: combineBestStat(enhanceStat(primaryAura.accuracy), secondaryAura.accuracy),
          // Record fusion source for display in aura details
          fusionSource: true,
          creatorCharacterId: task.characterId,
          skills: processedSkills
        });
        
        // 30% chance to transfer a skill from secondary aura if they're not the same skills
        if (secondaryAura.skills && secondaryAura.skills.length > 0 && Math.random() < 0.3) {
          // Find a skill from the secondary aura that isn't already in the result aura
          const availableSkills = secondaryAura.skills.filter(secondarySkill => 
            !resultAura.skills.some(resultSkill => resultSkill.name === secondarySkill.name)
          );
          
          if (availableSkills.length > 0) {
            const randomSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
            resultAura.skills = [...resultAura.skills, randomSkill];
            await storage.updateAura(resultAura.id, { skills: resultAura.skills });
          }
        }
        
        // Delete source auras
        await storage.deleteAura(primaryAura.id);
        await storage.deleteAura(secondaryAura.id);
        
        // Update task
        await storage.updateForgingTask(taskId, {
          completed: true,
          resultAuraId: resultAura.id
        });
        
        // Free up the character
        if (task.characterId) {
          await storage.updateCharacter(task.characterId, {
            isActive: false,
            activityType: null,
            activityEndTime: null
          });
          
          const character = await storage.getCharacterById(task.characterId);
          if (character) {
            await storage.createActivityLog({
              userId: req.session.userId!,
              activityType: 'character_task_completed',
              description: `${character.name} has completed fusing auras to create a stronger one`,
              relatedIds: { characterId: character.id, auraId: resultAura.id }
            });
          }
        }
        
        // Log activity
        await storage.createActivityLog({
          userId: req.session.userId!,
          activityType: 'aura_fusion_completed',
          description: `Fused auras to create enhanced Level ${resultAura.level} ${resultAura.element} Aura`,
          relatedIds: { auraId: resultAura.id }
        });
        
        return res.json({
          success: true,
          aura: resultAura
        });
      } else {
        return res.status(400).json({ message: 'Unknown task type' });
      }
    } catch (error) {
      console.error('Error completing forging task:', error);
      res.status(500).json({ message: 'Failed to complete forging task' });
    }
  });
  
  // Black Market routes
  app.get('/api/blackmarket/listings', authenticateUser, async (req, res) => {
    try {
      // Get all listings
      let listings = await storage.getBlackMarketListings();
      
      // If no listings exist, create some sample listings
      if (listings.length === 0) {
        const systemId = 0; // System listings created by ID 0
        
        // Helper function to create premium listings (Forge Tokens)
        const createPremiumListing = (type, data, price, featured = false) => ({
          userId: systemId,
          itemType: type,
          itemId: Math.floor(Math.random() * 1000000) + 1, // Generate a placeholder ID
          itemData: data,
          price,
          currencyType: 'forgeTokens',
          sold: false,
          listedAt: new Date(),
          expiresAt: new Date(Date.now() + applySpeedBoost(86400000)), // Apply speed boost
          featured
        });
        
        // Helper function to create standard listings (Rogue Credits)
        const createStandardListing = (type, data, price) => ({
          userId: systemId,
          itemType: type,
          itemId: Math.floor(Math.random() * 1000000) + 1, // Generate a placeholder ID
          itemData: data,
          price,
          currencyType: 'rogueCredits', 
          sold: false,
          listedAt: new Date(),
          expiresAt: new Date(Date.now() + applySpeedBoost(86400000)) // Apply speed boost
        });
        
        // Sample premium character listings (forge tokens)
        const premiumCharacters = [
          createPremiumListing('character', {
            name: 'Shadow Rogue',
            level: 25,
            class: 'Rogue',
            stats: {
              strength: 52,
              agility: 85,
              intelligence: 60,
              vitality: 70
            },
            equippedAuraIds: [],
            passiveSkills: [
              { name: 'Shadowstep', description: 'Can teleport behind enemies once per battle' },
              { name: 'Critical Mastery', description: '15% increased critical hit chance' }
            ]
          }, 750, true),
          
          createPremiumListing('character', {
            name: 'Arcane Scholar',
            level: 20,
            class: 'Mage',
            stats: {
              strength: 30,
              agility: 45,
              intelligence: 90,
              vitality: 55
            },
            equippedAuraIds: [],
            passiveSkills: [
              { name: 'Spell Mastery', description: 'Spells cost 10% less mana' },
              { name: 'Arcane Shield', description: 'Automatically blocks first spell damage in battle' }
            ]
          }, 550)
        ];
        
        // Sample standard character listings (rogue credits)
        const standardCharacters = [
          createStandardListing('character', {
            name: 'Veteran Warrior',
            level: 15,
            class: 'Warrior',
            stats: {
              strength: 70,
              agility: 40,
              intelligence: 30,
              vitality: 65
            },
            equippedAuraIds: [],
            passiveSkills: [
              { name: 'Battle Hardened', description: 'Takes 5% less damage from physical attacks' }
            ]
          }, 2500)
        ];
        
        // Sample premium aura listings
        const premiumAuras = [
          createPremiumListing('aura', {
            name: 'Flame Emperor\'s Might',
            element: 'Fire',
            level: 3,
            attack: 8,
            defense: 6,
            vitality: 7,
            speed: 7,
            focus: 8,
            resilience: 5,
            accuracy: 6,
            skills: [
              { name: 'Inferno', description: 'Deals massive fire damage to all enemies', tier: 'Ultimate' },
              { name: 'Burning Aura', description: 'Enemies take burn damage when attacking the wearer', tier: 'Advanced' },
              { name: 'Fire Resistance', description: '25% resistance to fire damage', tier: 'Basic' }
            ]
          }, 900, true),
          
          createPremiumListing('aura', {
            name: 'Tidal Mastery',
            element: 'Water',
            level: 2,
            attack: 5,
            defense: 7,
            vitality: 6,
            speed: 9,
            focus: 8,
            resilience: 4,
            accuracy: 7,
            skills: [
              { name: 'Healing Tide', description: 'Restores health to all allies', tier: 'Advanced' },
              { name: 'Water Shield', description: 'Creates a barrier that absorbs damage', tier: 'Basic' }
            ]
          }, 600)
        ];
        
        // Sample standard aura listings
        const standardAuras = [
          createStandardListing('aura', {
            name: 'Earthen Protection',
            element: 'Earth',
            level: 1,
            attack: 4,
            defense: 9,
            vitality: 7,
            speed: 3,
            focus: 5,
            resilience: 8,
            accuracy: 4,
            skills: [
              { name: 'Stone Skin', description: 'Reduces physical damage by 10%', tier: 'Basic' }
            ]
          }, 1800)
        ];
        
        // Sample resource listings
        const resources = [
          createPremiumListing('resource', {
            name: 'Celestial Ore',
            type: 'material',
            quantity: 50,
            description: 'Rare material used for crafting high-level auras',
            iconUrl: 'https://images.unsplash.com/photo-1618221118493-9bce6d4b04cd?w=150&h=150&fit=crop'
          }, 300),
          
          createStandardListing('resource', {
            name: 'Aether Crystal',
            type: 'material',
            quantity: 20,
            description: 'Magical crystal that enhances aura crafting success rates',
            iconUrl: 'https://images.unsplash.com/photo-1566792368824-44a7882c53e5?w=150&h=150&fit=crop'
          }, 1200),
          
          createPremiumListing('resource', {
            name: 'Soul Shard Bundle',
            type: 'currency',
            quantity: 10,
            description: 'Bundle of soul shards used for advanced crafting',
            iconUrl: 'https://images.unsplash.com/photo-1518563071562-1e3a85d4523d?w=150&h=150&fit=crop'
          }, 450)
        ];
        
        // Create all the listings
        const allListings = [
          ...premiumCharacters,
          ...standardCharacters,
          ...premiumAuras,
          ...standardAuras,
          ...resources
        ];
        
        for (const listing of allListings) {
          await storage.createBlackMarketListing(listing);
        }
        
        // Fetch the newly created listings
        listings = await storage.getBlackMarketListings();
      }
      
      res.json(listings);
    } catch (error) {
      console.error('Error fetching market listings:', error);
      res.status(500).json({ message: 'Failed to fetch market listings' });
    }
  });
  
  app.post('/api/blackmarket/buy/:id', authenticateUser, async (req, res) => {
    try {
      const listingId = parseInt(req.params.id);
      const listing = await storage.getBlackMarketListingById(listingId);
      
      if (!listing) {
        return res.status(404).json({ message: 'Listing not found' });
      }
      
      if (listing.sold) {
        return res.status(400).json({ message: 'Item already sold' });
      }
      
      // Check if user has enough currency
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      // Validate currency for purchase
      if (listing.currencyType === 'forgeTokens') {
        if (user.forgeTokens === null || user.forgeTokens < listing.price) {
          return res.status(400).json({ message: 'Not enough Forge Tokens' });
        }
        // Deduct forge tokens from user
        await storage.updateUser(user.id, {
          forgeTokens: user.forgeTokens - listing.price
        });
      } else if (listing.currencyType === 'rogueCredits') {
        if (user.rogueCredits === null || user.rogueCredits < listing.price) {
          return res.status(400).json({ message: 'Not enough Rogue Credits' });
        }
        // Deduct rogue credits from user
        await storage.updateUser(user.id, {
          rogueCredits: user.rogueCredits - listing.price
        });
      } else {
        return res.status(400).json({ message: 'Invalid currency type' });
      }
      
      // Mark as sold
      await storage.updateBlackMarketListing(listingId, { sold: true });
      
      // Transfer the item to the user
      let purchasedItem;
      if (listing.itemType === 'character') {
        // Get character details (for MVP, generate a new character with passiveSkills)
        purchasedItem = await storage.createCharacter({
          userId: user.id,
          name: `Market Hero ${Math.floor(Math.random() * 1000)}`,
          class: ['Warrior', 'Mage', 'Rogue', 'Cleric'][Math.floor(Math.random() * 4)],
          level: Math.floor(Math.random() * 5) + 1,
          avatarUrl: [
            'https://images.unsplash.com/photo-1577095972620-2f389ca3abcd?w=150&h=150&fit=crop',
            'https://images.unsplash.com/photo-1613477564751-fc2a7c5bbb7a?w=150&h=150&fit=crop',
            'https://images.unsplash.com/photo-1578336134673-1eef9c8c5e36?w=150&h=150&fit=crop'
          ][Math.floor(Math.random() * 3)],
          attack: Math.floor(Math.random() * 10) + 10,
          defense: Math.floor(Math.random() * 10) + 10,
          health: Math.floor(Math.random() * 50) + 100,
          speed: Math.floor(Math.random() * 10) + 10,
          vitality: Math.floor(Math.random() * 10) + 10,
          intelligence: Math.floor(Math.random() * 10) + 10,
          luck: Math.floor(Math.random() * 10) + 10,
          // Add passiveSkills array with random skills based on character class
          passiveSkills: [
            {
              name: ['Strength Boost', 'Quick Reflexes', 'Magical Aptitude', 'Divine Grace'][Math.floor(Math.random() * 4)],
              description: 'A special ability gained through market purchase'
            }
          ]
        });
      } else if (listing.itemType === 'aura') {
        // Create a new aura with stat values
        purchasedItem = await storage.createAura({
          userId: user.id,
          name: `Market Aura ${Math.floor(Math.random() * 1000)}`,
          level: Math.floor(Math.random() * 3) + 1,
          element: ['fire', 'water', 'earth', 'air'][Math.floor(Math.random() * 4)],
          tier: 1,
          // Add individual stat values
          attack: Math.floor(Math.random() * 15) + 5,
          defense: Math.floor(Math.random() * 15) + 5,
          vitality: Math.floor(Math.random() * 15) + 5,
          speed: Math.floor(Math.random() * 15) + 5,
          focus: Math.floor(Math.random() * 15) + 5,
          resilience: Math.floor(Math.random() * 15) + 5,
          accuracy: Math.floor(Math.random() * 15) + 5,
          // Market purchased aura
          fusionSource: false,
          skills: []
        });
      } else if (listing.itemType === 'resource') {
        // Add resources to inventory
        const resourceName = ['Celestial Ore', 'Moonsilver', 'Dragon Scale', 'Phoenix Feather'][Math.floor(Math.random() * 4)];
        const quantity = Math.floor(Math.random() * 41) + 10;
        
        const existingResource = await storage.getResourceByNameAndUserId(resourceName, user.id);
        if (existingResource) {
          purchasedItem = await storage.updateResource(existingResource.id, {
            quantity: existingResource.quantity + quantity
          });
        } else {
          purchasedItem = await storage.createResource({
            userId: user.id,
            name: resourceName,
            type: 'material',
            quantity: quantity,
            description: 'A valuable material from the Black Market',
            iconUrl: 'https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop'
          });
        }
      }
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'item_purchased',
        description: `Purchased ${listing.itemType} from the Black Market for ${listing.price} ${listing.currencyType}`,
        relatedIds: { listingId: listing.id }
      });
      
      res.json({
        success: true,
        item: purchasedItem
      });
    } catch (error) {
      console.error('Error purchasing item:', error);
      res.status(500).json({ message: 'Failed to purchase item' });
    }
  });
  
  // Bounty Board routes
  app.get('/api/bounty/quests', authenticateUser, async (req, res) => {
    try {
      let quests = await storage.getBountyQuests(req.session.userId!);
      
      // If no quests are found, create some sample daily and weekly quests
      if (quests.length === 0) {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        const nextWeek = new Date();
        nextWeek.setDate(nextWeek.getDate() + 7);
        
        // Get bounty board level to determine quest difficulties
        const bountyBoardUpgrade = await storage.getBuildingUpgradeByTypeAndUserId('bountyBoard', req.session.userId!);
        const bountyBoardLevel = bountyBoardUpgrade?.currentLevel || 1;
        
        // Determine quest availability based on bounty board level
        const canGenerateRare = bountyBoardLevel >= 3;
        const canGenerateEpic = bountyBoardLevel >= 5;
        const canGenerateMythic = bountyBoardLevel >= 7;
        const canGenerateLegendary = bountyBoardLevel >= 10;
        
        // Determine number of daily quests based on bounty board level
        const dailyQuestCount = Math.min(5, Math.floor(1.5 * bountyBoardLevel));
        
        // Base daily quests
        const dailyQuests = [
          {
            userId: req.session.userId!,
            name: "Resource Collector",
            description: "Gather various resources through farming missions",
            questType: "daily",
            difficulty: "Basic",
            requirements: {
              farmingCompleted: { current: 0, target: 3, label: "Complete farming missions" }
            },
            rewards: {
              rogueCredits: 150,
              forgeTokens: 30
            },
            completed: false,
            expiresAt: tomorrow
          }
        ];
        
        // Add Rare quest if available
        if (canGenerateRare) {
          dailyQuests.push({
            userId: req.session.userId!,
            name: "Dungeon Explorer",
            description: "Complete dungeon runs to earn extra rewards",
            questType: "daily",
            difficulty: "Rare",
            requirements: {
              dungeonRuns: { current: 0, target: 2, label: "Complete dungeon runs" }
            },
            rewards: {
              rogueCredits: 250,
              forgeTokens: 50,
              soulShards: 2
            },
            completed: false,
            expiresAt: tomorrow
          });
        }
        
        // Add Epic quest if available
        if (canGenerateEpic) {
          dailyQuests.push({
            userId: req.session.userId!,
            name: "Forge Apprentice",
            description: "Craft or fuse auras at The Forge",
            questType: "daily",
            difficulty: "Epic",
            requirements: {
              craftAuras: { current: 0, target: 1, label: "Craft an aura" }
            },
            rewards: {
              forgeTokens: 80,
              soulShards: 5,
              material: { name: "Celestial Ore", amount: 20 }
            },
            completed: false,
            expiresAt: tomorrow
          });
        }
        
        // Add Mythic quest if available
        if (canGenerateMythic) {
          dailyQuests.push({
            userId: req.session.userId!,
            name: "Elite Dungeon Challenge",
            description: "Conquer the most difficult dungeons",
            questType: "daily",
            difficulty: "Mythic",
            requirements: {
              eliteDungeons: { current: 0, target: 2, label: "Complete elite dungeons" },
              bossDefeats: { current: 0, target: 1, label: "Defeat dungeon boss" }
            },
            rewards: {
              rogueCredits: 500,
              forgeTokens: 100,
              soulShards: 8
            },
            completed: false,
            expiresAt: tomorrow
          });
        }
        
        // Base weekly quests
        const weeklyQuests = [
          {
            userId: req.session.userId!,
            name: "Master Collector",
            description: "Gather a large amount of resources throughout the week",
            questType: "weekly",
            difficulty: canGenerateRare ? "Rare" : "Basic",
            requirements: {
              farmingCompleted: { current: 0, target: 15, label: "Complete farming missions" }
            },
            rewards: {
              rogueCredits: 1000,
              forgeTokens: 200,
              material: { name: "Celestial Ore", amount: 50 }
            },
            completed: false,
            expiresAt: nextWeek
          }
        ];
        
        // Add Epic weekly quest if available
        if (canGenerateEpic) {
          weeklyQuests.push({
            userId: req.session.userId!,
            name: "Dungeon Master",
            description: "Prove your skill by completing multiple challenging dungeons",
            questType: "weekly",
            difficulty: "Epic",
            requirements: {
              dungeonRuns: { current: 0, target: 10, label: "Complete dungeon runs" },
              bossDefeats: { current: 0, target: 3, label: "Defeat dungeon bosses" }
            },
            rewards: {
              rogueCredits: 2000,
              forgeTokens: 350,
              soulShards: 15
            },
            completed: false,
            expiresAt: nextWeek
          });
        }
        
        // Add Legendary weekly quest if available
        if (canGenerateLegendary) {
          weeklyQuests.push({
            userId: req.session.userId!,
            name: "The Ultimate Challenge",
            description: "Only the most dedicated adventurers can complete this quest",
            questType: "weekly",
            difficulty: "Legendary",
            requirements: {
              legendaryDungeons: { current: 0, target: 5, label: "Complete legendary dungeons" },
              legendaryBosses: { current: 0, target: 3, label: "Defeat legendary bosses" },
              craftAuras: { current: 0, target: 5, label: "Craft high-level auras" }
            },
            rewards: {
              rogueCredits: 5000,
              forgeTokens: 1000,
              soulShards: 50,
              material: { name: "Celestial Essence", amount: 100 }
            },
            completed: false,
            expiresAt: nextWeek
          });
        }
        
        // Create all the quests
        for (const quest of [...dailyQuests, ...weeklyQuests]) {
          await storage.createBountyQuest(quest);
        }
        
        // Fetch the newly created quests
        quests = await storage.getBountyQuests(req.session.userId!);
      }
      
      res.json(quests);
    } catch (error) {
      console.error('Error fetching bounty quests:', error);
      res.status(500).json({ message: 'Failed to fetch bounty quests' });
    }
  });
  
  app.post('/api/bounty/quests/:id/claim', authenticateUser, async (req, res) => {
    try {
      const questId = parseInt(req.params.id);
      const quest = await storage.getBountyQuestById(questId);
      
      if (!quest) {
        return res.status(404).json({ message: 'Quest not found' });
      }
      
      if (quest.userId !== req.session.userId) {
        return res.status(403).json({ message: 'Not authorized to access this quest' });
      }
      
      if (quest.completed) {
        return res.status(400).json({ message: 'Quest already claimed' });
      }
      
      // Calculate if the quest is complete
      let isComplete = true;
      if (quest.requirements && typeof quest.requirements === 'object') {
        for (const [key, requirement] of Object.entries(quest.requirements)) {
          if (typeof requirement === 'object' && 'current' in requirement && 'target' in requirement) {
            if (requirement.current < requirement.target) {
              isComplete = false;
              break;
            }
          }
        }
      }
      
      if (!isComplete) {
        return res.status(400).json({ message: 'Quest requirements not met' });
      }
      
      // Mark as completed
      await storage.updateBountyQuest(questId, { completed: true });
      
      // Award rewards
      const user = await storage.getUserById(req.session.userId!);
      if (user && quest.rewards) {
        const updates: Partial<typeof user> = {};
        
        if ('rogueCredits' in quest.rewards && quest.rewards.rogueCredits) {
          updates.rogueCredits = (user.rogueCredits || 0) + quest.rewards.rogueCredits;
        }
        
        if ('forgeTokens' in quest.rewards && quest.rewards.forgeTokens) {
          updates.forgeTokens = (user.forgeTokens || 0) + quest.rewards.forgeTokens;
        }
        
        if ('soulShards' in quest.rewards && quest.rewards.soulShards) {
          updates.soulShards = (user.soulShards || 0) + quest.rewards.soulShards;
        }
        
        if (Object.keys(updates).length > 0) {
          await storage.updateUser(user.id, updates);
        }
        
        // Award material rewards if any
        if ('material' in quest.rewards && quest.rewards.material) {
          const { name, amount } = quest.rewards.material;
          const existingResource = await storage.getResourceByNameAndUserId(name, user.id);
          
          if (existingResource) {
            await storage.updateResource(existingResource.id, {
              quantity: (existingResource.quantity || 0) + amount
            });
          } else {
            await storage.createResource({
              userId: user.id,
              name,
              type: 'material',
              quantity: amount,
              description: `A material obtained from quests`,
              iconUrl: 'https://images.unsplash.com/photo-1608054791095-e0482e3e5139?w=150&h=150&fit=crop'
            });
          }
        }
      }
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'quest_completed',
        description: `Completed quest: ${quest.name}`,
        relatedIds: { questId: quest.id }
      });
      
      res.json({
        success: true,
        message: 'Quest rewards claimed successfully',
        rewards: quest.rewards
      });
    } catch (error) {
      console.error('Error claiming quest rewards:', error);
      res.status(500).json({ message: 'Failed to claim quest rewards' });
    }
  });
  
  // Buildings routes
  app.get('/api/buildings', authenticateUser, async (req, res) => {
    try {
      const buildings = await storage.getBuildingUpgrades(req.session.userId!);
      
      // Define the default building types
      const defaultBuildingTypes = ['townhall', 'forge', 'blackmarket', 'bountyBoard', 'tavern'];
      
      // Check if all default building types exist
      const existingTypes = buildings.map(b => b.buildingType);
      
      // Create missing buildings
      const createdBuildings = [];
      for (const type of defaultBuildingTypes) {
        if (!existingTypes.includes(type)) {
          console.log(`Creating default building for type: ${type}`);
          const newBuilding = await storage.createBuildingUpgrade({
            userId: req.session.userId!,
            buildingType: type,
            currentLevel: 1,
            upgradeInProgress: false,
            unlockedSkills: [],
            availableSkillPoints: 0,
            skillDistribution: {}
          });
          if (newBuilding) {
            createdBuildings.push(newBuilding);
          }
        }
      }
      
      // If any buildings were created, return all buildings including the new ones
      if (createdBuildings.length > 0) {
        const allBuildings = await storage.getBuildingUpgrades(req.session.userId!);
        return res.json(allBuildings);
      }
      
      res.json(buildings);
    } catch (error) {
      console.error('Error fetching buildings:', error);
      res.status(500).json({ message: 'Failed to fetch buildings' });
    }
  });

  // Get building skill tree
  app.get('/api/buildings/skills/:buildingType', authenticateUser, async (req, res) => {
    try {
      const { buildingType } = req.params;
      
      console.log("GET /api/buildings/skills/:buildingType", { buildingType, userId: req.session.userId });
      
      // Get the building
      let building = await storage.getBuildingUpgradeByTypeAndUserId(buildingType, req.session.userId!);
      
      // If building doesn't exist, create a default one
      if (!building) {
        console.log(`Creating default building for type: ${buildingType}`);
        building = await storage.createBuildingUpgrade({
          userId: req.session.userId!,
          buildingType: buildingType,
          currentLevel: 1,
          upgradeInProgress: false,
          unlockedSkills: [],
          availableSkillPoints: 0,
          skillDistribution: {}
        });
        
        if (!building) {
          return res.status(500).json({ message: 'Failed to create building record' });
        }
      }
      
      // Define skill trees for each building type
      const skillTrees = {
        townhall: [
          { id: 'th_slot_1', name: 'Extra Farming Slot', description: 'Unlocks an additional farming slot', maxLevel: 5 },
          { id: 'th_resource_1', name: 'Resource Production', description: 'Increases resource gain by 5% per level', maxLevel: 5 },
          { id: 'th_exp_1', name: 'Experience Boost', description: 'Increases XP gain by 5% per level', maxLevel: 5 },
          { id: 'th_building_1', name: 'Construction Speed', description: 'Reduces building upgrade time by 5% per level', maxLevel: 5 },
        ],
        forge: [
          // Path A: Speed & Efficiency
          { id: 'forge_speed_a', name: 'Crafting Speed', description: 'Increases crafting speed by 3% per level', maxLevel: 10, path: 'a' },
          { id: 'forge_double_a', name: 'Double Forge Chance', description: 'Increases chance to craft twice by 1.5% per level', maxLevel: 10, path: 'a' },
          { id: 'forge_slots_a', name: 'Additional Crafting Slots', description: 'Unlocks crafting slot #2 at level 5, slot #3 at level 10', maxLevel: 10, path: 'a' },
          { id: 'forge_adv_speed_a', name: 'Advanced Crafting Speed', description: 'Further increases crafting speed by 2% per level', maxLevel: 10, path: 'a', requires: { forge_speed_a: 10 } },
          
          // Path B: Quality & Power
          { id: 'forge_quality_b', name: 'Forge Quality', description: 'Increases item quality by 2% per level', maxLevel: 10, path: 'b' },
          { id: 'forge_crit_b', name: 'Forge Critical Chance', description: 'Increases chance for critical crafting by 1% per level', maxLevel: 10, path: 'b' },
          { id: 'forge_slots_b', name: 'Quality Crafting Slot', description: 'Unlocks crafting slot #4 at level 10', maxLevel: 10, path: 'b' },
          { id: 'forge_enh_quality_b', name: 'Enhanced Quality', description: 'Further increases item quality by 1.5% per level', maxLevel: 10, path: 'b', requires: { forge_quality_b: 10 } },
          
          // Path C: Skill Mastery
          { id: 'forge_skill_c', name: 'Skill Boost', description: 'Increases skill boost by 2% per level', maxLevel: 10, path: 'c' },
          { id: 'forge_crit_c', name: 'Skill Critical Chance', description: 'Increases chance for critical skill bonus by 1% per level', maxLevel: 10, path: 'c' },
          { id: 'forge_slots_c', name: 'Mastery Crafting Slot', description: 'Unlocks crafting slot #5 at level 10', maxLevel: 10, path: 'c' },
          { id: 'forge_enh_skill_c', name: 'Enhanced Skill Boost', description: 'Further increases skill boost by 1.5% per level', maxLevel: 10, path: 'c', requires: { forge_skill_c: 10 } },
          
          // Cross-Path Specializations: A + B (Efficient Quality)
          { id: 'forge_quick_precision', name: 'Quick Precision', description: 'Increases quality by 1% and speed by 2% per level', maxLevel: 3, path: 'ab', requires: { points_a: 10, points_b: 10 } },
          { id: 'forge_crit_efficiency', name: 'Critical Efficiency', description: 'Increases double forge by 1% and critical chance by 1% per level', maxLevel: 3, path: 'ab', requires: { forge_quick_precision: 3 } },
          { id: 'forge_sixth_slot', name: '6th Crafting Slot', description: 'Unlocks crafting slot #6', maxLevel: 3, path: 'ab', requires: { forge_crit_efficiency: 3 } },
          
          // Cross-Path Specializations: B + C (Skillful Quality)
          { id: 'forge_refined_techniques', name: 'Refined Techniques', description: 'Increases skill boost and quality by 1.5% per level', maxLevel: 3, path: 'bc', requires: { points_b: 10, points_c: 10 } },
          { id: 'forge_enh_critical', name: 'Enhanced Critical', description: 'Increases forge critical chance by 2% per level', maxLevel: 3, path: 'bc', requires: { forge_refined_techniques: 3 } },
          { id: 'forge_master_artisan', name: 'Master Artisan', description: 'Increases stat multiplier and skill boost by 3% per level', maxLevel: 3, path: 'bc', requires: { forge_enh_critical: 3 } },
          
          // Cross-Path Specializations: A + C (Efficient Mastery)
          { id: 'forge_swift_learning', name: 'Swift Learning', description: 'Increases speed and skill boost by 2% per level', maxLevel: 3, path: 'ac', requires: { points_a: 10, points_c: 10 } },
          { id: 'forge_dual_crafting', name: 'Dual Crafting', description: 'Increases double forge by 2% and skill boost by 1.5% per level', maxLevel: 3, path: 'ac', requires: { forge_swift_learning: 3 } },
          { id: 'forge_twin_mastery', name: 'Twin Forge Mastery', description: 'Increases double forge and speed by 5% at level 3', maxLevel: 3, path: 'ac', requires: { forge_dual_crafting: 3 } },
        ],
        blackmarket: [
          { id: 'bm_slots_1', name: 'Listing Slots', description: 'Unlocks additional personal listing slot', maxLevel: 5 },
          { id: 'bm_premium_1', name: 'Premium Offers', description: 'Increases premium item offers available', maxLevel: 3 },
          { id: 'bm_standard_1', name: 'Standard Offers', description: 'Increases standard item offers available', maxLevel: 3 },
          { id: 'bm_fee_1', name: 'Reduced Fees', description: 'Reduces market listing fees by 5% per level', maxLevel: 5 },
        ],
        bountyBoard: [
          { id: 'bb_daily_1', name: 'Daily Quest Slots', description: 'Increases available daily quests by 1', maxLevel: 4 },
          { id: 'bb_weekly_1', name: 'Weekly Quest Slots', description: 'Increases available weekly quests by 1', maxLevel: 2 },
          { id: 'bb_rewards_1', name: 'Enhanced Rewards', description: 'Increases quest rewards by 10% per level', maxLevel: 5 },
          { id: 'bb_refresh_1', name: 'Quick Refresh', description: 'Reduces quest refresh timer by 1 hour per level', maxLevel: 3 },
        ],
      };
      
      // Get the appropriate skill tree
      const skillTree = skillTrees[buildingType as keyof typeof skillTrees] || [];
      
      // Return the skill tree with the current unlocked skills
      res.json({
        buildingType,
        currentLevel: building.currentLevel,
        unlockedSkills: building.unlockedSkills || [],
        availableSkillTree: skillTree
      });
    } catch (error) {
      console.error('Error fetching building skill tree:', error);
      res.status(500).json({ message: 'Failed to fetch building skill tree' });
    }
  });
  
  // Allocate skill points
  app.post('/api/buildings/skills/:buildingType', authenticateUser, async (req, res) => {
    try {
      const { buildingType } = req.params;
      const { skillId } = req.body;
      
      if (!skillId) {
        return res.status(400).json({ message: 'Skill ID is required' });
      }
      
      // Get the building
      let building = await storage.getBuildingUpgradeByTypeAndUserId(buildingType, req.session.userId!);
      
      // If building doesn't exist, create a default one
      if (!building) {
        console.log(`Creating default building for type: ${buildingType}`);
        building = await storage.createBuildingUpgrade({
          userId: req.session.userId!,
          buildingType: buildingType,
          currentLevel: 1,
          upgradeInProgress: false,
          unlockedSkills: [],
          availableSkillPoints: 0,
          skillDistribution: {}
        });
        
        if (!building) {
          return res.status(500).json({ message: 'Failed to create building record' });
        }
      }
      
      // Get the skill tree for this building type
      const skillTrees = {
        townhall: townhallSkillTree,
        forge: [
          // Path A: Speed & Efficiency
          { id: 'forge_speed_a', name: 'Crafting Speed', description: 'Increases crafting speed by 3% per level', maxLevel: 10, path: 'a' },
          { id: 'forge_double_a', name: 'Double Forge Chance', description: 'Increases chance to craft twice by 1.5% per level', maxLevel: 10, path: 'a' },
          { id: 'forge_slots_a', name: 'Additional Crafting Slots', description: 'Unlocks crafting slot #2 at level 5, slot #3 at level 10', maxLevel: 10, path: 'a' },
          { id: 'forge_adv_speed_a', name: 'Advanced Crafting Speed', description: 'Further increases crafting speed by 2% per level', maxLevel: 10, path: 'a', requires: { forge_speed_a: 10 } },
          
          // Path B: Quality & Power
          { id: 'forge_quality_b', name: 'Forge Quality', description: 'Increases item quality by 2% per level', maxLevel: 10, path: 'b' },
          { id: 'forge_crit_b', name: 'Forge Critical Chance', description: 'Increases chance for critical crafting by 1% per level', maxLevel: 10, path: 'b' },
          { id: 'forge_slots_b', name: 'Quality Crafting Slot', description: 'Unlocks crafting slot #4 at level 10', maxLevel: 10, path: 'b' },
          { id: 'forge_enh_quality_b', name: 'Enhanced Quality', description: 'Further increases item quality by 1.5% per level', maxLevel: 10, path: 'b', requires: { forge_quality_b: 10 } },
          
          // Path C: Skill Mastery
          { id: 'forge_skill_c', name: 'Skill Boost', description: 'Increases skill boost by 2% per level', maxLevel: 10, path: 'c' },
          { id: 'forge_crit_c', name: 'Skill Critical Chance', description: 'Increases chance for critical skill bonus by 1% per level', maxLevel: 10, path: 'c' },
          { id: 'forge_slots_c', name: 'Mastery Crafting Slot', description: 'Unlocks crafting slot #5 at level 10', maxLevel: 10, path: 'c' },
          { id: 'forge_enh_skill_c', name: 'Enhanced Skill Boost', description: 'Further increases skill boost by 1.5% per level', maxLevel: 10, path: 'c', requires: { forge_skill_c: 10 } },
          
          // Cross-Path Specializations
          { id: 'forge_quick_precision', name: 'Quick Precision', description: 'Increases quality by 1% and speed by 2% per level', maxLevel: 3, path: 'ab', requires: { points_a: 10, points_b: 10 } },
          { id: 'forge_crit_efficiency', name: 'Critical Efficiency', description: 'Increases double forge by 1% and critical chance by 1% per level', maxLevel: 3, path: 'ab', requires: { forge_quick_precision: 3 } },
          { id: 'forge_sixth_slot', name: '6th Crafting Slot', description: 'Unlocks crafting slot #6', maxLevel: 3, path: 'ab', requires: { forge_crit_efficiency: 3 } },
          { id: 'forge_refined_techniques', name: 'Refined Techniques', description: 'Increases skill boost and quality by 1.5% per level', maxLevel: 3, path: 'bc', requires: { points_b: 10, points_c: 10 } },
          { id: 'forge_enh_critical', name: 'Enhanced Critical', description: 'Increases forge critical chance by 2% per level', maxLevel: 3, path: 'bc', requires: { forge_refined_techniques: 3 } },
          { id: 'forge_master_artisan', name: 'Master Artisan', description: 'Increases stat multiplier and skill boost by 3% per level', maxLevel: 3, path: 'bc', requires: { forge_enh_critical: 3 } },
          { id: 'forge_swift_learning', name: 'Swift Learning', description: 'Increases speed and skill boost by 2% per level', maxLevel: 3, path: 'ac', requires: { points_a: 10, points_c: 10 } },
          { id: 'forge_dual_crafting', name: 'Dual Crafting', description: 'Increases double forge by 2% and skill boost by 1.5% per level', maxLevel: 3, path: 'ac', requires: { forge_swift_learning: 3 } },
          { id: 'forge_twin_mastery', name: 'Twin Forge Mastery', description: 'Increases double forge and speed by 5% at level 3', maxLevel: 3, path: 'ac', requires: { forge_dual_crafting: 3 } },
        ],
        blackmarket: [
          { id: 'bm_slots_1', name: 'Listing Slots', description: 'Unlocks additional personal listing slot', maxLevel: 5 },
          { id: 'bm_premium_1', name: 'Premium Offers', description: 'Increases premium item offers available', maxLevel: 3 },
          { id: 'bm_standard_1', name: 'Standard Offers', description: 'Increases standard item offers available', maxLevel: 3 },
          { id: 'bm_fee_1', name: 'Reduced Fees', description: 'Reduces market listing fees by 5% per level', maxLevel: 5 },
        ],
        bountyBoard: [
          { id: 'bb_daily_1', name: 'Daily Quest Slots', description: 'Increases available daily quests by 1', maxLevel: 4 },
          { id: 'bb_weekly_1', name: 'Weekly Quest Slots', description: 'Increases available weekly quests by 1', maxLevel: 2 },
          { id: 'bb_rewards_1', name: 'Enhanced Rewards', description: 'Increases quest rewards by 10% per level', maxLevel: 5 },
          { id: 'bb_refresh_1', name: 'Quick Refresh', description: 'Reduces quest refresh timer by 1 hour per level', maxLevel: 3 },
        ],
      };
      
      const skillTree = skillTrees[buildingType as keyof typeof skillTrees] || [];
      const selectedSkill = skillTree.find(skill => skill.id === skillId);
      
      if (!selectedSkill) {
        return res.status(404).json({ message: 'Skill not found in tree' });
      }
      
      // Check if the skill already has the maximum level
      const unlockedSkills = building.unlockedSkills || [];
      const skillCount = unlockedSkills.filter(id => id === skillId).length;
      
      if (skillCount >= selectedSkill.maxLevel) {
        return res.status(400).json({ message: 'This skill is already at maximum level' });
      }
      
      // Calculate path allocations
      const skillDistribution = building.skillDistribution || {};
      const pathCounts: Record<string, number> = {
        a: 0,
        b: 0,
        c: 0,
        ab: 0,
        bc: 0,
        ac: 0
      };
      
      // Count allocated points per path
      unlockedSkills.forEach(id => {
        const skill = skillTree.find(s => s.id === id);
        if (skill && skill.path) {
          pathCounts[skill.path] = (pathCounts[skill.path] || 0) + 1;
        }
      });
      
      // Check requirements for the selected skill
      if (selectedSkill.requires) {
        const meetsRequirements = Object.entries(selectedSkill.requires).every(([reqId, reqLevel]) => {
          // Special handling for path point requirements
          if (reqId.startsWith('points_')) {
            const path = reqId.split('_')[1];
            return pathCounts[path] >= reqLevel;
          }
          
          // Regular skill prerequisite check
          const prereqCount = unlockedSkills.filter(id => id === reqId).length;
          return prereqCount >= reqLevel;
        });
        
        if (!meetsRequirements) {
          return res.status(400).json({ 
            message: 'Skill requirements not met',
            requires: selectedSkill.requires
          });
        }
      }
      
      // Check if there are unallocated skill points (building level - allocated skills)
      const allocatedPoints = unlockedSkills.length;
      const availablePoints = building.currentLevel - allocatedPoints;
      
      if (availablePoints <= 0) {
        return res.status(400).json({ message: 'No skill points available' });
      }
      
      // Update skill distribution for path tracking
      const updatedDistribution = { ...skillDistribution };
      if (selectedSkill.path) {
        updatedDistribution[selectedSkill.path] = (updatedDistribution[selectedSkill.path] || 0) + 1;
      }
      
      // Add the skill to unlocked skills
      const updatedBuilding = await storage.updateBuildingUpgrade(building.id, {
        unlockedSkills: [...unlockedSkills, skillId],
        skillDistribution: updatedDistribution
      });
      
      res.json(updatedBuilding);
    } catch (error) {
      console.error('Error allocating skill point:', error);
      res.status(500).json({ message: 'Failed to allocate skill point' });
    }
  });

// DISABLED:   // DISABLED - duplicate route
// DISABLED:   // app.post('/api/buildings/upgrade', authenticateUser, async (req, res) => {
// DISABLED:     try {
// DISABLED:       const { buildingType, allocatedSkill } = req.body;
// DISABLED:       
// DISABLED:       if (!buildingType) {
// DISABLED:         return res.status(400).json({ message: 'Building type is required' });
// DISABLED:       }
// DISABLED:       
// DISABLED:       // Get user to check resources
// DISABLED:       const user = await storage.getUserById(req.session.userId!);
// DISABLED:       if (!user) {
// DISABLED:         return res.status(404).json({ message: 'User not found' });
// DISABLED:       }
// DISABLED:       
// DISABLED:       // Get the townhall to determine building level restrictions
// DISABLED:       const townhall = await storage.getBuildingUpgradeByTypeAndUserId('townhall', req.session.userId!);
// DISABLED:       const townhallLevel = townhall?.currentLevel || 1;
// DISABLED:       
// DISABLED:       // Set max allowed level to 9 for all buildings regardless of townhall level
// DISABLED:       const maxAllowedLevel = 9;
// DISABLED:       
// DISABLED:       // Get the existing building
// DISABLED:       const existingBuilding = await storage.getBuildingUpgradeByTypeAndUserId(buildingType, req.session.userId!);
// DISABLED:       
// DISABLED:       if (!existingBuilding) {
// DISABLED:         // Create a new building upgrade if it doesn't exist
// DISABLED:         const newBuilding = await storage.createBuildingUpgrade({
// DISABLED:           userId: req.session.userId!,
// DISABLED:           buildingType,
// DISABLED:           currentLevel: 1,
// DISABLED:           upgradeInProgress: false,
// DISABLED:           unlockedSkills: []
// DISABLED:         });
// DISABLED:         
// DISABLED:         return res.status(201).json(newBuilding);
// DISABLED:       }
// DISABLED:       
// DISABLED:       // Check if already upgrading
// DISABLED:       if (existingBuilding.upgradeInProgress) {
// DISABLED:         return res.status(400).json({ message: 'Building is already being upgraded' });
// DISABLED:       }
// DISABLED:       
// DISABLED:       // Building configs with max level and upgrade time
// DISABLED:       const buildingConfigs = {
// DISABLED:         townhall: { maxLevel: 9, upgradeTime: 60 },
// DISABLED:         forge: { maxLevel: 9, upgradeTime: 45 },
// DISABLED:         blackmarket: { maxLevel: 9, upgradeTime: 30 },
// DISABLED:         barracks: { maxLevel: 9, upgradeTime: 45 },
// DISABLED:         library: { maxLevel: 9, upgradeTime: 30 },
// DISABLED:         guild: { maxLevel: 9, upgradeTime: 90 },
// DISABLED:         bountyBoard: { maxLevel: 9, upgradeTime: 40 }
// DISABLED:       };
// DISABLED:       
// DISABLED:       const config = buildingConfigs[buildingType as keyof typeof buildingConfigs];
// DISABLED:       const maxLevel = config?.maxLevel || 50;
// DISABLED:       
// DISABLED:       // For townhall, use its own max level
// DISABLED:       if (buildingType === 'townhall') {
// DISABLED:         if (existingBuilding.currentLevel >= maxLevel) {
// DISABLED:           return res.status(400).json({ message: 'Townhall is already at max level' });
// DISABLED:         }
// DISABLED:       } else {
// DISABLED:         // For other buildings, check against the max allowed level
// DISABLED:         if (existingBuilding.currentLevel >= Math.min(maxAllowedLevel, maxLevel)) {
// DISABLED:           return res.status(400).json({ 
// DISABLED:             message: 'Building has reached maximum level',
// DISABLED:             currentLevel: existingBuilding.currentLevel,
// DISABLED:             maxAllowedLevel: maxAllowedLevel
// DISABLED:           });
// DISABLED:         }
// DISABLED:       }
// DISABLED:       
// DISABLED:       // Calculate cost
// DISABLED:       const baseCosts = {
// DISABLED:         townhall: { rogueCredits: 1000, forgeTokens: 100 },
// DISABLED:         forge: { rogueCredits: 800, forgeTokens: 80 },
// DISABLED:         blackmarket: { rogueCredits: 600, forgeTokens: 60 },
// DISABLED:         barracks: { rogueCredits: 800, forgeTokens: 80 },
// DISABLED:         library: { rogueCredits: 600, forgeTokens: 60 },
// DISABLED:         guild: { rogueCredits: 1200, forgeTokens: 120 },
// DISABLED:         bountyBoard: { rogueCredits: 700, forgeTokens: 70 }
// DISABLED:       };
// DISABLED:       
// DISABLED:       const baseCost = baseCosts[buildingType as keyof typeof baseCosts] || { rogueCredits: 500, forgeTokens: 50 };
// DISABLED:       const levelMultiplier = existingBuilding.currentLevel;
// DISABLED:       const cost = {
// DISABLED:         rogueCredits: baseCost.rogueCredits * levelMultiplier,
// DISABLED:         forgeTokens: baseCost.forgeTokens * levelMultiplier
// DISABLED:       };
// DISABLED:       
// DISABLED:       // Check if user can afford upgrade
// DISABLED:       if (user.rogueCredits! < cost.rogueCredits || user.forgeTokens! < cost.forgeTokens) {
// DISABLED:         return res.status(400).json({ 
// DISABLED:           message: 'Insufficient resources for upgrade',
// DISABLED:           required: cost,
// DISABLED:           current: {
// DISABLED:             rogueCredits: user.rogueCredits,
// DISABLED:             forgeTokens: user.forgeTokens
// DISABLED:           }
// DISABLED:         });
// DISABLED:       }
// DISABLED:       
// DISABLED:       // Deduct costs
// DISABLED:       await storage.updateUser(user.id, {
// DISABLED:         rogueCredits: user.rogueCredits! - cost.rogueCredits,
// DISABLED:         forgeTokens: user.forgeTokens! - cost.forgeTokens
// DISABLED:       });
// DISABLED:       
// DISABLED:       // Set upgrade in progress
// DISABLED:       const upgradeTime = (config?.upgradeTime || 30) * 60 * 1000; // minutes to milliseconds
// DISABLED:       const updatedBuilding = await storage.updateBuildingUpgrade(existingBuilding.id, {
// DISABLED:         upgradeInProgress: true,
// DISABLED:         upgradeStartTime: new Date(),
// DISABLED:         upgradeEndTime: new Date(Date.now() + upgradeTime)
// DISABLED:       });
// DISABLED:       
// DISABLED:       // Log activity
// DISABLED:       await storage.createActivityLog({
// DISABLED:         userId: req.session.userId!,
// DISABLED:         activityType: 'building_upgrade_started',
// DISABLED:         description: `Started upgrading ${buildingType} to level ${existingBuilding.currentLevel + 1}`,
// DISABLED:         relatedIds: { buildingId: existingBuilding.id }
// DISABLED:       });
// DISABLED:       
// DISABLED:       res.json(updatedBuilding);
// DISABLED:     } catch (error) {
// DISABLED:       console.error('Error starting building upgrade:', error);
// DISABLED:       res.status(500).json({ message: 'Failed to start building upgrade' });
// DISABLED:     }
// DISABLED:   });
// DISABLED:   
  app.post('/api/buildings/complete/:buildingType', authenticateUser, async (req, res) => {
    try {
      const { buildingType } = req.params;
      
      // Get the building
      const building = await storage.getBuildingUpgradeByTypeAndUserId(buildingType, req.session.userId!);
      
      if (!building) {
        return res.status(404).json({ message: 'Building not found' });
      }
      
      if (!building.upgradeInProgress) {
        return res.status(400).json({ message: 'Building is not being upgraded' });
      }
      
      if (building.upgradeEndTime && new Date(building.upgradeEndTime) > new Date()) {
        return res.status(400).json({ 
          message: 'Upgrade not complete yet',
          remainingTime: new Date(building.upgradeEndTime).getTime() - Date.now()
        });
      }
      
      // Complete upgrade
      const updatedBuilding = await storage.updateBuildingUpgrade(building.id, {
        currentLevel: building.currentLevel + 1,
        upgradeInProgress: false,
        upgradeStartTime: null,
        upgradeEndTime: null
      });
      
      // Log activity
      await storage.createActivityLog({
        userId: req.session.userId!,
        activityType: 'building_upgrade_completed',
        description: `Completed upgrading ${buildingType} to level ${building.currentLevel + 1}`,
        relatedIds: { buildingId: building.id }
      });
      
      res.json(updatedBuilding);
    } catch (error) {
      console.error('Error completing building upgrade:', error);
      res.status(500).json({ message: 'Failed to complete building upgrade' });
    }
  });
  
  // Activity log routes
  app.get('/api/activity', authenticateUser, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const logs = await storage.getActivityLogs(req.session.userId!, limit);
      res.json(logs);
    } catch (error) {
      console.error('Error fetching activity logs:', error);
      res.status(500).json({ message: 'Failed to fetch activity logs' });
    }
  });
  
  // Register building skill routes
  await addBuildingSkillRoutes(app);
  
  // Add error handling middleware
  app.use(handleErrors);
  
  // Register dungeon routes from new, modular implementation
  registerDungeonRoutes(app);
  
  return httpServer;
}

// NOTE: The battle log generation has been moved to the new modular dungeon-routes.ts implementation.
// The following function is kept for reference but is no longer used.

/*
async function processBattleLog(run: any, success: boolean) {
  // See dungeon-routes.ts for the new implementation
  return [];
}
*/

// Function to handle building skill routes
export async function addBuildingSkillRoutes(app: Express) {
  // Building skill routes implementation
  app.post('/api/buildings/upgrade', authenticateUser, async (req: Request, res: Response) => {
    try {
      const { buildingId, buildingType, slotId, upgradePath, pathName } = req.body;
      const userId = req.session.userId;
      
      if (!userId) {
        return res.status(401).json({ message: 'User not authenticated' });
      }
      
      // Handle different types of upgrades
      if (buildingType === 'farmSlot' || buildingType === 'forgeSlot') {
        // This is a slot upgrade
        if (slotId === undefined || upgradePath === undefined) {
          return res.status(400).json({ message: 'Missing required fields for slot upgrade' });
        }
        
        // Get current upgrades for this user
        let userUpgrades = await storage.getBuildingUpgradesByUserId(userId);
        
        if (!userUpgrades) {
          // Create initial upgrades record if none exists
          userUpgrades = await storage.createBuildingUpgrades({
            userId,
            farmSlots: [],
            forgeSlots: [],
            marketUpgrades: []
          });
        }
        
        // Create upgrade data
        const upgradeData = {
          slotId,
          level: 1, // Start at level 1 or increment existing level
          upgradePath,
          pathName,
          timestamp: new Date().toISOString()
        };
        
        // Update the appropriate slot category
        let updatedUpgrades;
        if (buildingType === 'farmSlot') {
          // Check if this slot already has upgrades
          const existingSlotIndex = userUpgrades.farmSlots.findIndex(
            (slot: any) => slot.slotId === slotId
          );
          
          if (existingSlotIndex >= 0) {
            // Increment existing slot level
            userUpgrades.farmSlots[existingSlotIndex].level += 1;
            // Update path name if it was changed
            userUpgrades.farmSlots[existingSlotIndex].upgradePath = upgradePath;
            userUpgrades.farmSlots[existingSlotIndex].pathName = pathName;
            userUpgrades.farmSlots[existingSlotIndex].timestamp = upgradeData.timestamp;
          } else {
            // Add new slot upgrade
            userUpgrades.farmSlots.push(upgradeData);
          }
          
          updatedUpgrades = await storage.updateBuildingUpgrades(userId, userUpgrades);
        } else {
          // Handle forge slots
          const existingSlotIndex = userUpgrades.forgeSlots.findIndex(
            (slot: any) => slot.slotId === slotId
          );
          
          if (existingSlotIndex >= 0) {
            // Increment existing slot level
            userUpgrades.forgeSlots[existingSlotIndex].level += 1;
            // Update path name if it was changed
            userUpgrades.forgeSlots[existingSlotIndex].upgradePath = upgradePath;
            userUpgrades.forgeSlots[existingSlotIndex].pathName = pathName;
            userUpgrades.forgeSlots[existingSlotIndex].timestamp = upgradeData.timestamp;
          } else {
            // Add new slot upgrade
            userUpgrades.forgeSlots.push(upgradeData);
          }
          
          updatedUpgrades = await storage.updateBuildingUpgrades(userId, userUpgrades);
        }
        
        return res.json({ 
          success: true, 
          upgrades: updatedUpgrades
        });
      } else {
        // Regular building upgrade
        if (!buildingId) {
          return res.status(400).json({ message: 'Missing required fields' });
        }
        
        const building = await storage.getBuildingById(buildingId);
        
        if (!building) {
          return res.status(404).json({ message: 'Building not found' });
        }
        
        // Update building level
        const updatedBuilding = await storage.upgradeBuilding(buildingId);
        
        return res.json({ 
          success: true, 
          building: updatedBuilding
        });
      }
    } catch (error) {
      console.error('Error upgrading building:', error);
      return res.status(500).json({ message: 'Failed to upgrade building' });
    }
  });
  
  // Get all building upgrades for current user
  app.get('/api/buildings/upgrades', authenticateUser, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      
      if (!userId) {
        return res.status(401).json({ message: 'User not authenticated' });
      }
      
      // Get all upgrades for this user
      const userUpgrades = await storage.getBuildingUpgradesByUserId(userId);
      
      if (!userUpgrades) {
        // Return empty default structure if no upgrades exist
        return res.json({
          farmSlots: [],
          forgeSlots: [],
          marketUpgrades: []
        });
      }
      
      return res.json(userUpgrades);
    } catch (error) {
      console.error('Error getting building upgrades:', error);
      return res.status(500).json({ message: 'Failed to get building upgrades' });
    }
  });
}


=== server/dungeon-routes.ts ===
import type { Express, Request, Response } from "express";
import { storage } from "./storage";
import { generateBattleLog } from "./new-battle-system";

/**
 * Process and generate a battle log for a dungeon run
 * @param run The dungeon run data
 * @param success Whether the run should succeed
 * @returns Battle log data
 */
async function processBattleLog(run: any, success: boolean): Promise<any[]> {
  // Check if we've already generated a battle log for this run
  if (run.battleLog && Array.isArray(run.battleLog) && run.battleLog.length > 0) {
    console.log('Using existing battle log for run', run.id);
    return run.battleLog;
  }
  
  // Process character IDs
  let characterIds: number[] = [];
  
  if (Array.isArray(run.characterIds)) {
    characterIds = run.characterIds;
  } else if (typeof run.characterIds === 'string') {
    try {
      characterIds = JSON.parse(run.characterIds);
    } catch (error) {
      console.error('Failed to parse character IDs:', error);
      characterIds = run.characterIds.split(',').map((id: string) => parseInt(id.trim()));
    }
  }
  
  console.log('Processing characters for battle log:', characterIds);
  
  // Set allies on run object for battle log generation
  run._allies = [];
  
  // Process each character
  for (const characterId of characterIds) {
    try {
      // Fetch character data
      const character = await storage.getCharacterById(characterId);
      
      if (!character) {
        console.warn(`Character ID ${characterId} not found, skipping...`);
        continue;
      }
      
      // Process auras for character
      const auras = await storage.getCharacterAuras(characterId);
      
      // Calculate aura bonuses
      const auraBonus = {
        attack: 0,
        vitality: 0,
        speed: 0,
        focus: 0,
        accuracy: 0,
        defense: 0,
        resilience: 0
      };
      
      if (auras && auras.length > 0) {
        auras.forEach(aura => {
          // Add stat bonuses directly from aura stats fields
          // Note: Auras are already filtered to only include those equipped on this character
          if (aura.attack) auraBonus.attack += aura.attack;
          if (aura.vitality) auraBonus.vitality += aura.vitality;
          if (aura.speed) auraBonus.speed += aura.speed;
          if (aura.focus) auraBonus.focus += aura.focus;
          if (aura.accuracy) auraBonus.accuracy += aura.accuracy;
          if (aura.defense) auraBonus.defense += aura.defense;
          if (aura.resilience) auraBonus.resilience += aura.resilience;
        });
      }
      
      // Create battle ally object with character data
      const ally = {
        id: `char-${character.id}`,
        name: character.name,
        level: character.level || 1,
        stats: {
          attack: character.attack || 10,
          vitality: character.vitality || 10,
          speed: character.speed || 10
        },
        auraBonus: Object.values(auraBonus).some(val => val > 0) ? auraBonus : null,
        skills: {
          basic: {
            name: "Basic Attack",
            damage: Math.floor((character.attack || 10) * 0.9),
            cooldown: 0
          },
          advanced: {
            name: "Quick Strike",
            damage: Math.floor((character.attack || 10) * 1.2),
            cooldown: 2
          },
          ultimate: {
            name: "Power Surge",
            damage: Math.floor((character.attack || 10) * 1.8),
            cooldown: 4
          }
        },
        // Set health values
        maxHp: (character.vitality || 10) * 8,
        hp: (character.vitality || 10) * 8,  // Start with full health
        attackMeter: 0,
        advancedSkillCooldown: 0,
        ultimateSkillCooldown: 0,
        statusEffects: []
      };
      
      // Add to allies list
      run._allies.push(ally);
    } catch (error) {
      console.error(`Error processing character ID ${characterId}:`, error);
    }
  }
  
  // Generate the battle log using the new battle system
  return await generateBattleLog(run, success);
}

/**
 * Register dungeon API routes
 * @param app Express application instance
 */
export function registerDungeonRoutes(app: Express) {
  // Get all dungeon types
  app.get('/api/dungeons/types', async (req: Request, res: Response) => {
    try {
      const dungeonTypes = await storage.getDungeonTypes();
      res.json(dungeonTypes);
    } catch (error) {
      console.error('Failed to fetch dungeon types:', error);
      res.status(500).json({ error: 'Failed to fetch dungeon types' });
    }
  });
  
  // Get all dungeon runs for the current user
  app.get('/api/dungeons/runs', async (req: Request, res: Response) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
      const runs = await storage.getDungeonRuns(req.session.userId);
      res.json(runs);
    } catch (error) {
      console.error('Failed to fetch dungeon runs:', error);
      res.status(500).json({ error: 'Failed to fetch dungeon runs' });
    }
  });
  
  // Start a new dungeon run
  app.post('/api/dungeons/start', async (req: Request, res: Response) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
      const { dungeonTypeId, dungeonName, dungeonLevel, characterIds, startTime, endTime } = req.body;
      
      if (!dungeonTypeId || !characterIds || characterIds.length === 0) {
        return res.status(400).json({ error: 'Missing required fields' });
      }
      
      // Get dungeon type to retrieve element
      const dungeonType = await storage.getDungeonTypeById(dungeonTypeId);
      
      // Create the dungeon run
      const runData = {
        userId: req.session.userId,
        dungeonTypeId,
        dungeonName: dungeonName || 'Unknown Dungeon',
        dungeonLevel: dungeonLevel || 1,
        elementalType: dungeonType?.elementalType || 'neutral',
        characterIds,
        startTime: startTime || new Date().toISOString(),
        endTime: endTime || new Date(Date.now() + 3600000).toISOString(), // Default 1 hour
        completed: false,
        success: false,
        battleLog: null,
        totalStages: 3 // Default to 3 stages for standard dungeons
      };
      
      const run = await storage.createDungeonRun(runData);
      res.status(201).json(run);
    } catch (error) {
      console.error('Failed to start dungeon run:', error);
      res.status(500).json({ error: 'Failed to start dungeon run' });
    }
  });
  
  // Get a specific dungeon run
  app.get('/api/dungeons/runs/:id', async (req: Request, res: Response) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
      const runId = parseInt(req.params.id);
      const run = await storage.getDungeonRunById(runId);
      
      if (!run) {
        return res.status(404).json({ error: 'Dungeon run not found' });
      }
      
      if (run.userId !== req.session.userId) {
        return res.status(403).json({ error: 'Unauthorized access to dungeon run' });
      }
      
      res.json(run);
    } catch (error) {
      console.error('Failed to fetch dungeon run:', error);
      res.status(500).json({ error: 'Failed to fetch dungeon run' });
    }
  });
  
  // Get battle log for a dungeon run
  app.get('/api/dungeons/runs/:id/battlelog', async (req: Request, res: Response) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
      const runId = parseInt(req.params.id);
      const run = await storage.getDungeonRunById(runId);
      
      if (!run) {
        return res.status(404).json({ error: 'Dungeon run not found' });
      }
      
      if (run.userId !== req.session.userId) {
        return res.status(403).json({ error: 'Unauthorized access to dungeon run' });
      }
      
      // If run is not completed, we need to check if it's time to complete it
      if (!run.completed && new Date(run.endTime) <= new Date()) {
        // Determine success randomly (70% chance of success for testing)
        const success = Math.random() < 0.7;
        
        // Process the battle log
        // Make sure we include totalStages in the run object
        run.totalStages = run.totalStages || 3; // Default to 3 stages
        
        const battleLog = await processBattleLog(run, success);
        
        // Mark as completed but don't save yet
        run.completed = true;
        run.success = success;
        run.battleLog = battleLog;
        
        // Return the battle log
        res.json(battleLog);
      } else if (run.battleLog) {
        // Return existing battle log
        res.json(run.battleLog);
      } else {
        // Generate a preliminary battle log (not saved)
        const preliminaryLog = [
          {
            type: 'system_message',
            message: 'The dungeon run is still in progress. Check back later for the battle log.',
            timestamp: Date.now()
          }
        ];
        res.json(preliminaryLog);
      }
    } catch (error) {
      console.error('Failed to fetch battle log:', error);
      res.status(500).json({ error: 'Failed to fetch battle log' });
    }
  });
  
  // Complete a dungeon run
  app.post('/api/dungeons/complete/:id', async (req: Request, res: Response) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
      const runId = parseInt(req.params.id);
      const run = await storage.getDungeonRunById(runId);
      
      if (!run) {
        return res.status(404).json({ error: 'Dungeon run not found' });
      }
      
      if (run.userId !== req.session.userId) {
        return res.status(403).json({ error: 'Unauthorized access to dungeon run' });
      }
      
      // If already completed, just return the run
      if (run.completed) {
        return res.json({ 
          success: run.success, 
          message: run.success ? 'Dungeon already completed successfully' : 'Dungeon was already failed'
        });
      }
      
      // Determine if run is successful (70% chance for testing)
      const success = Math.random() < 0.7;
      
      // Create a battle log if needed
      if (!run.battleLog) {
        // Make sure we include totalStages
        run.totalStages = run.totalStages || 3; // Default to 3 stages
        run.battleLog = await processBattleLog(run, success);
      }
      
      // Update run status
      const updatedRun = await storage.updateDungeonRun(runId, {
        completed: true,
        success,
        battleLog: run.battleLog
      });
      
      // TODO: Award rewards based on dungeon level and success/failure
      
      res.json({ 
        success, 
        message: success ? 'Dungeon completed successfully' : 'Dungeon run failed',
        updatedRun
      });
    } catch (error) {
      console.error('Failed to complete dungeon run:', error);
      res.status(500).json({ error: 'Failed to complete dungeon run' });
    }
  });
}

=== server/new-battle-system.ts ===
/**
 * New Battle System for The Forge
 * Deterministic implementation with improved architecture
 */

/**
 * Random Number Generator with seeding for deterministic results
 * This ensures dungeons always generate the same results when viewed multiple times
 */
class DeterministicRandom {
  private seed: number;
  private m: number = 2147483647;  // 2^31 - 1
  private a: number = 16807;       // 7^5
  private c: number = 0;

  constructor(seed: number) {
    this.seed = seed;
  }

  // Linear Congruential Generator formula: (a * seed + c) % m
  next(): number {
    this.seed = (this.a * this.seed + this.c) % this.m;
    return this.seed / this.m; // Normalize to [0, 1)
  }

  // Get random integer between min (inclusive) and max (exclusive)
  nextInt(min: number, max: number): number {
    return Math.floor(this.next() * (max - min) + min);
  }

  // Random boolean with probability
  nextBool(probability: number = 0.5): boolean {
    return this.next() < probability;
  }
}

// Global dungeon RNG
let dungeonRNG: DeterministicRandom;

/**
 * Type definitions for the battle system
 */

// Status effect applied to units in battle
export interface StatusEffect {
  name: string;           // Display name of the effect
  type: string;           // Effect type (burn, poison, slow, weaken, etc.)
  value: number;          // Magnitude of the effect
  duration: number;       // Remaining turns/actions
  source?: string;        // Source of the effect (character/skill name)
}

// Core battle unit (character or enemy)
export interface BattleUnit {
  id: string;             // Unique identifier 
  name: string;           // Display name
  hp: number;             // Current health points
  maxHp: number;          // Maximum health points
  attackMeter: number;    // Current attack meter progress (0-100)
  
  // Base stats
  stats: {
    attack: number;       // Base attack power
    vitality: number;     // Base vitality (affects max HP)
    speed: number;        // Base speed (affects attack meter fill rate)
    [key: string]: number; // Additional stats
  };
  
  // Combat skills
  skills: {
    basic: BattleSkill;   // Always available skill
    advanced: BattleSkill | null; // Skill with moderate cooldown
    ultimate: BattleSkill | null; // Powerful skill with long cooldown
    [key: string]: BattleSkill | null; // Additional skills
  };
  
  // Optional bonuses from auras
  auraBonus?: {
    attack: number;       // % bonus to attack
    vitality: number;     // % bonus to vitality
    speed: number;        // % bonus to speed
    focus?: number;       // % bonus to critical chance
    accuracy?: number;    // % reduction in miss chance
    defense?: number;     // % reduction in damage taken
    resilience?: number;  // % resistance to status effects
    element?: string;     // Elemental affinity
    [key: string]: any;   // Other bonuses
  } | null;
  
  // Gameplay state tracking
  advancedSkillCooldown: number;  // Turns until advanced skill is available
  ultimateSkillCooldown: number;  // Turns until ultimate skill is available
  statusEffects: StatusEffect[];  // Active status effects on this unit
}

// Skill definition
export interface BattleSkill {
  name: string;           // Display name
  damage: number;         // Base damage/healing value
  cooldown?: number;      // Turns between uses
  special?: string;       // Special effect type
  aoe?: boolean;          // Whether it hits multiple targets
}

// Combat action performed in battle
export interface BattleAction {
  actor: string;          // Name of the unit performing the action
  skill: string;          // Name of the skill used
  target: string;         // Name of the target unit
  damage: number;         // Amount of damage/healing done
  isCritical: boolean;    // Whether the hit was critical
  healing?: boolean;      // Whether this is a healing action
  message?: string;       // Display message for this action
  type?: string;          // Action type (attack, status, defeat, etc.)
}

// Battle log entry types
export interface BattleEvent {
  type: string;           // Event type (round, system_message, etc.)
  timestamp?: number;     // When this event occurred
  
  // Round-specific properties
  number?: number;            // Round number (when type === 'round')
  actions?: BattleAction[];   // Array of actions in this round
  remainingAllies?: number;   // Number of allies still alive after round
  remainingEnemies?: number;  // Number of enemies still alive after round
  
  // Stage progress properties
  allies?: BattleUnit[];      // All allies in battle
  enemies?: BattleUnit[];     // All enemies in battle
  currentStage?: number;      // Current dungeon stage
  totalStages?: number;       // Total stages in dungeon
  message?: string;           // Display message
  victory?: boolean;          // Whether the battle/stage was won
  summary?: string;           // Battle summary
  
  // System message
  system_message?: string;    // System message to display
  
  // Any other properties
  [key: string]: any;
}

/**
 * Generates appropriate enemy units based on dungeon level and current stage
 * @param dungeonLevel The level of the dungeon
 * @param element The elemental type of the dungeon
 * @param numEnemies The number of enemies to generate
 * @param currentStage The current stage number
 * @param totalStages The total number of stages in the dungeon
 * @returns Array of generated enemy units
 */
function generateEnemies(
  dungeonLevel: number, 
  element: string = 'neutral', 
  numEnemies: number = 3,
  currentStage: number = 1, 
  totalStages: number = 3
): BattleUnit[] {
  const enemies: BattleUnit[] = [];
  
  // Calculate stage progression and difficulty scaling
  // Difficulty increases as stages progress
  const stageProgress = currentStage / totalStages;
  const stageDifficultyMod = 1 + (stageProgress * 0.7); // 1.23 for stage 1/3, 1.47 for stage 2/3, 1.7 for stage 3/3
  
  // Scale base stats based on dungeon level and current stage
  const baseAttack = (8 + Math.floor(dungeonLevel * 1.5)) * stageDifficultyMod;
  const baseVitality = (10 + Math.floor(dungeonLevel * 1.4)) * stageDifficultyMod;
  const baseSpeed = (10 + Math.floor(dungeonLevel * 0.7)) * stageDifficultyMod;
  const baseHP = baseVitality * 8;
  
  // Potentially increase enemy count in later stages
  let actualNumEnemies = numEnemies;
  if (currentStage >= Math.ceil(totalStages * 0.7)) {
    // For the final 30% of stages, add an additional enemy (if we're not already at max)
    actualNumEnemies = Math.min(numEnemies + 1, 3);
  }
  
  // Generate enemies
  for (let i = 0; i < actualNumEnemies; i++) {
    // Determine enemy type - make the last enemy stronger
    // Define boss and elite criteria properly - only do this once with proper hierarchy
    const isFinalBoss = (currentStage === totalStages && i === actualNumEnemies - 1);
    const isStageBoss = (!isFinalBoss && i === actualNumEnemies - 1);
    const isElite = (!isFinalBoss && !isStageBoss && stageProgress > 0.5 && i === actualNumEnemies - 2);
    
    // Define enemy name based on type and element
    let enemyName = '';
    if (element === 'fire') {
      enemyName = isFinalBoss ? 'Infernal Overlord' : 
                 isStageBoss ? 'Flame Commander' :
                 isElite ? 'Flame Sentinel' : 'Fire Imp';
    } else if (element === 'ice') {
      enemyName = isFinalBoss ? 'Glacial Titan' :
                 isStageBoss ? 'Frost Lord' :
                 isElite ? 'Frost Giant' : 'Ice Elemental';
    } else if (element === 'nature') {
      enemyName = isFinalBoss ? 'Ancient Elderwood' :
                 isStageBoss ? 'Elder Treant' :
                 isElite ? 'Ancient Treant' : 'Thorn Beast';
    } else if (element === 'shadow') {
      enemyName = isFinalBoss ? 'Void Harbinger' :
                 isStageBoss ? 'Shadow Master' :
                 isElite ? 'Shadow Fiend' : 'Void Wraith';
    } else if (element === 'arcane') {
      enemyName = isFinalBoss ? 'Archmage Construct' :
                 isStageBoss ? 'Arcane Overseer' :
                 isElite ? 'Arcane Golem' : 'Magic Construct';
    } else {
      enemyName = isFinalBoss ? 'Dungeon Overlord' :
                 isStageBoss ? 'Dungeon Master' :
                 isElite ? 'Dungeon Guardian' : 'Dungeon Creature';
    }
    
    // Apply enemy strength multipliers
    const regularMultiplier = 1.0;
    const eliteMultiplier = isElite ? 1.5 : regularMultiplier;
    const stageBossMultiplier = isStageBoss ? 1.8 : eliteMultiplier;
    const finalBossMultiplier = isFinalBoss ? 2.2 : stageBossMultiplier;
    
    // Use the highest applicable multiplier
    const strengthMultiplier = isFinalBoss ? finalBossMultiplier : 
                               isStageBoss ? stageBossMultiplier : 
                               isElite ? eliteMultiplier : 
                               regularMultiplier;
    
    // Add stage number indicator ONLY for the final boss
    if (isFinalBoss) {
      enemyName = `Stage ${currentStage} ${enemyName}`;
    }
    
    // For regular stage bosses, just add the stage number
    if (isStageBoss) {
      enemyName = `${enemyName} (Stage ${currentStage})`;
    }
    
    // Create the enemy unit
    const enemy: BattleUnit = {
      id: `enemy-${i}`,
      name: enemyName,
      hp: Math.floor(baseHP * strengthMultiplier),
      maxHp: Math.floor(baseHP * strengthMultiplier),
      attackMeter: 0,
      stats: {
        attack: Math.floor(baseAttack * strengthMultiplier),
        vitality: Math.floor(baseVitality * strengthMultiplier),
        speed: Math.floor(baseSpeed * (isFinalBoss ? 1.1 : isStageBoss ? 1.0 : isElite ? 0.9 : 1.0)) 
      },
      skills: {
        basic: {
          name: isFinalBoss ? 'Devastating Strike' : 
                isStageBoss ? 'Powerful Strike' :
                isElite ? 'Strong Strike' : 'Strike',
          damage: Math.floor(baseAttack * 0.9 * strengthMultiplier)
        },
        advanced: (isElite || isStageBoss || stageProgress > 0.3) ? {
          name: `${element.charAt(0).toUpperCase() + element.slice(1)} Blast`,
          damage: Math.floor(baseAttack * 1.5 * strengthMultiplier),
          cooldown: 3
        } : null,
        ultimate: isFinalBoss ? {
          name: 'Annihilation',
          damage: Math.floor(baseAttack * 3.0 * strengthMultiplier),
          cooldown: 4
        } : isStageBoss ? {
          name: 'Overwhelming Force',
          damage: Math.floor(baseAttack * 2.5 * strengthMultiplier),
          cooldown: 5
        } : isElite ? {
          name: 'Powerful Attack',
          damage: Math.floor(baseAttack * 2.0 * strengthMultiplier),
          cooldown: 6
        } : null
      },
      advancedSkillCooldown: 0,
      ultimateSkillCooldown: 0,
      statusEffects: []
    };
    
    enemies.push(enemy);
  }
  
  console.log(`Created ${enemies.length} enemies for stage ${currentStage}/${totalStages}, difficulty mod: ${stageDifficultyMod.toFixed(2)}`);
  
  return enemies;
}

/**
 * Calculate whether an attack is a critical hit
 * @param attacker The attacking unit
 * @returns boolean indicating critical hit
 */
function isCriticalHit(attacker: BattleUnit): boolean {
  // Base critical chance (5%)
  let criticalChance = 5;
  
  // Apply focus bonus if available
  if (attacker.auraBonus?.focus) {
    criticalChance += attacker.auraBonus.focus;
  }
  
  // Cap critical chance at 30%
  criticalChance = Math.min(30, criticalChance);
  
  // Determine if critical hit occurs with deterministic RNG
  return dungeonRNG.next() * 100 < criticalChance;
}

/**
 * Calculate actual damage after applying critical hits and defenses
 * @param attacker The attacking unit
 * @param defender The defending unit
 * @param skill The skill being used
 * @returns Object containing damage and critical hit status
 */
function calculateDamage(attacker: BattleUnit, defender: BattleUnit, skill: BattleSkill): { damage: number, isCritical: boolean } {
  // Check for critical hit
  const critical = isCriticalHit(attacker);
  
  // Base damage from skill
  let damage = skill.damage;
  
  // Apply critical multiplier if applicable
  if (critical) {
    damage = Math.floor(damage * 1.5);
  }
  
  // Apply defender's defense if available
  if (defender.auraBonus?.defense) {
    const damageReduction = defender.auraBonus.defense / 100;
    damage = Math.floor(damage * (1 - Math.min(0.5, damageReduction))); // Cap damage reduction at 50%
  }
  
  // Ensure minimum damage of 1
  damage = Math.max(1, damage);
  
  return { damage, isCritical: critical };
}

/**
 * Process a single round of battle
 * @param allies List of ally units
 * @param enemies List of enemy units
 * @param roundNumber The current round number
 * @returns A battle event containing the round's actions
 */
function processRound(allies: BattleUnit[], enemies: BattleUnit[], roundNumber: number): BattleEvent {
  const actions: BattleAction[] = [];
  
  // Get all living units
  const livingAllies = allies.filter(unit => unit.hp > 0);
  const livingEnemies = enemies.filter(unit => unit.hp > 0);
  
  // If either side is defeated, end the round immediately
  if (livingAllies.length === 0 || livingEnemies.length === 0) {
    return {
      type: 'round',
      number: roundNumber,
      actions: [],
      remainingAllies: livingAllies.length,
      remainingEnemies: livingEnemies.length,
      timestamp: Date.now()
    };
  }
  
  // For simplicity, each living ally attacks a random living enemy
  for (const ally of livingAllies) {
    // Skip if no living enemies remain
    if (livingEnemies.length === 0) break;
    
    // Select a random living enemy using deterministic RNG
    const targetIndex = dungeonRNG.nextInt(0, livingEnemies.length);
    const target = livingEnemies[targetIndex];
    
    // Determine which skill to use (simple implementation)
    let skill = ally.skills.basic;
    
    // Try to use ultimate skill if available
    if (ally.skills.ultimate && ally.ultimateSkillCooldown === 0) {
      skill = ally.skills.ultimate;
      ally.ultimateSkillCooldown = skill.cooldown || 5;
    } 
    // Try to use advanced skill if available
    else if (ally.skills.advanced && ally.advancedSkillCooldown === 0) {
      skill = ally.skills.advanced;
      ally.advancedSkillCooldown = skill.cooldown || 3;
    }
    
    // Calculate damage
    const { damage, isCritical } = calculateDamage(ally, target, skill);
    
    // Apply damage to target
    target.hp = Math.max(0, target.hp - damage);
    
    // Record the action
    actions.push({
      actor: ally.name,
      skill: skill.name,
      target: target.name,
      damage,
      isCritical
    });
    
    // Remove target from living enemies if defeated
    if (target.hp <= 0) {
      livingEnemies.splice(targetIndex, 1);
    }
  }
  
  // For simplicity, each living enemy attacks a random living ally
  for (const enemy of enemies.filter(unit => unit.hp > 0)) {
    // Skip if no living allies remain
    if (livingAllies.length === 0) break;
    
    // Select a random living ally using deterministic RNG
    const targetIndex = dungeonRNG.nextInt(0, livingAllies.length);
    const target = livingAllies[targetIndex];
    
    // Determine which skill to use (simple implementation)
    let skill = enemy.skills.basic;
    
    // Try to use ultimate skill if available
    if (enemy.skills.ultimate && enemy.ultimateSkillCooldown === 0) {
      skill = enemy.skills.ultimate;
      enemy.ultimateSkillCooldown = skill.cooldown || 5;
    } 
    // Try to use advanced skill if available
    else if (enemy.skills.advanced && enemy.advancedSkillCooldown === 0) {
      skill = enemy.skills.advanced;
      enemy.advancedSkillCooldown = skill.cooldown || 3;
    }
    
    // Calculate damage
    const { damage, isCritical } = calculateDamage(enemy, target, skill);
    
    // Apply damage to target
    target.hp = Math.max(0, target.hp - damage);
    
    // Record the action
    actions.push({
      actor: enemy.name,
      skill: skill.name,
      target: target.name,
      damage,
      isCritical
    });
    
    // Remove target from living allies if defeated
    if (target.hp <= 0) {
      livingAllies.splice(targetIndex, 1);
    }
  }
  
  // Decrement cooldowns
  for (const unit of [...allies, ...enemies]) {
    if (unit.advancedSkillCooldown > 0) unit.advancedSkillCooldown--;
    if (unit.ultimateSkillCooldown > 0) unit.ultimateSkillCooldown--;
  }
  
  // Return the round event
  return {
    type: 'round',
    number: roundNumber,
    actions,
    remainingAllies: livingAllies.length,
    remainingEnemies: livingEnemies.length,
    timestamp: Date.now()
  };
}

/**
 * Primary function to generate a battle log for a dungeon run
 * @param run The dungeon run data including characters and dungeon info
 * @param success Whether the run is predetermined to succeed
 * @returns A complete battle log with all events
 */
export async function generateBattleLog(run: any, success: boolean): Promise<BattleEvent[]> {
  console.log('Generating battle log for run:', run.id);
  console.log('Success preset:', success);
  
  // Initialize deterministic random generator with a seed based on dungeon run ID and creation time
  // This ensures the same dungeon will always generate the same battle sequence
  const seed = run.id * 1000 + (new Date(run.createdAt || Date.now()).getTime() % 1000);
  dungeonRNG = new DeterministicRandom(seed);
  console.log(`Initialized deterministic RNG with seed: ${seed}`);
  
  // Create an empty battle log
  const battleLog: BattleEvent[] = [];
  
  // Add initialization message
  battleLog.push({
    type: 'system_message',
    message: 'Initializing battle system...',
    timestamp: Date.now()
  });
  
  // Extract allies from the run (this should be from _allies prepared in the routes file)
  const allies = run._allies || [];
  
  // If no allies, add an error message and return
  if (allies.length === 0) {
    battleLog.push({
      type: 'system_message',
      message: 'No characters found for this dungeon run.',
      timestamp: Date.now()
    });
    return battleLog;
  }
  
  // Determine dungeon parameters
  const dungeonLevel = run.dungeonLevel || 1;
  const dungeonElement = run.element || 'neutral';
  
  // Create enemies based on dungeon level (adjust number based on ally count)
  const numEnemies = Math.min(5, Math.max(2, allies.length));
  // Determine total stages 
  const totalStages = run.totalStages || 3; // Default to 3 stages if not specified
  // Generate enemies for first stage
  const enemies = generateEnemies(dungeonLevel, dungeonElement, numEnemies, 1, totalStages);
  
  // Add battle start event
  battleLog.push({
    type: 'battle_start',
    allies,
    enemies,
    message: `A battle begins in a level ${dungeonLevel} ${dungeonElement} dungeon!`,
    timestamp: Date.now()
  });
  
  // Determine number of rounds based on success/failure and force the outcome if needed
  const maxRounds = 10; // Maximum number of rounds to simulate
  let roundNumber = 1;
  
  // If success is predetermined but unlikely with fair battle, boost allies
  if (success) {
    allies.forEach((ally: BattleUnit) => {
      ally.stats.attack = Math.floor(ally.stats.attack * 1.2); // Boost attack by 20%
      ally.hp = ally.maxHp; // Ensure full health
    });
  }
  
  // If failure is predetermined but unlikely with fair battle, boost enemies
  if (!success) {
    enemies.forEach(enemy => {
      enemy.stats.attack = Math.floor(enemy.stats.attack * 1.3); // Boost attack by 30%
    });
  }
  
  // Simulate battle rounds
  let battleOngoing = true;
  while (battleOngoing && roundNumber <= maxRounds) {
    // Process the round
    const roundEvent = processRound(allies, enemies, roundNumber);
    battleLog.push(roundEvent);
    
    // Check if battle is over
    if (roundEvent.remainingAllies === 0 || roundEvent.remainingEnemies === 0) {
      battleOngoing = false;
    }
    
    // Move to next round
    roundNumber++;
  }
  
  // Force the outcome if it doesn't match the predetermined result
  let livingAllies = allies.filter((unit: BattleUnit) => unit.hp > 0);
  const livingEnemies = enemies.filter((unit: BattleUnit) => unit.hp > 0);
  
  const actualSuccess = livingEnemies.length === 0;
  
  // If the outcome doesn't match the predetermined result, add a twist
  if (actualSuccess !== success) {
    if (success) {
      // Force a success by defeating remaining enemies
      battleLog.push({
        type: 'system_message',
        message: 'A mysterious energy surges through your party, giving them renewed strength!',
        timestamp: Date.now()
      });
      
      // Final heroic round
      livingEnemies.forEach(enemy => {
        // Defeat enemy
        enemy.hp = 0;
        
        // Random ally lands the finishing blow using deterministic RNG
        const randomAlly = livingAllies[dungeonRNG.nextInt(0, livingAllies.length)];
        
        battleLog.push({
          type: 'round',
          number: roundNumber++,
          actions: [{
            actor: randomAlly.name,
            skill: 'Heroic Surge',
            target: enemy.name,
            damage: enemy.maxHp,
            isCritical: true,
            message: `${randomAlly.name} delivers a devastating final blow!`
          }],
          remainingAllies: livingAllies.length,
          remainingEnemies: 0,
          timestamp: Date.now()
        });
      });
    } else {
      // Force a failure with a surprise attack
      battleLog.push({
        type: 'system_message',
        message: 'The dungeon reveals a hidden trap!',
        timestamp: Date.now()
      });
      
      // Defeat all allies with a trap
      livingAllies.forEach((ally: BattleUnit) => {
        ally.hp = 0;
      });
      
      battleLog.push({
        type: 'round',
        number: roundNumber++,
        actions: [{
          actor: 'Dungeon Trap',
          skill: 'Deadly Mechanism',
          target: 'Party',
          damage: 9999,
          isCritical: true,
          message: 'A hidden mechanism activates, overwhelming the entire party!'
        }],
        remainingAllies: 0,
        remainingEnemies: livingEnemies.length,
        timestamp: Date.now()
      });
    }
  }
  
  // Set up multi-stage dungeon progression using totalStages declared above
  let currentStage = 1;
  let stagesCompleted = 0;
  let partyDefeated = livingAllies.length === 0;
  
  console.log(`[STAGE SETUP] Starting dungeon with ${totalStages} total stages`);
  console.log(`[STAGE SETUP] Initial living allies: ${livingAllies.length}`);
  console.log(`[STAGE SETUP] Party defeated status: ${partyDefeated}`);
  
  // Process all stages of the dungeon
  if (!partyDefeated) {
    console.log(`[DUNGEON] Starting to process all dungeon stages (Total: ${totalStages})`);
    
    // First stage has just been simulated above - check if it was successful
    const firstStageEnemiesRemaining = enemies.filter(unit => unit.hp > 0).length;
    
    if (firstStageEnemiesRemaining === 0) {
      // First stage was successful
      console.log(`[STAGE ${currentStage}] First stage successfully completed`);
      stagesCompleted++;
      
      // Add stage completion event
      battleLog.push({
        type: 'stage_complete',
        currentStage,
        totalStages,
        message: `Stage ${currentStage} completed! Preparing for the next challenge...`,
        aliveAllies: livingAllies,
        timestamp: Date.now()
      });
    } else {
      console.log(`[STAGE ${currentStage}] First stage incomplete - enemies remaining: ${firstStageEnemiesRemaining}`);
      console.log(`[STAGE ${currentStage}] Living allies: ${livingAllies.length}`);
      
      // Add battle event indicating first stage isn't complete yet
      battleLog.push({
        type: 'system_message',
        message: `The battle continues with the first stage...`,
        timestamp: Date.now()
      });
      
      // Don't proceed to next stage since first stage isn't complete
      partyDefeated = true;
    }
    
    // Process additional stages if first stage was successful
    while (currentStage < totalStages && !partyDefeated) {
      currentStage++;
      
      // Generate new enemies for this stage (with appropriate difficulty scaling)
      const stageEnemies = generateEnemies(
        dungeonLevel + Math.floor(currentStage / 2), 
        dungeonElement,
        numEnemies,
        currentStage,  // Pass current stage number
        totalStages    // Pass total stages
      );
      
      // Add stage start event
      battleLog.push({
        type: 'stage_start',
        currentStage,
        totalStages,
        enemies: stageEnemies,
        message: `Stage ${currentStage} begins! New enemies approach...`,
        timestamp: Date.now()
      });
      
      // Reset existing enemies for the battle simulation
      enemies.length = 0;
      stageEnemies.forEach(enemy => enemies.push(enemy));
      
      // Simulate battle for this stage
      battleOngoing = true;
      roundNumber = 1;
      
      while (battleOngoing && roundNumber <= maxRounds) {
        // Process the round
        const roundEvent = processRound(livingAllies, enemies, roundNumber);
        battleLog.push(roundEvent);
        
        // Check battle status after the round
        console.log(`[STAGE ${currentStage}] Round ${roundNumber}: ${roundEvent.remainingAllies} allies vs ${roundEvent.remainingEnemies} enemies`);
        
        // Check if battle is over
        if (roundEvent.remainingAllies === 0 || roundEvent.remainingEnemies === 0) {
          console.log(`[STAGE ${currentStage}] Battle ended after round ${roundNumber}`);
          battleOngoing = false;
        }
        
        // Move to next round
        roundNumber++;
      }
      
      // If battle reached max rounds limit without resolution
      if (battleOngoing && roundNumber > maxRounds) {
        console.log(`[STAGE ${currentStage}] Battle reached max rounds (${maxRounds}) without resolution`);
      }
      
      // Update living allies and enemies after this stage
      const updatedLivingAllies = livingAllies.filter((unit: BattleUnit) => unit.hp > 0);
      const updatedLivingEnemies = enemies.filter((unit: BattleUnit) => unit.hp > 0);
      
      console.log(`[STAGE ${currentStage}] After battle: ${updatedLivingAllies.length} allies alive, ${updatedLivingEnemies.length} enemies alive`);
      
      // Check if party defeated
      if (updatedLivingAllies.length === 0) {
        partyDefeated = true;
        console.log(`[STAGE ${currentStage}] Party defeated, ending dungeon progression`);
        
        // Add defeat message
        battleLog.push({
          type: 'system_message',
          message: `Your party has been defeated at stage ${currentStage}!`,
          timestamp: Date.now()
        });
      } 
      // Check if stage cleared
      else if (updatedLivingEnemies.length === 0) {
        // Stage completed
        stagesCompleted++;
        console.log(`[STAGE ${currentStage}] Stage completed! Stages completed: ${stagesCompleted}/${totalStages}`);
        
        // Add stage completion event
        battleLog.push({
          type: 'stage_complete',
          currentStage,
          totalStages,
          message: `Stage ${currentStage} completed!${currentStage === totalStages ? ' You have conquered the dungeon!' : ' Preparing for the next challenge...'}`,
          aliveAllies: updatedLivingAllies, // Pass the updated allies array
          timestamp: Date.now()
        });
        
        // IMPORTANT FIX: Replace the livingAllies array for the next stage
        // This ensures living allies are properly tracked between stages
        livingAllies = [...updatedLivingAllies];
        
        // No HP restoration between stages as requested
        console.log(`[STAGE ${currentStage}] ${livingAllies.length} allies preparing for next stage`);
      } else {
        // Something unexpected happened - both allies and enemies still alive after max rounds
        console.log(`[STAGE ${currentStage}] WARNING: Battle ended without clear victor after max rounds`);
        console.log(`[STAGE ${currentStage}] ${updatedLivingAllies.length} allies vs ${updatedLivingEnemies.length} enemies`);
      }
    }
  }
  
  // Scale rewards based on stages completed
  const rewardMultiplier = Math.max(0.3, stagesCompleted / totalStages);
  
  // Add final battle end event with all stages information
  const victorious = success; // Use the predetermined outcome
  
  console.log(`[BATTLE END] Stages completed: ${stagesCompleted}/${totalStages}`);
  console.log(`[BATTLE END] Living allies remaining: ${livingAllies.length}`);
  console.log(`[BATTLE END] Party defeated status: ${partyDefeated}`);
  console.log(`[BATTLE END] Predetermined outcome (success): ${success}`);
  
  // Override stages completed if needed to ensure the success outcome
  if (victorious && stagesCompleted < totalStages && !partyDefeated) {
    console.log(`[BATTLE END] Overriding stages completed from ${stagesCompleted} to ${totalStages} to match predetermined success`);
    stagesCompleted = totalStages;
  }
  
  battleLog.push({
    type: 'battle_end',
    victory: victorious,
    completedStages: stagesCompleted,
    totalStages,
    rewardMultiplier,
    summary: victorious
      ? `Victory! Your party completed ${stagesCompleted} of ${totalStages} stages.`
      : `Defeat! Your party completed ${stagesCompleted} of ${totalStages} stages before being overwhelmed.`,
    timestamp: Date.now()
  });
  
  return battleLog;
}

=== shared/schema.ts ===
import { pgTable, text, serial, integer, boolean, timestamp, json, jsonb, primaryKey } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";

// User model
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  discordId: text("discord_id").notNull().unique(),
  username: text("username").notNull(),
  avatarUrl: text("avatar_url"),
  roles: text("roles").array(),
  lastLogin: timestamp("last_login").defaultNow(),
  forgeTokens: integer("forge_tokens").default(0),
  rogueCredits: integer("rogue_credits").default(0),
  soulShards: integer("soul_shards").default(0),
  townhallLevel: integer("townhall_level").default(1),
  forgeLevel: integer("forge_level").default(1),
  blackMarketLevel: integer("black_market_level").default(1),
  bountyBoardLevel: integer("bounty_board_level").default(1),
  tavernLevel: integer("tavern_level").default(1),
  isAdmin: boolean("is_admin").default(false),
});

// Character model
export const characters = pgTable("characters", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  name: text("name").notNull(),
  level: integer("level").default(1),
  class: text("class").notNull(),
  avatarUrl: text("avatar_url").notNull(),
  equippedAuraId: integer("equipped_aura_id"),
  attack: integer("attack").default(100),
  accuracy: integer("accuracy").default(100),
  vitality: integer("vitality").default(100),
  defense: integer("defense").default(100),
  speed: integer("speed").default(100),
  focus: integer("focus").default(100),
  resilience: integer("resilience").default(100),
  health: integer("health").default(100),
  intelligence: integer("intelligence").default(100),
  luck: integer("luck").default(100),
  passiveSkills: jsonb("passive_skills").array(), // Array of passive skills with name and description
  isActive: boolean("is_active").default(false),
  activityType: text("activity_type"), // 'farming', 'dungeon', null
  activityEndTime: timestamp("activity_end_time"),
});

// Aura model
export const auras = pgTable("auras", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  name: text("name").notNull(),
  level: integer("level").default(1),
  element: text("element").notNull(), // fire, water, earth, wind
  tier: integer("tier").default(1),
  // Stat bonuses range from -10 to +10 (representing percentage)
  attack: integer("attack").default(0),
  accuracy: integer("accuracy").default(0),
  defense: integer("defense").default(0),
  vitality: integer("vitality").default(0),
  speed: integer("speed").default(0),
  focus: integer("focus").default(0),
  resilience: integer("resilience").default(0),
  skills: jsonb("skills").array(),
  equippedByCharacterId: integer("equipped_by_character_id"),
  isFusing: boolean("is_fusing").default(false),
  fusionEndTime: timestamp("fusion_end_time"),
  fusionSource: boolean("fusion_source").default(false), // Whether this aura was created via fusion
  creatorCharacterId: integer("creator_character_id"), // Character that created this aura
});

// Resource model
export const resources = pgTable("resources", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  name: text("name").notNull(),
  type: text("type").notNull(), // material, currency, upgrade
  quantity: integer("quantity").default(0),
  description: text("description"),
  iconUrl: text("icon_url"),
});

// Farming task model
export const farmingTasks = pgTable("farming_tasks", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  characterId: integer("character_id").notNull(),
  resourceName: text("resource_name").notNull(),
  startTime: timestamp("start_time").defaultNow(),
  endTime: timestamp("end_time").notNull(),
  completed: boolean("completed").default(false),
  slotIndex: integer("slot_index").notNull(),
});

// Dungeon run model
export const dungeonTypes = pgTable("dungeon_types", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  elementalType: text("elemental_type").notNull(), // fire, water, earth, wind
  difficulty: text("difficulty").notNull(), // easy, medium, hard, elite, legendary
  recommendedLevel: integer("recommended_level").notNull(),
  stages: integer("stages").default(8).notNull(),
  imageUrl: text("image_url"),
  rewardTiers: jsonb("reward_tiers"),
  specificDrops: jsonb("specific_drops"),
});

export const dungeonRuns = pgTable("dungeon_runs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  dungeonTypeId: integer("dungeon_type_id").notNull(),
  dungeonName: text("dungeon_name").notNull(),
  dungeonLevel: integer("dungeon_level").notNull(),
  elementalType: text("elemental_type").notNull(),
  characterIds: integer("character_ids").array().notNull(),
  startTime: timestamp("start_time").defaultNow(),
  endTime: timestamp("end_time").notNull(),
  completed: boolean("completed").default(false),
  success: boolean("success"),
  completedStages: integer("completed_stages").default(0),
  totalStages: integer("total_stages").default(8),
  rewards: jsonb("rewards"),
  rollValue: integer("roll_value"),
  rewardTier: integer("reward_tier"),
  battleLog: jsonb("battle_log"),
});

// Forging task model
export const forgingTasks = pgTable("forging_tasks", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  characterId: integer("character_id").notNull(), // Character assigned to this task
  taskType: text("task_type").notNull(), // 'craft', 'fusion'
  primaryAuraId: integer("primary_aura_id"),
  secondaryAuraId: integer("secondary_aura_id"),
  targetElement: text("target_element"),
  requiredMaterials: jsonb("required_materials"),
  startTime: timestamp("start_time").defaultNow(),
  endTime: timestamp("end_time").notNull(),
  completed: boolean("completed").default(false),
  resultAuraId: integer("result_aura_id"),
});

// Black Market listing model
export const blackMarketListings = pgTable("black_market_listings", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  itemType: text("item_type").notNull(), // 'character', 'aura', 'resource'
  itemId: integer("item_id").notNull(),
  itemData: jsonb("item_data"),
  price: integer("price").notNull(),
  currencyType: text("currency_type").notNull(), // 'forgeTokens', 'rogueCredits'
  createdAt: timestamp("created_at").defaultNow(),
  expiresAt: timestamp("expires_at"),
  sold: boolean("sold").default(false),
  featured: boolean("featured").default(false),
  isPremium: boolean("is_premium").default(false),
  listedAt: timestamp("listed_at").defaultNow(),
});

// Bounty quest model
export const bountyQuests = pgTable("bounty_quests", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  requirements: jsonb("requirements").notNull(),
  rewards: jsonb("rewards").notNull(),
  difficulty: text("difficulty").notNull(), // 'easy', 'medium', 'hard', 'epic'
  frequency: text("frequency").default('daily'), // 'daily', 'weekly'
  createdAt: timestamp("created_at").defaultNow(),
  expiresAt: timestamp("expires_at").notNull(),
  completed: boolean("completed").default(false),
});

// Building upgrade model
export const buildingUpgrades = pgTable("building_upgrades", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  buildingType: text("building_type").notNull(), // 'townhall', 'forge', 'blackmarket', etc.
  currentLevel: integer("current_level").notNull(),
  upgradeStartTime: timestamp("upgrade_start_time"),
  upgradeEndTime: timestamp("upgrade_end_time"),
  upgradeInProgress: boolean("upgrade_in_progress").default(false),
  unlockedSkills: text("unlocked_skills").array(),
  availableSkillPoints: integer("available_skill_points").default(0),
  skillDistribution: jsonb("skill_distribution"), // Stores skill point allocation for each building
});

// Activity log model
export const activityLogs = pgTable("activity_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  activityType: text("activity_type").notNull(),
  description: text("description").notNull(),
  timestamp: timestamp("timestamp").defaultNow(),
  relatedIds: jsonb("related_ids"),
});

// Define relations between tables
export const usersRelations = relations(users, ({ many }) => ({
  characters: many(characters),
  auras: many(auras),
  resources: many(resources),
  farmingTasks: many(farmingTasks),
  dungeonRuns: many(dungeonRuns),
  forgingTasks: many(forgingTasks),
  blackMarketListings: many(blackMarketListings),
  bountyQuests: many(bountyQuests),
  buildingUpgrades: many(buildingUpgrades),
  activityLogs: many(activityLogs),
}));

export const charactersRelations = relations(characters, ({ one, many }) => ({
  user: one(users, {
    fields: [characters.userId],
    references: [users.id],
  }),
  equippedAura: one(auras, {
    fields: [characters.equippedAuraId],
    references: [auras.id],
  }),
  farmingTasks: many(farmingTasks),
  forgingTasks: many(forgingTasks),
}));

export const aurasRelations = relations(auras, ({ one }) => ({
  user: one(users, {
    fields: [auras.userId],
    references: [users.id],
  }),
  equippedByCharacter: one(characters, {
    fields: [auras.equippedByCharacterId],
    references: [characters.id],
  }),
  creatorCharacter: one(characters, {
    fields: [auras.creatorCharacterId],
    references: [characters.id],
  }),
}));

export const resourcesRelations = relations(resources, ({ one }) => ({
  user: one(users, {
    fields: [resources.userId],
    references: [users.id],
  }),
}));

export const farmingTasksRelations = relations(farmingTasks, ({ one }) => ({
  user: one(users, {
    fields: [farmingTasks.userId],
    references: [users.id],
  }),
  character: one(characters, {
    fields: [farmingTasks.characterId],
    references: [characters.id],
  }),
}));

export const dungeonTypesRelations = relations(dungeonTypes, ({ many }) => ({
  dungeonRuns: many(dungeonRuns)
}));

export const dungeonRunsRelations = relations(dungeonRuns, ({ one }) => ({
  user: one(users, {
    fields: [dungeonRuns.userId],
    references: [users.id],
  }),
  dungeonType: one(dungeonTypes, {
    fields: [dungeonRuns.dungeonTypeId],
    references: [dungeonTypes.id],
  }),
}));

export const forgingTasksRelations = relations(forgingTasks, ({ one }) => ({
  user: one(users, {
    fields: [forgingTasks.userId],
    references: [users.id],
  }),
  character: one(characters, {
    fields: [forgingTasks.characterId],
    references: [characters.id],
  }),
  primaryAura: one(auras, {
    fields: [forgingTasks.primaryAuraId],
    references: [auras.id],
  }),
  secondaryAura: one(auras, {
    fields: [forgingTasks.secondaryAuraId],
    references: [auras.id],
  }),
  resultAura: one(auras, {
    fields: [forgingTasks.resultAuraId],
    references: [auras.id],
  }),
}));

export const blackMarketListingsRelations = relations(blackMarketListings, ({ one }) => ({
  user: one(users, {
    fields: [blackMarketListings.userId],
    references: [users.id],
  }),
}));

export const bountyQuestsRelations = relations(bountyQuests, ({ one }) => ({
  user: one(users, {
    fields: [bountyQuests.userId],
    references: [users.id],
  }),
}));

export const buildingUpgradesRelations = relations(buildingUpgrades, ({ one }) => ({
  user: one(users, {
    fields: [buildingUpgrades.userId],
    references: [users.id],
  }),
}));

export const activityLogsRelations = relations(activityLogs, ({ one }) => ({
  user: one(users, {
    fields: [activityLogs.userId],
    references: [users.id],
  }),
}));

// Metadata model for storing key-value pairs
export const metadata = pgTable("metadata", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  key: text("key").notNull(),
  value: text("value").notNull(),
});

export const metadataRelations = relations(metadata, ({ one }) => ({
  user: one(users, {
    fields: [metadata.userId],
    references: [users.id],
  }),
}));

// Define insert schemas for each model
export const insertUserSchema = createInsertSchema(users).omit({ id: true });
export const insertCharacterSchema = createInsertSchema(characters).omit({ id: true });
export const insertAuraSchema = createInsertSchema(auras).omit({ id: true });
export const insertResourceSchema = createInsertSchema(resources).omit({ id: true });
export const insertFarmingTaskSchema = createInsertSchema(farmingTasks).omit({ id: true });
export const insertDungeonTypeSchema = createInsertSchema(dungeonTypes).omit({ id: true });
export const insertDungeonRunSchema = createInsertSchema(dungeonRuns).omit({ id: true });
export const insertForgingTaskSchema = createInsertSchema(forgingTasks).omit({ id: true });
export const insertBlackMarketListingSchema = createInsertSchema(blackMarketListings).omit({ id: true });
export const insertBountyQuestSchema = createInsertSchema(bountyQuests).omit({ id: true });
export const insertBuildingUpgradeSchema = createInsertSchema(buildingUpgrades).omit({ id: true });
export const insertActivityLogSchema = createInsertSchema(activityLogs).omit({ id: true });
export const insertMetadataSchema = createInsertSchema(metadata).omit({ id: true });

// Define types for each model
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type Character = typeof characters.$inferSelect;
export type InsertCharacter = z.infer<typeof insertCharacterSchema>;

export type Aura = typeof auras.$inferSelect;
export type InsertAura = z.infer<typeof insertAuraSchema>;

export type Resource = typeof resources.$inferSelect;
export type InsertResource = z.infer<typeof insertResourceSchema>;

export type FarmingTask = typeof farmingTasks.$inferSelect;
export type InsertFarmingTask = z.infer<typeof insertFarmingTaskSchema>;

export type DungeonType = typeof dungeonTypes.$inferSelect;
export type InsertDungeonType = z.infer<typeof insertDungeonTypeSchema>;

export type DungeonRun = typeof dungeonRuns.$inferSelect;
export type InsertDungeonRun = z.infer<typeof insertDungeonRunSchema>;

export type ForgingTask = typeof forgingTasks.$inferSelect;
export type InsertForgingTask = z.infer<typeof insertForgingTaskSchema>;

export type BlackMarketListing = typeof blackMarketListings.$inferSelect;
export type InsertBlackMarketListing = z.infer<typeof insertBlackMarketListingSchema>;

export type BountyQuest = typeof bountyQuests.$inferSelect;
export type InsertBountyQuest = z.infer<typeof insertBountyQuestSchema>;

export type BuildingUpgrade = typeof buildingUpgrades.$inferSelect;
export type InsertBuildingUpgrade = z.infer<typeof insertBuildingUpgradeSchema>;

export type ActivityLog = typeof activityLogs.$inferSelect;
export type InsertActivityLog = z.infer<typeof insertActivityLogSchema>;

export type Metadata = typeof metadata.$inferSelect;
export type InsertMetadata = z.infer<typeof insertMetadataSchema>;
